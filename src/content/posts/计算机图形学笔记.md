---
title: 计算机图形学笔记
published: 2025-07-21 23:58:30
description: '学习笔记'
tags: ["C++", "编程", "计算机图形学", "OpenGL"]
category: '学习笔记'
---
<!--more-->
## 计算机图形学入门教程 📚

从数学原理到工程实现的完整知识体系

> **基于GAMES101课程与实践项目的深度解析**
> 涵盖理论推导、算法实现、工程优化的全方位教程

## 📋 **完整目录**

### 第一部分：数学基础与理论根基 🧮

1. [线性代数基础](#线性代数基础) - 向量、矩阵、齐次坐标系统
2. [几何变换数学原理](#几何变换数学原理) - 平移、旋转、缩放的数学本质
3. [投影几何学](#投影几何学) - 透视投影与视图变换的完整推导
4. [微积分在图形学中的应用](#微积分在图形学中的应用) - 曲线曲率与渲染积分

### 第二部分：光栅化渲染管线 🎨

1. [图形渲染管线概述](#图形渲染管线概述) - 现代GPU管线架构
2. [顶点处理与变换](#顶点处理与变换) - MVP变换链与顶点着色器
3. [图元装配与裁剪](#图元装配与裁剪) - 视锥体裁剪算法详解
4. [光栅化算法详解](#光栅化算法详解) - 三角形光栅化与重心坐标
5. [深度测试与隐藏面消除](#深度测试与隐藏面消除) - Z-Buffer算法与优化
6. [光照模型与着色](#光照模型与着色) - Phong模型到PBR的演进
7. [纹理映射技术](#纹理映射技术) - Mipmap、法线贴图与环境映射

### 第三部分：几何建模与处理 📐

1. [参数曲线理论](#参数曲线理论) - 参数化表示的数学基础
2. [贝塞尔曲线深度解析](#贝塞尔曲线深度解析) - de Casteljau算法与工程实现
3. [样条曲线与曲面](#样条曲线与曲面) - B样条与NURBS理论
4. [网格几何处理](#网格几何处理) - 半边结构与网格算法

### 第四部分：光线追踪与全局光照 ☀️

1. [光线追踪基础理论](#光线追踪基础理论) - 渲染方程与Whitted光线追踪
2. [光线-几何体相交算法](#光线-几何体相交算法) - 数学推导与数值稳定性
3. [空间加速数据结构](#空间加速数据结构) - BVH与KD-Tree构建算法
4. [蒙特卡洛方法与积分](#蒙特卡洛方法与积分) - 重要性采样与方差减少
5. [全局光照与路径追踪](#全局光照与路径追踪) - 路径追踪算法实现

### 第五部分：动画与物理仿真 🎬

1. [动画基础理论](#动画基础理论) - 关键帧插值与运动学
2. [物理仿真数学基础](#物理仿真数学基础) - 牛顿力学与约束系统
3. [质点弹簧系统](#质点弹簧系统) - 弹性力学与碰撞检测
4. [数值积分方法](#数值积分方法) - 欧拉法到Runge-Kutta的演进

### 第六部分：现代图形学前沿 🚀

1. [实时渲染优化技术](#实时渲染优化技术) - LOD、遮挡剔除与GPU优化
2. [基于物理的渲染(PBR)](#基于物理的渲染pbr) - 微表面理论与材质建模
3. [体积渲染与参与介质](#体积渲染与参与介质) - 云雾烟尘的渲染技术
4. [计算着色器与GPGPU](#计算着色器与gpgpu) - 并行计算在图形学中的应用

---

## 线性代数基础

## 1.1 向量的数学定义与几何意义

### 1.1.1 向量的基本概念

**数学定义**：向量是具有大小和方向的量，在n维欧几里得空间 $\mathbb{R}^n$ 中可以表示为：

$$\vec{v} = \begin{pmatrix} v_1 \\ v_2 \\ \vdots \\ v_n \end{pmatrix} \in \mathbb{R}^n$$

**向量的模长（欧几里得范数）**：
$$\|\vec{v}\| = \sqrt{v_1^2 + v_2^2 + \cdots + v_n^2} = \sqrt{\sum_{i=1}^{n} v_i^2}$$

**单位向量**：
$$\hat{v} = \frac{\vec{v}}{\|\vec{v}\|}, \quad \|\hat{v}\| = 1$$

**几何意义与性质**：

- **位置表示**：向量可以看作从原点指向某点的有向线段
- **方向性**：向量的方向由其各分量的比值决定，与起点无关
- **平移不变性**：向量表示的是相对位移，不依赖于坐标系原点
- **线性性**：向量空间满足加法和数乘的线性性质

**在计算机图形学中的核心应用**：

- **位置向量**：表示3D空间中顶点的坐标 $p = (x, y, z)^T$
- **方向向量**：表示光线方向、法向量、视线方向等
- **位移向量**：表示物体的平移变换
- **颜色向量**：RGB/RGBA颜色空间的表示
- **纹理坐标**：UV坐标的二维向量表示

### 1.1.2 向量运算的数学原理

#### 向量加法（Vector Addition）

**数学定义**：对于 n 维向量 $u$ 和 $v$，其和定义为：
$$u + v = \begin{pmatrix}{c} u_1 + v_1 \\ u_2 + v_2 \\ \vdots \\ u_n + v_n \end{pmatrix}$$

**几何解释**：

- **平行四边形法则**：$u + v$ 是以 $u$ 和 $v$ 为邻边的平行四边形的对角线
- **三角形法则**：将 $v$ 的起点放在 $u$ 的终点，连接 $u$ 的起点和 $v$ 的终点

**代数性质**：

- **交换律**：$u + v = v + u$
- **结合律**：$(u + v) + w = u + (v + w)$
- **零元素**：$u + 0 = u$
- **逆元素**：$u + (-u) = 0$

**GAMES101项目实现**：

```cpp
// Eigen库中的向量加法
Eigen::Vector3f u(1.0f, 2.0f, 3.0f);
Eigen::Vector3f v(4.0f, 5.0f, 6.0f);
Eigen::Vector3f result = u + v;  // (5, 7, 9)

// 在光栅化中的应用：顶点位置变换
Eigen::Vector3f vertex_position = base_position + displacement;
```

#### 向量数乘（Scalar Multiplication）

**数学定义**：对于标量 $k \in \mathbb{R}$ 和向量 $\vec{v} \in \mathbb{R}^n$：
$$k\vec{v} = \begin{pmatrix} kv_1 \\ kv_2 \\ \vdots \\ kv_n \end{pmatrix}$$

**几何效果分析**：

- $k > 1$：向量伸长 $k$ 倍，方向不变
- $0 < k < 1$：向量缩短为原长度的 $k$ 倍，方向不变
- $k = 0$：得到零向量
- $k < 0$：向量反向并缩放 $|k|$ 倍

**重要应用**：

- **单位向量计算**：$\hat{v} = \frac{1}{\|\vec{v}\|}\vec{v}$
- **缩放变换**：在几何变换中实现物体的放大缩小
- **插值计算**：线性插值 $\vec{p}(t) = (1-t)\vec{p_0} + t\vec{p_1}$

#### 点积（内积/数量积）

**数学定义**：对于向量 $\vec{u}, \vec{v} \in \mathbb{R}^n$，点积定义为：
$$\vec{u} \cdot \vec{v} = \sum_{i=1}^{n} u_i v_i = u_1v_1 + u_2v_2 + \cdots + u_nv_n$$

**几何形式**：
$$\vec{u} \cdot \vec{v} = \|\vec{u}\| \|\vec{v}\| \cos \theta$$
其中 $\theta$ 是两向量间的夹角 $(0 \leq \theta \leq \pi)$

**几何意义深度解析**：

- **投影解释**：$\vec{u} \cdot \vec{v} = \|\vec{u}\| \cdot \text{proj}_{\vec{v}}\vec{u}$
- **标量结果**：点积的结果是标量，不是向量
- **角度计算**：$\cos \theta = \frac{\vec{u} \cdot \vec{v}}{\|\vec{u}\| \|\vec{v}\|}$

**重要代数性质**：

- **交换律**：$\vec{u} \cdot \vec{v} = \vec{v} \cdot \vec{u}$
- **分配律**：$\vec{u} \cdot (\vec{v} + \vec{w}) = \vec{u} \cdot \vec{v} + \vec{u} \cdot \vec{w}$
- **结合律**：$(k\vec{u}) \cdot \vec{v} = k(\vec{u} \cdot \vec{v})$
- **正定性**：$\vec{u} \cdot \vec{u} = \|\vec{u}\|^2 \geq 0$，等号成立当且仅当 $\vec{u} = \vec{0}$

**几何判断准则**：

- $\vec{u} \cdot \vec{v} = 0 \iff \vec{u} \perp \vec{v}$（垂直判断）
- $\vec{u} \cdot \vec{v} > 0 \iff \theta < 90°$（锐角）
- $\vec{u} \cdot \vec{v} < 0 \iff \theta > 90°$（钝角）

**GAMES101项目中的关键应用**：

```cpp
// 1. 计算两向量夹角
float dot_product = u.dot(v);
float angle = std::acos(std::clamp(dot_product / (u.norm() * v.norm()), -1.0f, 1.0f));

// 2. 光照计算中的Lambert余弦定律
float cos_theta = std::max(0.0f, normal.dot(light_direction));
Vector3f diffuse_color = albedo * light_color * cos_theta;

// 3. 视锥体裁剪中的平面测试
float distance_to_plane = point.dot(plane_normal) + plane_d;
bool is_inside = distance_to_plane >= 0;

// 4. 背面剔除
Vector3f view_direction = camera_position - vertex_position;
bool is_front_facing = face_normal.dot(view_direction) > 0;
```

#### 叉积（外积/向量积）

**数学定义**：对于三维向量 $\vec{u}, \vec{v} \in \mathbb{R}^3$，叉积定义为：
$$\vec{u} \times \vec{v} = \begin{pmatrix} u_2v_3 - u_3v_2 \\ u_3v_1 - u_1v_3 \\ u_1v_2 - u_2v_1 \end{pmatrix}$$

**行列式表示**：

叉积可以表示为形式行列式：

- 第1行：$(\vec{i}, \vec{j}, \vec{k})$ - 单位向量
- 第2行：$(u_1, u_2, u_3)$ - 向量 $\vec{u}$ 的分量
- 第3行：$(v_1, v_2, v_3)$ - 向量 $\vec{v}$ 的分量

$$\vec{u} \times \vec{v} = \text{determinant expansion}$$

**几何意义深度解析**：

- **方向**：遵循右手定则，垂直于 $\vec{u}$ 和 $\vec{v}$ 构成的平面
- **大小**：$\|\vec{u} \times \vec{v}\| = \|\vec{u}\| \|\vec{v}\| \sin \theta$
- **面积解释**：$\|\vec{u} \times \vec{v}\|$ 等于以 $\vec{u}$ 和 $\vec{v}$ 为邻边的平行四边形面积

**重要代数性质**：

- **反交换律**：$\vec{u} \times \vec{v} = -\vec{v} \times \vec{u}$
- **分配律**：$\vec{u} \times (\vec{v} + \vec{w}) = \vec{u} \times \vec{v} + \vec{u} \times \vec{w}$
- **标量结合律**：$(k\vec{u}) \times \vec{v} = k(\vec{u} \times \vec{v}) = \vec{u} \times (k\vec{v})$
- **平行判断**：$\vec{u} \times \vec{v} = \vec{0} \iff \vec{u} \parallel \vec{v}$
- **垂直性**：$(\vec{u} \times \vec{v}) \cdot \vec{u} = 0$ 且 $(\vec{u} \times \vec{v}) \cdot \vec{v} = 0$

**标量三重积**：

标量三重积等于三个向量构成的行列式：

- 第1行：$(u_1, u_2, u_3)$ - 向量 $\vec{u}$ 的分量
- 第2行：$(v_1, v_2, v_3)$ - 向量 $\vec{v}$ 的分量
- 第3行：$(w_1, w_2, w_3)$ - 向量 $\vec{w}$ 的分量

$$\vec{u} \cdot (\vec{v} \times \vec{w}) = \text{scalar triple product}$$

表示以三个向量为邻边的平行六面体的有向体积。

**GAMES101项目中的核心应用**：

```cpp
// 1. 计算三角形法向量（Assignment 2/3中的关键操作）
Eigen::Vector3f edge1 = vertex2 - vertex1;
Eigen::Vector3f edge2 = vertex3 - vertex1;
Eigen::Vector3f normal = edge1.cross(edge2).normalized();

// 2. 判断点在三角形内部（重心坐标计算的基础）
Vector3f v0 = C - A, v1 = B - A, v2 = P - A;
Vector3f cross1 = v0.cross(v1);  // 三角形面积向量
Vector3f cross2 = v0.cross(v2);  // 子三角形面积向量
float area_ratio = cross2.dot(cross1) / cross1.squaredNorm();

// 3. 构建坐标系（相机变换中的应用）
Vector3f forward = (target - eye).normalized();
Vector3f right = forward.cross(up).normalized();
Vector3f camera_up = right.cross(forward);

// 4. 计算三角形面积
float triangle_area = 0.5f * edge1.cross(edge2).norm();
```

## 1.2 矩阵理论基础

### 1.2.1 矩阵的定义与基本运算

**矩阵定义**：$m \times n$ 矩阵是由 $m$ 行 $n$ 列实数排列成的矩形阵列:

$$A = (a_{ij})_{m \times n} \text{ where } a_{ij} \text{ is the element in row } i \text{ and column } j$$

**矩阵乘法的严格定义**：
对于矩阵 $A \in \mathbb{R}^{m \times p}$ 和 $B \in \mathbb{R}^{p \times n}$，乘积 $C = AB \in \mathbb{R}^{m \times n}$ 的元素为：
$$c_{ij} = \sum_{k=1}^{p} a_{ik} b_{kj}, \quad i = 1,2,\ldots,m; \quad j = 1,2,\ldots,n$$

**矩阵乘法的几何意义**：

- **线性变换复合**：$(AB)\vec{x} = A(B\vec{x})$ 表示先应用变换 $B$，再应用变换 $A$
- **基向量变换**：矩阵 $A$ 的第 $j$ 列是标准基向量 $\vec{e_j}$ 经过变换 $A$ 后的结果
- **坐标系变换**：从一个坐标系到另一个坐标系的映射

**矩阵乘法的重要性质**：

- **结合律**：$(AB)C = A(BC)$
- **分配律**：$A(B + C) = AB + AC$，$(A + B)C = AC + BC$
- **非交换性**：一般情况下 $AB \neq BA$
- **与标量乘法的关系**：$(kA)B = k(AB) = A(kB)$

### 1.2.2 特殊矩阵类型

#### 单位矩阵（Identity Matrix）

**定义**：$n \times n$ 单位矩阵 $I_n$ 定义为对角线元素为1，其他元素为0的矩阵：

$$(I_n)_{ij} = \delta_{ij}$$

其中 $\delta_{ij}$ 是Kronecker delta函数：

当 $i = j$ 时：$\delta_{ij} = 1$

当 $i \neq j$ 时：$\delta_{ij} = 0$

**基本性质**：

- **乘法单位元**：$AI = IA = A$（当维度匹配时）
- **几何意义**：恒等变换，不改变任何向量
- **特征值**：所有特征值都是1

#### 转置矩阵（Transpose Matrix）

**定义**：矩阵 $A$ 的转置 $A^T$ 定义为：
$$(A^T)_{ij} = A_{ji}$$

**重要性质**：

- **对合性**：$(A^T)^T = A$
- **乘积转置**：$(AB)^T = B^T A^T$
- **和的转置**：$(A + B)^T = A^T + B^T$
- **标量乘法**：$(kA)^T = kA^T$

**几何意义**：

- 对于旋转矩阵：$R^T = R^{-1}$（正交矩阵性质）
- 反映了线性变换的"逆向"操作

#### 逆矩阵（Inverse Matrix）

**定义**：对于方阵 $A \in \mathbb{R}^{n \times n}$，如果存在矩阵 $A^{-1}$ 使得：
$$AA^{-1} = A^{-1}A = I_n$$
则称 $A^{-1}$ 为 $A$ 的逆矩阵。

**存在性条件**：

- **行列式非零**：$\det(A) \neq 0$
- **满秩条件**：$\text{rank}(A) = n$
- **线性无关**：$A$ 的列向量线性无关

**计算方法**：

1. **伴随矩阵法**：$A^{-1} = \frac{1}{\det(A)} \text{adj}(A)$
2. **高斯-约旦消元法**：$[A|I] \to [I|A^{-1}]$
3. **LU分解法**：适用于大型矩阵

**重要性质**：

- $(A^{-1})^{-1} = A$
- $(AB)^{-1} = B^{-1}A^{-1}$
- $(A^T)^{-1} = (A^{-1})^T$
- $\det(A^{-1}) = \frac{1}{\det(A)}$

### 1.2.3 齐次坐标系统

#### 齐次坐标的数学基础

**引入动机**：

1. **统一变换表示**：将平移、旋转、缩放等变换统一为矩阵乘法
2. **透视投影简化**：用线性代数处理非线性的透视除法
3. **变换复合**：多个变换的复合简化为矩阵乘法
4. **无穷远点表示**：优雅地处理平行线相交于无穷远点

**齐次坐标的数学定义**：
对于 $n$ 维欧几里得空间中的点，其齐次坐标是 $(n+1)$ 维向量：

齐次坐标 $(x, y, z, w)$ 对应笛卡尔坐标 $(x/w, y/w, z/w)$，其中 $w \neq 0$

**齐次坐标的分类**：

- **点的表示**：$(x, y, z, 1)$ - 第四个分量为1
- **向量的表示**：$(x, y, z, 0)$ - 第四个分量为0
- **无穷远点**：$(x, y, z, 0)$ 且 $(x, y, z) \neq (0, 0, 0)$

**齐次坐标的等价性**：
所有非零标量倍数表示同一个点：

$$k(x, y, z, w) \sim (x, y, z, w) \quad (k \neq 0)$$

#### 齐次坐标的运算规则

**点与向量的区别**：

- **点 + 向量 = 点**：$(x_1, y_1, z_1, 1) + (x_2, y_2, z_2, 0) = (x_1+x_2, y_1+y_2, z_1+z_2, 1)$
- **点 - 点 = 向量**：$(x_1, y_1, z_1, 1) - (x_2, y_2, z_2, 1) = (x_1-x_2, y_1-y_2, z_1-z_2, 0)$
- **向量 + 向量 = 向量**：$(x_1, y_1, z_1, 0) + (x_2, y_2, z_2, 0) = (x_1+x_2, y_1+y_2, z_1+z_2, 0)$

**仿射组合**：
点的仿射组合（权重和为1）仍为点：

对于点 $P_i = (x_i, y_i, z_i, 1)$，其仿射组合为：
$$\sum_{i} \alpha_i P_i = \left(\sum_i \alpha_i x_i, \sum_i \alpha_i y_i, \sum_i \alpha_i z_i, \sum_i \alpha_i\right)$$

当 $\sum_i \alpha_i = 1$ 时，结果是有效的点。

#### GAMES101项目中的实际应用

**变换矩阵的统一表示**：

```cpp
// 不使用齐次坐标的变换（需要分别处理）
Vector3f transformed_point = rotation_matrix * point + translation_vector;
Vector3f transformed_vector = rotation_matrix * vector;  // 向量不受平移影响

// 使用齐次坐标的统一变换
Matrix4f transformation = translation * rotation * scaling;
Vector4f homogeneous_point(point.x, point.y, point.z, 1.0f);
Vector4f homogeneous_vector(vector.x, vector.y, vector.z, 0.0f);

Vector4f transformed_point = transformation * homogeneous_point;
Vector4f transformed_vector = transformation * homogeneous_vector;

// 转换回笛卡尔坐标
Vector3f result_point = transformed_point.head<3>() / transformed_point.w();
Vector3f result_vector = transformed_vector.head<3>();  // w分量为0，不需要除法
```

**MVP变换链的实现**：

```cpp
// Assignment 1中的核心变换
Matrix4f mvp = projection * view * model;
for (auto& vertex : vertices) {
    Vector4f clip_coord = mvp * Vector4f(vertex.x, vertex.y, vertex.z, 1.0f);

    // 透视除法（齐次坐标到NDC）
    Vector3f ndc_coord = clip_coord.head<3>() / clip_coord.w();

    // 视口变换
    Vector3f screen_coord = viewport_transform * ndc_coord;
}
```

## 1.3 基础光栅化算法

### 1.3.1 Bresenham直线算法

#### 算法背景与动机

**问题描述**：给定两个端点 $(x_0, y_0)$ 和 $(x_1, y_1)$，在离散的像素网格上绘制连接这两点的直线。

**核心挑战**：

- 像素网格是离散的，而数学直线是连续的
- 需要选择最接近理想直线的像素点
- 算法必须高效，避免浮点运算和除法

#### 数学原理推导

**直线方程**：
$$y = mx + b, \quad m = \frac{y_1 - y_0}{x_1 - x_0}$$

**决策变量的引入**：
对于当前像素 $(x_i, y_i)$，下一个像素可能是 $(x_i+1, y_i)$ 或 $(x_i+1, y_i+1)$。

定义决策变量：
$$d_i = 2(y_i - y_{ideal}) \cdot (x_1 - x_0)$$

其中 $y_{ideal} = y_0 + m(x_i + 1 - x_0)$ 是理想直线在 $x = x_i + 1$ 处的y值。

**决策规则**：

- 如果 $d_i < 0$，选择 $(x_i+1, y_i)$
- 如果 $d_i \geq 0$，选择 $(x_i+1, y_i+1)$

**递推关系**：

当 $d_i < 0$ 时：
$$d_{i+1} = d_i + 2(y_1 - y_0)$$

当 $d_i \geq 0$ 时：
$$d_{i+1} = d_i + 2(y_1 - y_0) - 2(x_1 - x_0)$$

**初始值**：
$$d_0 = 2(y_1 - y_0) - (x_1 - x_0)$$

#### GAMES101项目实现分析

```cpp
// Assignment 1中的Bresenham算法实现
void rst::rasterizer::draw_line(Eigen::Vector3f begin, Eigen::Vector3f end) {
    auto x1 = begin.x(), y1 = begin.y();
    auto x2 = end.x(), y2 = end.y();

    Eigen::Vector3f line_color = {255, 255, 255};

    int x, y, dx, dy, dx1, dy1, px, py, xe, ye, i;

    // 计算增量
    dx = x2 - x1;  // $\Delta x$
    dy = y2 - y1;  // $\Delta y$
    dx1 = fabs(dx);  // $|\Delta x|$
    dy1 = fabs(dy);  // $|\Delta y|$

    // 初始决策变量
    px = 2 * dy1 - dx1;  // 对应水平主导情况
    py = 2 * dx1 - dy1;  // 对应垂直主导情况

    // 根据斜率选择主导方向
    if (dy1 <= dx1) {  // |斜率| ≤ 1，水平主导
        // 确保从左到右绘制
        if (dx >= 0) { x = x1; y = y1; xe = x2; }
        else { x = x2; y = y2; xe = x1; }

        set_pixel(Eigen::Vector3f(x, y, 1.0f), line_color);

        for (i = 0; x < xe; i++) {
            x = x + 1;
            if (px < 0) {
                px = px + 2 * dy1;  // 选择水平像素
            } else {
                // 选择对角像素，y坐标需要根据方向调整
                if ((dx < 0 && dy < 0) || (dx > 0 && dy > 0)) {
                    y = y + 1;
                } else {
                    y = y - 1;
                }
                px = px + 2 * (dy1 - dx1);
            }
            set_pixel(Eigen::Vector3f(x, y, 1.0f), line_color);
        }
    } else {  // |斜率| > 1，垂直主导
        // 类似处理，但以y为主导方向
        // ... 垂直主导的实现
    }
}
```

#### 算法优化与变种

**整数优化**：

- 所有计算都使用整数运算
- 避免浮点数和除法运算
- 时间复杂度：$O(max(|x_1-x_0|, |y_1-y_0|))$

**对称性处理**：

- 通过交换坐标处理不同象限的直线
- 统一处理各种斜率情况

**抗锯齿扩展**：

- Wu's算法：考虑像素覆盖面积
- 超采样：提高采样率后下采样

---

## 几何变换数学原理

## 2.1 线性变换理论

### 2.1.1 线性变换的数学定义

**严格数学定义**：设 $V$ 和 $W$ 是向量空间，映射 $T: V \to W$ 称为线性变换，当且仅当对于任意 $\vec{u}, \vec{v} \in V$ 和标量 $k$，满足：

1. **加法保持性（可加性）**：$T(\vec{u} + \vec{v}) = T(\vec{u}) + T(\vec{v})$
2. **数乘保持性（齐次性）**：$T(k\vec{u}) = kT(\vec{u})$

**等价条件**：线性变换也可以用单一条件表示：
$$T(\alpha\vec{u} + \beta\vec{v}) = \alpha T(\vec{u}) + \beta T(\vec{v})$$

**矩阵表示定理**：
对于有限维向量空间，任何线性变换 $T: \mathbb{R}^n \to \mathbb{R}^m$ 都可以唯一地表示为矩阵乘法：
$$T(\vec{v}) = A\vec{v}$$
其中 $A \in \mathbb{R}^{m \times n}$ 是变换矩阵。

**变换矩阵的构造**：
变换矩阵 $A$ 的第 $j$ 列是标准基向量 $\vec{e_j}$ 的像：
$$A = [T(\vec{e_1}) \quad T(\vec{e_2}) \quad \cdots \quad T(\vec{e_n})]$$

**线性变换的重要性质**：

- **零向量保持**：$T(\vec{0}) = \vec{0}$
- **线性组合保持**：$T(\sum_i \alpha_i \vec{v_i}) = \sum_i \alpha_i T(\vec{v_i})$
- **子空间保持**：线性子空间的像仍是线性子空间
- **平行线保持**：平行线变换后仍平行（或重合）
- **原点固定**：线性变换总是将原点映射到原点

### 2.1.2 基本线性变换

#### 缩放变换（Scaling Transform）

**数学定义**：
缩放变换是一种线性变换，将向量的各个分量分别乘以对应的缩放因子：
$$S(s_x, s_y, s_z): \begin{pmatrix} x \\ y \\ z \end{pmatrix} \mapsto \begin{pmatrix} s_x \cdot x \\ s_y \cdot y \\ s_z \cdot z \end{pmatrix}$$

**齐次坐标矩阵表示**：

缩放变换矩阵 $S(s_x, s_y, s_z)$ 是一个 $4 \times 4$ 对角矩阵：

- 对角线元素：$(s_x, s_y, s_z, 1)$
- 其他元素均为0

$$S(s_x, s_y, s_z) = \text{diag}(s_x, s_y, s_z, 1)$$

**几何效果分析**：

- **均匀缩放**：$s_x = s_y = s_z = s$
  - $s > 1$：物体放大 $s$ 倍
  - $0 < s < 1$：物体缩小为原来的 $s$ 倍
  - $s = 1$：恒等变换
- **非均匀缩放**：$s_x, s_y, s_z$ 不全相等
  - 改变物体的长宽高比例
  - 可能导致圆变椭圆等形变
- **反射缩放**：某个 $s_i < 0$
  - $s_i = -1$：沿第 $i$ 轴反射
  - $s_i < -1$：反射并放大
  - $-1 < s_i < 0$：反射并缩小

**重要性质**：

- **可逆性**：当所有 $s_i \neq 0$ 时，$S^{-1}(s_x, s_y, s_z) = S(1/s_x, 1/s_y, 1/s_z)$
- **行列式**：$\det(S) = s_x \cdot s_y \cdot s_z$（体积缩放因子）
- **特征值**：对角元素 $s_x, s_y, s_z$ 就是特征值
- **交换性**：缩放矩阵之间满足交换律

**GAMES101项目实现**：

```cpp
Eigen::Matrix4f create_scaling_matrix(float sx, float sy, float sz) {
    Eigen::Matrix4f scaling = Eigen::Matrix4f::Identity();
    scaling(0, 0) = sx;
    scaling(1, 1) = sy;
    scaling(2, 2) = sz;
    return scaling;
}

// 应用示例：在Assignment 1中缩放三角形
Matrix4f model = create_scaling_matrix(1.5f, 1.5f, 1.5f);  // 放大1.5倍
for (auto& vertex : triangle_vertices) {
    Vector4f scaled_vertex = model * Vector4f(vertex.x, vertex.y, vertex.z, 1.0f);
    vertex = scaled_vertex.head<3>();
}
```

**特殊缩放变换**：

- **各向同性缩放**：$S(s, s, s)$ - 保持形状，只改变大小
- **沿轴缩放**：$S(s, 1, 1)$ - 只沿x轴缩放
- **镜像变换**：$S(-1, 1, 1)$ - 沿x轴镜像

#### 旋转变换（Rotation Transform）

### 绕坐标轴旋转的数学推导

**绕Z轴旋转的详细推导**：
设点 $P(x, y)$ 绕原点逆时针旋转角度 $\theta$ 到点 $P'(x', y')$。

**极坐标方法**：
将点 $P$ 表示为极坐标形式：

- $P: (r\cos\phi, r\sin\phi)$，其中 $r = \sqrt{x^2 + y^2}$，$\phi = \arctan(y/x)$
- $P': (r\cos(\phi + \theta), r\sin(\phi + \theta))$

利用三角恒等式：

对于 x 坐标：
$$x' = r\cos(\phi + \theta) = r(\cos\phi\cos\theta - \sin\phi\sin\theta) = x\cos\theta - y\sin\theta$$

对于 y 坐标：
$$y' = r\sin(\phi + \theta) = r(\sin\phi\cos\theta + \cos\phi\sin\theta) = x\sin\theta + y\cos\theta$$

**矩阵形式**：

绕 z 轴旋转矩阵 $R_z(\theta)$ 的结构：

- 左上角 $2 \times 2$ 子矩阵：标准2D旋转矩阵，元素为 $(\cos\theta, -\sin\theta; \sin\theta, \cos\theta)$
- z 坐标不变：第3行第3列为1
- 齐次坐标：第4行第4列为1
- 其他元素为0

$$R_z(\theta) = \text{rotation matrix around z-axis}$$

**其他坐标轴旋转**：

**绕 x 轴旋转** $R_x(\theta)$：

- x 坐标不变：第1行第1列为1
- yz 平面内旋转：第2,3行第2,3列为 $2 \times 2$ 旋转矩阵
- 齐次坐标：第4行第4列为1

**绕 y 轴旋转** $R_y(\theta)$：

- y 坐标不变：第2行第2列为1
- xz 平面内旋转：注意 $\sin\theta$ 的符号与其他轴相反
- 齐次坐标：第4行第4列为1

**旋转矩阵的重要性质**：

- **正交性**：$R^T R = I$，即 $R^{-1} = R^T$
- **行列式**：$\det(R) = 1$（保持定向）
- **长度保持**：$\|R\vec{v}\| = \|\vec{v}\|$
- **角度保持**：$\vec{u} \cdot \vec{v} = (R\vec{u}) \cdot (R\vec{v})$

**GAMES101 Assignment 1实现**：

```cpp
Eigen::Matrix4f get_model_matrix(float rotation_angle) {
    Eigen::Matrix4f model = Eigen::Matrix4f::Identity();

    // 角度转弧度
    float angle_rad = rotation_angle * MY_PI / 180.0f;
    float cos_a = std::cos(angle_rad);
    float sin_a = std::sin(angle_rad);

    // 绕Z轴旋转矩阵
    model(0, 0) = cos_a;   model(0, 1) = -sin_a;
    model(1, 0) = sin_a;   model(1, 1) = cos_a;

    return model;
}
```

### 任意轴旋转（Rodrigues旋转公式）

**问题描述**：给定单位向量 $\vec{n}$ 和角度 $\theta$，求绕轴 $\vec{n}$ 旋转 $\theta$ 角度的旋转矩阵。

**Rodrigues公式推导**：
对于任意向量 $\vec{v}$，绕单位轴 $\vec{n}$ 旋转 $\theta$ 角度后的结果为：
$$\vec{v}_{rot} = \vec{v}\cos\theta + (\vec{n} \times \vec{v})\sin\theta + \vec{n}(\vec{n} \cdot \vec{v})(1-\cos\theta)$$

**矩阵形式的Rodrigues公式**：
$$R(\vec{n}, \theta) = I\cos\theta + [\vec{n}]_{\times}\sin\theta + \vec{n}\vec{n}^T(1-\cos\theta)$$

其中 $[\vec{n}]_{\times}$ 是 $\vec{n} = (n_x, n_y, n_z)$ 的反对称矩阵（叉积矩阵）：

反对称矩阵的结构：

- 对角线元素全为0
- 第1行：$(0, -n_z, n_y)$
- 第2行：$(n_z, 0, -n_x)$
- 第3行：$(-n_y, n_x, 0)$

$$[\vec{n}]_{\times} = \text{skew-symmetric matrix of } \vec{n}$$

**公式的几何意义**：

- $\vec{n}\vec{n}^T(1-\cos\theta)$：向量在旋转轴上的投影分量（不变部分）
- $I\cos\theta$：垂直于旋转轴的分量的余弦部分
- $[\vec{n}]_{\times}\sin\theta$：垂直于旋转轴的分量的正弦部分

**推导过程**：

1. 将向量 $\vec{v}$ 分解为平行和垂直于 $\vec{n}$ 的分量：
   $$\vec{v} = \vec{v}_{\parallel} + \vec{v}_{\perp}$$
   其中 $\vec{v}_{\parallel} = (\vec{v} \cdot \vec{n})\vec{n}$，$\vec{v}_{\perp} = \vec{v} - \vec{v}_{\parallel}$

2. 平行分量不受旋转影响：$\vec{v}_{\parallel}' = \vec{v}_{\parallel}$

3. 垂直分量在垂直于 $\vec{n}$ 的平面内旋转：
   $$\vec{v}_{\perp}' = \vec{v}_{\perp}\cos\theta + (\vec{n} \times \vec{v}_{\perp})\sin\theta$$

**GAMES101项目实现**：

```cpp
Eigen::Matrix4f get_rotation(Vector3f axis, float angle) {
    // 确保轴向量为单位向量
    axis.normalize();
    float theta = angle * MY_PI / 180.0f;

    // 构建3x3旋转矩阵
    Eigen::Matrix3f I = Eigen::Matrix3f::Identity();

    // 反对称矩阵 [n]×
    Eigen::Matrix3f N;
    N << 0, -axis[2], axis[1],
         axis[2], 0, -axis[0],
         -axis[1], axis[0], 0;

    // 外积矩阵 nnᵀ
    Eigen::Matrix3f nnT = axis * axis.transpose();

    // Rodrigues公式
    Eigen::Matrix3f R = I * cos(theta) +
                        N * sin(theta) +
                        nnT * (1 - cos(theta));

    // 扩展为4x4齐次矩阵
    Eigen::Matrix4f rotation_matrix = Eigen::Matrix4f::Identity();
    rotation_matrix.block<3,3>(0,0) = R;

    return rotation_matrix;
}
```

**特殊情况验证**：

- 当 $\vec{n} = (0,0,1)$ 时，退化为绕Z轴旋转
- 当 $\theta = 0$ 时，$R = I$（恒等变换）
- 当 $\theta = \pi$ 时，$R = 2\vec{n}\vec{n}^T - I$（关于轴的180°旋转）

## 2.2 仿射变换理论

### 2.2.1 仿射变换的数学特性

#### 仿射变换的严格定义

**数学定义**：仿射变换是线性变换与平移的复合，对于向量空间 $\mathbb{R}^n$，仿射变换 $T: \mathbb{R}^n \to \mathbb{R}^n$ 定义为：
$$T(\vec{v}) = A\vec{v} + \vec{b}$$
其中 $A \in \mathbb{R}^{n \times n}$ 是线性变换矩阵，$\vec{b} \in \mathbb{R}^n$ 是平移向量。

**仿射空间的概念**：
仿射空间是没有固定原点的几何空间，仿射变换在仿射空间中具有特殊意义：

- **点的变换**：$P' = AP + \vec{b}$
- **向量的变换**：$\vec{v}' = A\vec{v}$（向量不受平移影响）

#### 仿射变换的几何性质

**保持性质（不变量）**：

1. **直线性保持**：直线 $L: \vec{p}(t) = \vec{p_0} + t\vec{d}$ 变换后仍为直线
   $$L': \vec{p}'(t) = A\vec{p_0} + \vec{b} + tA\vec{d}$$

2. **平行性保持**：平行直线变换后仍平行
   - 证明：平行线具有相同方向向量，$A\vec{d}$ 保持方向关系

3. **比例保持**：线段上的比例关系保持不变
   - 若 $\vec{p} = (1-t)\vec{p_1} + t\vec{p_2}$，则 $\vec{p}' = (1-t)\vec{p_1}' + t\vec{p_2}'$

4. **重心保持**：点集的重心变换后仍为变换后点集的重心

**不保持的性质**：

- **长度**：$\|\vec{v}'\| \neq \|\vec{v}\|$（除非 $A$ 是正交矩阵）
- **角度**：$\angle(\vec{u}, \vec{v}) \neq \angle(\vec{u}', \vec{v}')$（除非 $A$ 是相似变换）
- **面积/体积**：缩放因子为 $|\det(A)|$

#### 仿射变换的分类

**按几何效果分类**：

1. **刚体变换（Rigid Transform）**：$A$ 是正交矩阵，$\det(A) = 1$
   - 保持长度、角度、面积
   - 只包含旋转和平移

2. **相似变换（Similarity Transform）**：$A = sR$，$s > 0$，$R$ 是正交矩阵
   - 保持角度和形状
   - 包含均匀缩放、旋转、平移

3. **一般仿射变换**：任意可逆矩阵 $A$
   - 可能包含剪切、非均匀缩放等

**按变换分解分类**：
任何仿射变换都可以分解为基本变换的复合：
$$T = T_{trans} \circ T_{rot} \circ T_{scale} \circ T_{shear}$$

### 2.2.2 平移变换的深度分析

#### 平移变换的数学本质

**为什么平移不是线性变换**：
线性变换必须满足：

1. $T(\vec{0}) = \vec{0}$（零向量保持）
2. $T(\alpha\vec{u} + \beta\vec{v}) = \alpha T(\vec{u}) + \beta T(\vec{v})$（线性性）

但平移变换 $T(\vec{v}) = \vec{v} + \vec{t}$ 不满足第一个条件：
$$T(\vec{0}) = \vec{0} + \vec{t} = \vec{t} \neq \vec{0} \quad (\text{当} \vec{t} \neq \vec{0})$$

**仿射变换的引入**：
为了统一处理线性变换和平移，引入仿射变换：
$$T(\vec{v}) = A\vec{v} + \vec{t}$$

#### 齐次坐标中的平移表示

**齐次坐标矩阵**：

平移变换矩阵 $T(t_x, t_y, t_z)$ 的结构：

- 左上角 $3 \times 3$ 子矩阵为单位矩阵
- 第4列前三个元素为平移向量 $(t_x, t_y, t_z)$
- 第4行为 $(0, 0, 0, 1)$

$$T(t_x, t_y, t_z) = \text{translation matrix}$$

**变换过程的数学验证**：

对于点 $(x, y, z, 1)$，平移变换的结果为：
$$(x, y, z, 1) \xrightarrow{T(t_x, t_y, t_z)} (x + t_x, y + t_y, z + t_z, 1)$$

**向量与点的区别**：

- **点的平移**：$(x, y, z, 1) \to (x+t_x, y+t_y, z+t_z, 1)$
- **向量的平移**：$(x, y, z, 0) \to (x, y, z, 0)$（向量不受平移影响）

这正确反映了几何直觉：向量表示方向和大小，与位置无关。

#### 平移变换的性质

**群论性质**：
平移变换构成一个交换群 $(T, \circ)$：

1. **封闭性**：$T(\vec{a}) \circ T(\vec{b}) = T(\vec{a} + \vec{b})$
2. **结合律**：$(T(\vec{a}) \circ T(\vec{b})) \circ T(\vec{c}) = T(\vec{a}) \circ (T(\vec{b}) \circ T(\vec{c}))$
3. **单位元**：$T(\vec{0})$ 是恒等变换
4. **逆元**：$T(\vec{a})^{-1} = T(-\vec{a})$
5. **交换律**：$T(\vec{a}) \circ T(\vec{b}) = T(\vec{b}) \circ T(\vec{a})$

**矩阵表示的优势**：

```cpp
// 传统方法：需要特殊处理
Vector3f translate_point(const Vector3f& point, const Vector3f& translation) {
    return point + translation;
}

Vector3f translate_vector(const Vector3f& vector, const Vector3f& translation) {
    return vector;  // 向量不受平移影响
}

// 齐次坐标方法：统一处理
Matrix4f translation_matrix = create_translation_matrix(tx, ty, tz);
Vector4f result_point = translation_matrix * Vector4f(point.x, point.y, point.z, 1.0f);
Vector4f result_vector = translation_matrix * Vector4f(vector.x, vector.y, vector.z, 0.0f);
```

#### GAMES101项目中的应用

**创建平移矩阵**：

```cpp
Eigen::Matrix4f create_translation_matrix(float tx, float ty, float tz) {
    Eigen::Matrix4f translation = Eigen::Matrix4f::Identity();
    translation(0, 3) = tx;
    translation(1, 3) = ty;
    translation(2, 3) = tz;
    return translation;
}

// Assignment 1中的视图变换
Eigen::Matrix4f get_view_matrix(Eigen::Vector3f eye_pos) {
    Eigen::Matrix4f view = Eigen::Matrix4f::Identity();

    // 平移到原点（相机位置的逆变换）
    Eigen::Matrix4f translate = create_translation_matrix(-eye_pos[0], -eye_pos[1], -eye_pos[2]);

    view = translate * view;
    return view;
}
```

### 2.2.3 变换复合的数学理论

#### 变换复合的基本原理

**函数复合的定义**：
对于变换 $T_1, T_2, T_3$，复合变换定义为：
$$(T_3 \circ T_2 \circ T_1)(\vec{v}) = T_3(T_2(T_1(\vec{v})))$$

**矩阵乘法对应关系**：
在齐次坐标系统中，变换复合对应矩阵乘法：
$$T_3 \circ T_2 \circ T_1 \longleftrightarrow M_3 M_2 M_1$$

**重要注意**：矩阵乘法的顺序与变换应用顺序相反！

- 变换应用顺序：$T_1 \to T_2 \to T_3$
- 矩阵乘法顺序：$M_3 M_2 M_1$

#### 变换顺序的重要性

**非交换性证明**：
考虑平移 $T(1,0,0)$ 和绕Z轴旋转90°的复合：

**顺序1**：先平移后旋转
$$R_{90°} \circ T(1,0,0): (0,0,0) \to (1,0,0) \to (0,1,0)$$

**顺序2**：先旋转后平移
$$T(1,0,0) \circ R_{90°}: (0,0,0) \to (0,0,0) \to (1,0,0)$$

结果不同，说明变换顺序至关重要！

#### 标准变换序列（SRT分解）

**Scale-Rotate-Translate顺序**：
$$M_{total} = T \cdot R \cdot S$$

**为什么采用SRT顺序**：

1. **缩放（Scale）**：在局部坐标系中进行，不影响物体的朝向
2. **旋转（Rotate）**：在缩放后的坐标系中进行，保持物体形状
3. **平移（Translate）**：最后移动到世界坐标系中的目标位置

**数学验证**：

```cpp
// 错误顺序：RST（旋转-缩放-平移）
Matrix4f wrong_order = T * S * R;
// 问题：缩放会影响已经旋转的物体，可能导致非均匀拉伸

// 正确顺序：SRT（缩放-旋转-平移）
Matrix4f correct_order = T * R * S;
// 优势：每个变换都在合适的坐标系中进行
```

#### 图形学中的变换链

**完整的MVP变换链**：
$$\text{屏幕坐标} = M_{viewport} \cdot M_{projection} \cdot M_{view} \cdot M_{model} \cdot \text{局部坐标}$$

**各阶段的作用**：

1. **模型变换（Model）**：局部坐标 → 世界坐标
2. **视图变换（View）**：世界坐标 → 观察坐标
3. **投影变换（Projection）**：观察坐标 → 裁剪坐标
4. **视口变换（Viewport）**：NDC → 屏幕坐标

#### GAMES101项目实现

**Assignment 1中的变换链**：

```cpp
// 构建完整的MVP矩阵
Eigen::Matrix4f get_model_matrix(float rotation_angle) {
    // 模型变换：只包含旋转
    Eigen::Matrix4f model = Eigen::Matrix4f::Identity();
    float angle_rad = rotation_angle * MY_PI / 180.0f;

    model(0, 0) = cos(angle_rad);   model(0, 1) = -sin(angle_rad);
    model(1, 0) = sin(angle_rad);   model(1, 1) = cos(angle_rad);

    return model;
}

Eigen::Matrix4f get_view_matrix(Eigen::Vector3f eye_pos) {
    // 视图变换：相机移动到原点
    Eigen::Matrix4f view = Eigen::Matrix4f::Identity();
    Eigen::Matrix4f translate;
    translate << 1, 0, 0, -eye_pos[0],
                 0, 1, 0, -eye_pos[1],
                 0, 0, 1, -eye_pos[2],
                 0, 0, 0, 1;
    view = translate * view;
    return view;
}

// 在渲染循环中应用变换
Matrix4f mvp = projection * view * model;
for (auto& vertex : vertices) {
    Vector4f clip_coord = mvp * Vector4f(vertex.x, vertex.y, vertex.z, 1.0f);
    // 透视除法和视口变换...
}
```

**变换分解的实际应用**：

```cpp
// 复杂物体的变换分解
Matrix4f create_complex_transform(Vector3f scale, Vector3f rotation_angles, Vector3f translation) {
    // 1. 创建基本变换矩阵
    Matrix4f S = create_scaling_matrix(scale.x, scale.y, scale.z);
    Matrix4f Rx = create_rotation_x(rotation_angles.x);
    Matrix4f Ry = create_rotation_y(rotation_angles.y);
    Matrix4f Rz = create_rotation_z(rotation_angles.z);
    Matrix4f T = create_translation_matrix(translation.x, translation.y, translation.z);

    // 2. 按SRT顺序复合（注意矩阵乘法顺序）
    Matrix4f R = Rz * Ry * Rx;  // 旋转顺序：X→Y→Z
    Matrix4f transform = T * R * S;

    return transform;
}
```

---

## 投影几何学

## 3.1 投影变换的数学基础

### 3.1.1 投影的几何原理

**投影定义**：将高维空间的点映射到低维空间的过程

**投影类型**：

1. **平行投影**：投影线平行
   - 正交投影：投影线垂直于投影平面
   - 斜投影：投影线不垂直于投影平面

2. **透视投影**：投影线汇聚于一点（视点）

### 3.1.2 透视投影的完整数学推导

#### 透视投影的几何基础

**问题设定**：
给定观察点（视点）$E$ 和投影平面 $\Pi$，将3D空间中的点投影到2D平面上。

**标准设置**：

- 视点位于坐标原点：$E = (0, 0, 0)$
- 投影平面垂直于Z轴：$\Pi: z = -d$（$d > 0$）
- 观察方向沿负Z轴方向

#### 相似三角形推导

**几何分析**：
对于空间中的点 $P(x, y, z)$（其中 $z < 0$），从视点 $E$ 向点 $P$ 发出的射线与投影平面 $\Pi$ 的交点为 $P'(x', y', -d)$。

**X坐标推导**：
在XZ平面内，考虑三角形：

- 大三角形：顶点为 $(0,0)$、$(x, z)$、$(x, 0)$
- 小三角形：顶点为 $(0,0)$、$(x', -d)$、$(x', 0)$

由相似三角形性质：
$$\frac{x'}{x} = \frac{d}{-z} \implies x' = -\frac{dx}{z}$$

**Y坐标推导**：
类似地，在YZ平面内：
$$\frac{y'}{y} = \frac{d}{-z} \implies y' = -\frac{dy}{z}$$

**透视除法的本质**：
透视投影的核心是除法运算：$(x, y, z) \to (-dx/z, -dy/z, -d)$

#### 齐次坐标中的透视投影

**问题**：如何用矩阵表示包含除法的透视投影？

**解决方案**：利用齐次坐标的性质
齐次坐标 $(x, y, z, w)$ 对应笛卡尔坐标 $(x/w, y/w, z/w)$

**透视投影矩阵构造**：
我们希望找到矩阵 $P$，使得：

对输入点 $(x, y, z, 1)$，输出齐次坐标 $(x', y', z', w')$

其中透视除法后得到：$(-dx/z, -dy/z, -d)$

**矩阵推导**：
设 $w' = -z/d$，则：

- $x'/w' = -dx/z \implies x' = -dx/z \cdot (-z/d) = x$
- $y'/w' = -dy/z \implies y' = -dy/z \cdot (-z/d) = y$
- $z'/w' = -d \implies z' = -d \cdot (-z/d) = z$

因此透视投影矩阵为：

简单透视投影矩阵 $P_{simple}$ 的结构：

- 前三行为单位矩阵的前三行
- 第4行为 $(0, 0, -1/d, 0)$
- 其他元素为0

$$P_{simple} = \text{simple perspective projection matrix}$$

**验证**：
对输入向量 $(x, y, z, 1)$，变换结果为 $(x, y, z, -z/d)$

透视除法后：$(x/(-z/d), y/(-z/d), z/(-z/d)) = (-dx/z, -dy/z, -d)$ ✓

#### 透视投影的深度问题

**深度信息的保持**：
简单透视投影会丢失深度信息，因为所有点都被投影到 $z = -d$ 平面。

**解决方案**：
修改Z分量的计算，使其保持深度顺序：
$$z' = \alpha z + \beta$$

其中 $\alpha, \beta$ 是待定常数，需要满足：

1. 近平面 $z = -n$ 映射到 $z' = -1$
2. 远平面 $z = -f$ 映射到 $z' = 1$

**求解过程**：

建立线性方程组：

当 $z = -n$ 时：$\alpha(-n) + \beta = -1$

当 $z = -f$ 时：$\alpha(-f) + \beta = 1$

解得：
$$\alpha = -\frac{2}{f-n}, \quad \beta = -\frac{f+n}{f-n}$$

因此：
$$z' = -\frac{2z}{f-n} - \frac{f+n}{f-n} = -\frac{2z + f + n}{f-n}$$

但在齐次坐标中，我们需要：
$$\frac{z'}{w'} = -\frac{2z + f + n}{f-n} \cdot \frac{d}{-z} = \frac{d(2z + f + n)}{z(f-n)}$$

这导致了标准透视投影矩阵中Z行的复杂形式。

### 3.1.3 标准透视投影矩阵的完整推导

#### 视锥体（View Frustum）的定义

**视锥体参数**：

- $\text{fov}$：垂直视场角（Field of View），单位为度
- $\text{aspect}$：宽高比 $= \frac{\text{width}}{\text{height}}$
- $n$：近裁剪面距离（near plane）
- $f$：远裁剪面距离（far plane）

**视锥体的几何形状**：
视锥体是一个截头锥体（frustum），由6个平面围成：

- 近平面：$z = -n$
- 远平面：$z = -f$
- 左平面、右平面、上平面、下平面

#### 投影平面尺寸的计算

**近平面尺寸推导**：
在近平面 $z = -n$ 处，视锥体的尺寸为：

$$\text{top} = n \cdot \tan\left(\frac{\text{fov}}{2}\right)$$
$$\text{bottom} = -\text{top}$$
$$\text{right} = \text{top} \cdot \text{aspect}$$
$$\text{left} = -\text{right}$$

**几何解释**：

- $\tan(\text{fov}/2) = \text{top}/n$，因此 $\text{top} = n \cdot \tan(\text{fov}/2)$
- 对称视锥体：$\text{left} = -\text{right}$，$\text{bottom} = -\text{top}$

#### 一般透视投影矩阵推导

**目标**：将视锥体内的点 $(x, y, z)$ 映射到标准立方体 $[-1,1]^3$

**X坐标变换**：
近平面上的点 $x \in [\text{left}, \text{right}]$ 应映射到 $[-1, 1]$：
$$x_{ndc} = \frac{2x - (\text{right} + \text{left})}{\text{right} - \text{left}}$$

但透视投影中，$x$ 坐标会被 $z$ 缩放，因此：
$$x_{ndc} = \frac{2x/(-z) - (\text{right} + \text{left})/(-z)}{(\text{right} - \text{left})/(-z)}$$

整理得：
$$x_{ndc} = \frac{2x + z(\text{right} + \text{left})/n}{z(\text{right} - \text{left})/n}$$

**Y坐标变换**：
类似地：
$$y_{ndc} = \frac{2y + z(\text{top} + \text{bottom})/n}{z(\text{top} - \text{bottom})/n}$$

**Z坐标变换**：
Z坐标的变换需要保持深度顺序：
$$z_{ndc} = \frac{\alpha z + \beta}{z}$$

边界条件：

- $z = -n \implies z_{ndc} = -1$
- $z = -f \implies z_{ndc} = 1$

解得：$\alpha = -(f+n)$，$\beta = -2fn$

#### 齐次坐标矩阵形式

**一般透视投影矩阵**：

透视投影矩阵 $P$ 的结构：

- 第1行：$(\frac{2n}{r-l}, 0, \frac{r+l}{r-l}, 0)$
- 第2行：$(0, \frac{2n}{t-b}, \frac{t+b}{t-b}, 0)$
- 第3行：$(0, 0, -\frac{f+n}{f-n}, -\frac{2fn}{f-n})$
- 第4行：$(0, 0, -1, 0)$

$$P = \text{general perspective projection matrix}$$

其中：$n=\text{near}$, $f=\text{far}$, $l=\text{left}$, $r=\text{right}$, $t=\text{top}$, $b=\text{bottom}$

#### 对称视锥体的简化

**对称条件**：$l = -r$, $b = -t$

此时：$r + l = 0$, $t + b = 0$，矩阵简化为：

对称透视投影矩阵 $P_{symmetric}$ 的结构：

- 第1行：$(\frac{1}{\text{aspect} \cdot \tan(\text{fov}/2)}, 0, 0, 0)$
- 第2行：$(0, \frac{1}{\tan(\text{fov}/2)}, 0, 0)$
- 第3行：$(0, 0, -\frac{f+n}{f-n}, -\frac{2fn}{f-n})$
- 第4行：$(0, 0, -1, 0)$

$$P_{symmetric} = \text{symmetric perspective projection matrix}$$

**推导验证**：

- $\frac{2n}{r-l} = \frac{2n}{2r} = \frac{n}{r} = \frac{n}{n \cdot \tan(\text{fov}/2) \cdot \text{aspect}} = \frac{1}{\text{aspect} \cdot \tan(\text{fov}/2)}$
- $\frac{2n}{t-b} = \frac{2n}{2t} = \frac{n}{t} = \frac{n}{n \cdot \tan(\text{fov}/2)} = \frac{1}{\tan(\text{fov}/2)}$

#### GAMES101 Assignment 1项目实现

**完整的透视投影矩阵实现**：

```cpp
Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio,
                                      float zNear, float zFar) {
    // 创建单位矩阵作为基础
    Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();

    // 将视场角从度转换为弧度
    float eye_fov_rad = eye_fov * MY_PI / 180.0f;

    // 计算 tan(fov/2)，这是推导中的关键量
    float t = std::tan(eye_fov_rad / 2.0f);

    // 根据对称视锥体的简化公式填充矩阵元素
    projection(0, 0) = 1.0f / (aspect_ratio * t);  // X缩放因子
    projection(1, 1) = 1.0f / t;                   // Y缩放因子
    projection(2, 2) = -(zFar + zNear) / (zFar - zNear);     // Z变换系数A
    projection(2, 3) = -2.0f * zFar * zNear / (zFar - zNear); // Z变换系数B
    projection(3, 2) = -1.0f;                      // 透视除法触发器
    projection(3, 3) = 0.0f;                       // 清除原有的1

    return projection;
}
```

**矩阵元素的几何意义**：

1. `projection(0,0) = 1/(aspect*tan(fov/2))`：X方向的缩放，将视锥体宽度映射到[-1,1]
2. `projection(1,1) = 1/tan(fov/2)`：Y方向的缩放，将视锥体高度映射到[-1,1]
3. `projection(2,2) = -(f+n)/(f-n)`：Z坐标的线性部分
4. `projection(2,3) = -2fn/(f-n)`：Z坐标的常数部分
5. `projection(3,2) = -1`：使得w' = -z，实现透视除法

**变换过程验证**：

```cpp
// 测试近平面上的点
Vector4f near_point(0, 0, -zNear, 1);
Vector4f projected = projection * near_point;
// projected = (0, 0, zNear, zNear)
// 透视除法后: (0, 0, 1) - 正确映射到近平面

// 测试远平面上的点
Vector4f far_point(0, 0, -zFar, 1);
Vector4f projected_far = projection * far_point;
// 透视除法后的z坐标应该接近-1
```

**在渲染管线中的应用**：

```cpp
// Assignment 1中的完整变换链
void rasterizer::draw(pos_buf_id pos_buffer, ind_buf_id ind_buffer, Primitive type) {
    auto& buf = pos_buf[pos_buffer.pos_id];
    auto& ind = ind_buf[ind_buffer.ind_id];

    // 构建MVP矩阵
    Eigen::Matrix4f mvp = projection * view * model;

    for (auto& i : ind) {
        Triangle t;

        // 应用MVP变换到三角形的三个顶点
        Eigen::Vector4f v[] = {
            mvp * to_vec4(buf[i[0]], 1.0f),  // 齐次坐标变换
            mvp * to_vec4(buf[i[1]], 1.0f),
            mvp * to_vec4(buf[i[2]], 1.0f)
        };

        // 透视除法：从齐次坐标转换到NDC
        for (auto& vec : v) {
            vec /= vec.w();  // 关键的透视除法步骤
        }

        // 视口变换：从NDC转换到屏幕坐标
        for (auto& vert : v) {
            vert.x() = 0.5f * width * (vert.x() + 1.0f);   // [-1,1] -> [0,width]
            vert.y() = 0.5f * height * (vert.y() + 1.0f);  // [-1,1] -> [0,height]
            vert.z() = vert.z() * f1 + f2;  // 深度缓冲区映射
        }

        // 设置三角形顶点并进行光栅化
        for (int i = 0; i < 3; ++i) {
            t.setVertex(i, v[i].head<3>());
        }

        rasterize_wireframe(t);
    }
}
```

### 3.1.4 深度值的非线性分布

**问题**：透视投影后的深度值分布不均匀

**数学分析**：
投影后的z坐标为：
$$z' = -\frac{f+n}{f-n} + \frac{-2fn}{z(f-n)}$$

**深度精度分析**：

- 近处物体：深度精度高
- 远处物体：深度精度低
- 大部分精度集中在近裁剪面附近

**解决方案**：

1. 合理设置near/far比值
2. 使用反向Z缓冲
3. 对数深度缓冲

## 3.2 视图变换

### 3.2.1 摄像机模型

**摄像机参数**：

- eye：摄像机位置
- target：观察目标点
- up：上方向向量

**局部坐标系构建**：

```cpp
Vector3f forward = (target - eye).normalized();  // 前方向（-z轴）
Vector3f right = forward.cross(up).normalized(); // 右方向（x轴）
Vector3f camera_up = right.cross(forward);       // 上方向（y轴）
```

### 3.2.2 视图矩阵推导

**目标**：将世界坐标系变换到摄像机坐标系

**两步变换**：

1. 平移：将摄像机移动到原点
2. 旋转：将摄像机坐标轴与世界坐标轴对齐

**平移矩阵**：

视图变换平移矩阵 $\mathbf{T}$ 的结构：

- 左上角 $3 \times 3$ 子矩阵为单位矩阵
- 第4列前三个元素为 $(-eye_x, -eye_y, -eye_z)$
- 第4行为 $(0, 0, 0, 1)$

$$\mathbf{T} = \text{view translation matrix}$$

**旋转矩阵**：

视图变换旋转矩阵 $\mathbf{R}$ 的结构：

- 第1行：$(right_x, right_y, right_z, 0)$ - 右向量
- 第2行：$(up_x, up_y, up_z, 0)$ - 上向量
- 第3行：$(-forward_x, -forward_y, -forward_z, 0)$ - 负前向量
- 第4行：$(0, 0, 0, 1)$ - 齐次坐标

$$\mathbf{R} = \text{view rotation matrix}$$

**完整视图矩阵**：
$$\mathbf{V} = \mathbf{R} \times \mathbf{T}$$

**项目简化实现**：

```cpp
Eigen::Matrix4f get_view_matrix(Eigen::Vector3f eye_pos) {
    Eigen::Matrix4f view = Eigen::Matrix4f::Identity();

    Eigen::Matrix4f translate;
    translate << 1, 0, 0, -eye_pos[0],
                 0, 1, 0, -eye_pos[1],
                 0, 0, 1, -eye_pos[2],
                 0, 0, 0, 1;

    view = translate * view;
    return view;
}
```

### 3.1.4 深度缓冲区与Z-Fighting问题

#### 深度值的非线性分布

**问题分析**：
透视投影后的深度值在 $[0, 1]$ 范围内呈非线性分布，这会导致深度精度问题。

**深度变换函数**：
经过透视投影和透视除法后，原始深度 $z$ 变换为：
$$z_{buffer} = \frac{1}{2}\left(\frac{-(f+n)z - 2fn}{-z(f-n)} + 1\right)$$

简化为：
$$z_{buffer} = \frac{1}{2}\left(\frac{f+n}{f-n} + \frac{2fn}{z(f-n)}\right)$$

**非线性特性分析**：

- 当 $z \to -n$（近平面）时，$z_{buffer} \to 0$
- 当 $z \to -f$（远平面）时，$z_{buffer} \to 1$
- 深度精度在近平面附近最高，在远平面附近最低

**精度分布计算**：
深度精度定义为 $\frac{dz_{buffer}}{dz}$：
$$\frac{dz_{buffer}}{dz} = \frac{fn}{z^2(f-n)}$$

这表明深度精度与 $z^2$ 成反比，距离越远精度越低。

#### Z-Fighting现象

**定义**：当两个表面非常接近时，由于深度缓冲区精度限制，会出现闪烁现象。

**产生原因**：

1. **有限精度**：深度缓冲区通常使用24位或32位浮点数
2. **非线性分布**：远处物体的深度精度极低
3. **数值误差**：浮点运算的舍入误差

**数学分析**：
设两个表面的深度分别为 $z_1$ 和 $z_2$，且 $|z_1 - z_2| < \epsilon$，其中 $\epsilon$ 是深度缓冲区的精度。

当 $\frac{fn}{z^2(f-n)} \cdot |z_1 - z_2| < \frac{1}{2^{24}}$ 时，两个表面在深度缓冲区中无法区分。

#### 解决Z-Fighting的方法

**1. 优化近远平面比值**：
$$\text{精度} \propto \frac{n}{f-n}$$

减小 $f/n$ 比值可以提高整体精度：

```cpp
// 不好的设置
float near = 0.1f, far = 10000.0f;  // 比值 = 100000

// 更好的设置
float near = 1.0f, far = 1000.0f;   // 比值 = 1000
```

**2. 多边形偏移（Polygon Offset）**：

```cpp
// OpenGL中的多边形偏移
glEnable(GL_POLYGON_OFFSET_FILL);
glPolygonOffset(factor, units);
// 修改深度值：z' = z + factor * dz/dx + units * r
```

**3. 对数深度缓冲区**：
使用对数分布改善深度精度：
$$z_{log} = \frac{\log(z/n)}{\log(f/n)}$$

**4. 反向Z缓冲区**：
将远平面映射到0，近平面映射到1，利用浮点数在0附近精度更高的特性。

#### GAMES101项目中的深度处理

```cpp
// Assignment 2中的深度测试实现
void rst::rasterizer::rasterize_triangle(const Triangle& t) {
    // 获取三角形的屏幕空间包围盒
    auto v = t.toVector4();

    // 遍历包围盒内的每个像素
    for (int x = bbox_min_x; x <= bbox_max_x; x++) {
        for (int y = bbox_min_y; y <= bbox_max_y; y++) {
            // 计算重心坐标
            auto [alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);

            // 检查点是否在三角形内
            if (alpha >= 0 && beta >= 0 && gamma >= 0) {
                // 插值计算深度值
                float z_interpolated = alpha * v[0].z() + beta * v[1].z() + gamma * v[2].z();

                // 深度测试
                if (z_interpolated < depth_buf[get_index(x, y)]) {
                    // 更新深度缓冲区
                    depth_buf[get_index(x, y)] = z_interpolated;

                    // 设置像素颜色
                    set_pixel(Vector3f(x, y, 1.0f), t.getColor());
                }
            }
        }
    }
}
```

**深度精度优化建议**：

1. **合理设置近远平面**：避免过大的 $f/n$ 比值
2. **使用32位深度缓冲区**：相比24位有更高精度
3. **分层渲染**：将场景分为多个深度层分别渲染
4. **避免共面几何体**：设计时避免两个表面完全重合

---

## 微积分在图形学中的应用

## 4.1 参数曲线的微分几何理论

### 4.1.1 参数曲线的数学表示

#### 参数曲线的基本定义

**参数方程的一般形式**：
三维空间中的参数曲线可以表示为：
$$\vec{r}(t) = \begin{pmatrix} x(t) \\ y(t) \\ z(t) \end{pmatrix}, \quad t \in [a, b]$$

其中 $x(t)$、$y(t)$、$z(t)$ 是关于参数 $t$ 的连续可微函数。

**参数化的优势**：

- **统一表示**：直线、圆、椭圆等都可用参数方程统一描述
- **方向性**：参数增加方向给出曲线的自然定向
- **计算便利**：微分、积分运算转化为对参数的运算

#### 切向量与速度向量

**一阶导数（切向量）**：
$$\vec{r}'(t) = \frac{d\vec{r}}{dt} = \begin{pmatrix} x'(t) \\ y'(t) \\ z'(t) \end{pmatrix}$$

**几何与物理意义**：

- **几何意义**：$\vec{r}'(t)$ 是曲线在点 $\vec{r}(t)$ 处的切向量
- **物理意义**：若 $t$ 表示时间，则 $\vec{r}'(t)$ 是质点的瞬时速度向量
- **方向**：指向参数增加的方向

**单位切向量**：
$$\vec{T}(t) = \frac{\vec{r}'(t)}{\|\vec{r}'(t)\|}$$

当 $\|\vec{r}'(t)\| \neq 0$ 时，$\vec{T}(t)$ 是单位长度的切向量。

### 4.1.2 曲率理论与计算

#### 曲率的数学定义

**曲率的几何定义**：
曲率 $\kappa(t)$ 描述曲线在某点处偏离直线的程度，定义为单位切向量的变化率：
$$\kappa(t) = \left\|\frac{d\vec{T}}{dt}\right\| = \left\|\frac{d}{dt}\left(\frac{\vec{r}'(t)}{\|\vec{r}'(t)\|}\right)\right\|$$

**计算公式推导**：
利用向量微分的商法则：
$$\frac{d\vec{T}}{dt} = \frac{d}{dt}\left(\frac{\vec{r}'}{\|\vec{r}'\|}\right) = \frac{\vec{r}'' \|\vec{r}'\| - \vec{r}'(\vec{r}' \cdot \vec{r}'') / \|\vec{r}'\|}{\|\vec{r}'\|^2}$$

经过化简得到：
$$\kappa(t) = \frac{\|\vec{r}'(t) \times \vec{r}''(t)\|}{\|\vec{r}'(t)\|^3}$$

**二维情况的特殊形式**：
对于平面曲线 $y = f(x)$：
$$\kappa = \frac{|f''(x)|}{(1 + (f'(x))^2)^{3/2}}$$

#### 曲率的几何意义与应用

**几何解释**：

- $\kappa = 0$：曲线为直线
- $\kappa > 0$：曲线弯曲，数值越大弯曲程度越大
- $\kappa = 1/R$：$R$ 为曲率半径，即密切圆的半径

**在计算机图形学中的应用**：

1. **自适应曲线细分**：

```cpp
float compute_curvature(const Vector3f& p0, const Vector3f& p1, const Vector3f& p2) {
    Vector3f v1 = p1 - p0;
    Vector3f v2 = p2 - p1;
    Vector3f cross_product = v1.cross(v2);

    float numerator = cross_product.norm();
    float denominator = std::pow(v1.norm(), 3);

    return (denominator > 1e-6) ? numerator / denominator : 0.0f;
}

void adaptive_subdivision(const BezierCurve& curve, float tolerance) {
    for (float t = 0; t < 1.0; ) {
        float curvature = compute_curvature_at(curve, t);
        float step = std::min(tolerance / std::max(curvature, 1e-3), 0.1f);

        // 在高曲率处使用更小的步长
        render_curve_segment(curve, t, t + step);
        t += step;
    }
}
```

2. **动画路径平滑**：
通过控制曲率连续性确保动画的平滑过渡。

## 4.2 积分理论在渲染中的应用

### 4.2.1 渲染方程的数学基础

#### 渲染方程的物理推导

**能量守恒原理**：
在稳态条件下，表面某点的出射辐射度等于自发光加上所有入射光线经反射后的贡献。

**渲染方程的完整形式**：
$$L_o(\mathbf{p}, \omega_o) = L_e(\mathbf{p}, \omega_o) + \int_{\Omega} f_r(\mathbf{p}, \omega_i, \omega_o) L_i(\mathbf{p}, \omega_i) \cos\theta_i \, d\omega_i$$

**符号说明**：

- $L_o(\mathbf{p}, \omega_o)$：点 $\mathbf{p}$ 沿方向 $\omega_o$ 的出射辐射度
- $L_e(\mathbf{p}, \omega_o)$：点 $\mathbf{p}$ 的自发光辐射度
- $f_r(\mathbf{p}, \omega_i, \omega_o)$：双向反射分布函数（BRDF）
- $L_i(\mathbf{p}, \omega_i)$：沿方向 $\omega_i$ 的入射辐射度
- $\Omega$：以点 $\mathbf{p}$ 为中心的上半球立体角
- $\theta_i$：入射方向与表面法向量的夹角

#### BRDF的数学性质

**BRDF的定义**：
$$f_r(\mathbf{p}, \omega_i, \omega_o) = \frac{dL_o(\mathbf{p}, \omega_o)}{dE_i(\mathbf{p}, \omega_i)}$$

其中 $dE_i$ 是微分辐照度。

**重要性质**：

1. **非负性**：$f_r(\mathbf{p}, \omega_i, \omega_o) \geq 0$
2. **互易性**：$f_r(\mathbf{p}, \omega_i, \omega_o) = f_r(\mathbf{p}, \omega_o, \omega_i)$
3. **能量守恒**：$\int_{\Omega} f_r(\mathbf{p}, \omega_i, \omega_o) \cos\theta_o \, d\omega_o \leq 1$

### 4.2.2 蒙特卡洛积分理论

#### 蒙特卡洛方法的数学基础

**基本原理**：
对于积分 $I = \int_D f(\mathbf{x}) d\mathbf{x}$，蒙特卡洛估计为：
$$\hat{I} = \frac{1}{N} \sum_{i=1}^N \frac{f(\mathbf{X}_i)}{p(\mathbf{X}_i)}$$

其中 $\mathbf{X}_i$ 是根据概率密度函数 $p(\mathbf{x})$ 采样的随机变量。

**估计量的性质**：

- **无偏性**：$E[\hat{I}] = I$
- **方差**：$\text{Var}[\hat{I}] = \frac{1}{N} \int_D \left(\frac{f(\mathbf{x})}{p(\mathbf{x})} - I\right)^2 p(\mathbf{x}) d\mathbf{x}$
- **收敛性**：$\hat{I} \xrightarrow{P} I$ 当 $N \to \infty$

#### 重要性采样的数学优化

**方差最小化**：
最优的概率密度函数为：
$$p^*(\mathbf{x}) = \frac{|f(\mathbf{x})|}{\int_D |f(\mathbf{y})| d\mathbf{y}}$$

此时方差为零，但实际中难以实现。

**实用的重要性采样策略**：
选择 $p(\mathbf{x}) \propto |f(\mathbf{x})|$ 可以显著减少方差。

#### 在路径追踪中的实现

```cpp
Vector3f monte_carlo_integration(const Intersection& hit_point, int samples) {
    Vector3f color(0, 0, 0);
    const Vector3f& normal = hit_point.normal;

    for (int i = 0; i < samples; ++i) {
        // 重要性采样：按余弦分布采样
        Vector3f sample_dir = cosine_weighted_hemisphere_sample();

        // 计算采样概率密度
        float cos_theta = std::max(0.0f, normal.dot(sample_dir));
        float pdf = cos_theta / M_PI;  // 余弦加权采样的PDF

        if (pdf > 1e-6) {
            // 计算BRDF值
            Vector3f brdf_value = evaluate_brdf(hit_point, sample_dir);

            // 递归追踪光线
            Vector3f incoming_radiance = trace_ray(hit_point.position, sample_dir);

            // 蒙特卡洛估计
            color += brdf_value * incoming_radiance * cos_theta / pdf;
        }
    }

    return color / static_cast<float>(samples);
}

// 余弦加权半球采样
Vector3f cosine_weighted_hemisphere_sample() {
    float u1 = random_float();
    float u2 = random_float();

    float cos_theta = std::sqrt(u1);
    float sin_theta = std::sqrt(1.0f - u1);
    float phi = 2.0f * M_PI * u2;

    return Vector3f(sin_theta * std::cos(phi),
                   sin_theta * std::sin(phi),
                   cos_theta);
}
```

## 图形渲染管线概述

## 5.1 渲染管线的整体架构

### 5.1.1 管线阶段划分

**应用阶段（Application Stage）**：

- 场景管理：构建场景图
- 视锥体裁剪：剔除不可见物体
- 细节层次控制：根据距离选择模型精度
- 动画更新：骨骼动画、变形动画

**几何阶段（Geometry Stage）**：

- 顶点着色：变换顶点位置
- 投影：3D到2D的映射
- 裁剪：移除视锥体外的几何体
- 屏幕映射：NDC到屏幕坐标

**光栅化阶段（Rasterization Stage）**：

- 三角形设置：计算边方程
- 三角形遍历：确定覆盖的像素
- 像素着色：计算每个像素的颜色
- 合并：深度测试、混合等

### 5.1.2 坐标系变换流程的数学推导

#### 完整的变换链

**坐标空间序列**：
$$\text{模型坐标} \xrightarrow{M} \text{世界坐标} \xrightarrow{V} \text{观察坐标} \xrightarrow{P} \text{裁剪坐标} \xrightarrow{\text{透视除法}} \text{NDC} \xrightarrow{S} \text{屏幕坐标}$$

#### MVP变换的数学表示

**复合变换矩阵**：
$$\mathbf{V}_{clip} = \mathbf{P} \cdot \mathbf{V} \cdot \mathbf{M} \cdot \mathbf{V}_{model}$$

其中：

- $\mathbf{M} \in \mathbb{R}^{4 \times 4}$：模型变换矩阵（Model Matrix）
- $\mathbf{V} \in \mathbb{R}^{4 \times 4}$：视图变换矩阵（View Matrix）
- $\mathbf{P} \in \mathbb{R}^{4 \times 4}$：投影变换矩阵（Projection Matrix）

#### 透视除法（Perspective Division）

**齐次坐标到NDC的转换**：

透视除法：$(x_{clip}, y_{clip}, z_{clip}, w_{clip}) \rightarrow (x_{clip}/w_{clip}, y_{clip}/w_{clip}, z_{clip}/w_{clip})$

$$\mathbf{V}_{ndc} = (x_{ndc}, y_{ndc}, z_{ndc}) = (x_{clip}/w_{clip}, y_{clip}/w_{clip}, z_{clip}/w_{clip})$$

**NDC范围**：$x_{ndc}, y_{ndc}, z_{ndc} \in [-1, 1]$

#### 视口变换（Viewport Transform）

**从NDC到屏幕坐标**：

视口变换矩阵 $\mathbf{S}$ 的结构：

- 第1行：$(\frac{w}{2}, 0, 0, \frac{w}{2})$
- 第2行：$(0, \frac{h}{2}, 0, \frac{h}{2})$
- 第3行：$(0, 0, \frac{d}{2}, \frac{d}{2})$
- 第4行：$(0, 0, 0, 1)$

$$\mathbf{S} = \text{viewport transformation matrix}$$

其中：

- $w$：屏幕宽度（像素）
- $h$：屏幕高度（像素）
- $d$：深度缓冲区范围

**最终屏幕坐标**：

对于NDC坐标 $(x_{ndc}, y_{ndc}, z_{ndc}, 1)$，屏幕坐标为：
$$\mathbf{V}_{screen} = \left(\frac{w}{2}(x_{ndc} + 1), \frac{h}{2}(y_{ndc} + 1), \frac{d}{2}(z_{ndc} + 1), 1\right)$$

#### 变换的几何意义

**坐标系的右手/左手约定**：

- **OpenGL**：右手坐标系，$z_{ndc} \in [-1, 1]$
- **DirectX**：左手坐标系，$z_{ndc} \in [0, 1]$

**深度值的非线性分布**：
透视投影后，深度值在近平面附近密集，远平面附近稀疏：
$$z_{ndc} = \frac{-(f+n)z - 2fn}{z(f-n)}$$

## 5.2 可编程着色器架构

### 5.2.1 顶点着色器（Vertex Shader）

**主要功能**：

- 顶点位置变换
- 法向量变换
- 纹理坐标传递
- 光照计算（Gouraud着色）

**典型顶点着色器**：

```glsl
# version 330 core

layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoord;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoord;

void main() {
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    TexCoord = aTexCoord;

    gl_Position = projection * view * vec4(FragPos, 1.0);
}
```

### 5.2.2 片段着色器（Fragment Shader）

**主要功能**：

- 像素颜色计算
- 纹理采样
- 光照计算（Phong着色）
- 特效处理

**典型片段着色器**：

```glsl
# version 330 core

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoord;

uniform sampler2D texture_diffuse1;
uniform vec3 lightPos;
uniform vec3 viewPos;

out vec4 FragColor;

void main() {
    // 环境光
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * vec3(1.0);

    // 漫反射
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * vec3(1.0);

    // 镜面反射
    float specularStrength = 0.5;
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
    vec3 specular = specularStrength * spec * vec3(1.0);

    vec3 result = (ambient + diffuse + specular) * texture(texture_diffuse1, TexCoord).rgb;
    FragColor = vec4(result, 1.0);
}
```

---

## 顶点处理与变换

## 6.1 顶点属性与数据结构

### 6.1.1 顶点数据组织

**基本顶点属性**：

```cpp
struct Vertex {
    Vector3f position;    // 位置
    Vector3f normal;      // 法向量
    Vector2f texCoord;    // 纹理坐标
    Vector3f tangent;     // 切向量
    Vector3f bitangent;   // 副切向量
    Vector4f color;       // 顶点颜色
};
```

**顶点缓冲对象（VBO）**：

```cpp
// 创建并绑定VBO
unsigned int VBO;
glGenBuffers(1, &VBO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex),
             vertices.data(), GL_STATIC_DRAW);
```

### 6.1.2 顶点数组对象（VAO）

**VAO的作用**：

- 存储顶点属性配置
- 简化渲染调用
- 提高渲染效率

**VAO配置示例**：

```cpp
unsigned int VAO;
glGenVertexArrays(1, &VAO);
glBindVertexArray(VAO);

// 位置属性
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);
glEnableVertexAttribArray(0);

// 法向量属性
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex),
                      (void*)offsetof(Vertex, normal));
glEnableVertexAttribArray(1);

// 纹理坐标属性
glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex),
                      (void*)offsetof(Vertex, texCoord));
glEnableVertexAttribArray(2);
```

## 6.2 变换矩阵的计算与优化

### 6.2.1 法向量变换的数学推导

#### 问题的提出

**核心问题**：法向量不能直接用模型变换矩阵进行变换，否则会破坏垂直关系。

#### 数学推导过程

**平面的隐式表示**：
设平面方程为：
$$\vec{n} \cdot \vec{p} = d$$

其中 $\vec{n}$ 是法向量，$\vec{p}$ 是平面上的点，$d$ 是常数。

**变换后的约束条件**：
变换后的平面方程应为：
$$\vec{n}' \cdot \vec{p}' = d$$

**点的变换关系**：
已知点的变换为：$\vec{p}' = \mathbf{M}\vec{p}$

**法向量变换的推导**：
为保持垂直关系，需要：
$$\vec{n}' \cdot (\mathbf{M}\vec{p}) = \vec{n} \cdot \vec{p}$$

将其写成矩阵形式：
$$(\vec{n}')^T \mathbf{M}\vec{p} = \vec{n}^T \vec{p}$$

由于这对所有 $\vec{p}$ 都成立，因此：
$$(\vec{n}')^T \mathbf{M} = \vec{n}^T$$

转置得到：
$$\mathbf{M}^T \vec{n}' = \vec{n}$$

解得：
$$\vec{n}' = (\mathbf{M}^T)^{-1}\vec{n} = (\mathbf{M}^{-1})^T\vec{n}$$

#### 法向量变换矩阵

**法向量变换矩阵**：
$$\mathbf{N} = (\mathbf{M}^{-1})^T$$

其中 $\mathbf{M}$ 是模型变换矩阵的左上角 $3 \times 3$ 子矩阵。

**特殊情况**：

- **正交变换**：当 $\mathbf{M}$ 是正交矩阵时，$\mathbf{M}^{-1} = \mathbf{M}^T$，因此 $\mathbf{N} = \mathbf{M}$
- **均匀缩放**：当 $\mathbf{M} = s\mathbf{I}$ 时，$\mathbf{N} = \frac{1}{s}\mathbf{I}$

#### 工程实现

```cpp
// 计算法向量变换矩阵
Matrix3f compute_normal_matrix(const Matrix4f& model_matrix) {
    Matrix3f upper_left = model_matrix.block<3,3>(0,0);
    return upper_left.inverse().transpose();
}

// 应用法向量变换
Vector3f transform_normal(const Vector3f& normal, const Matrix4f& model_matrix) {
    Matrix3f normal_matrix = compute_normal_matrix(model_matrix);
    Vector3f transformed = normal_matrix * normal;
    return transformed.normalized();  // 重新归一化
}
```

### 6.2.2 变换矩阵的TRS分解

#### TRS分解的数学理论

**分解定理**：
任何非奇异的仿射变换矩阵 $\mathbf{M}$ 都可以唯一分解为：
$$\mathbf{M} = \mathbf{T} \cdot \mathbf{R} \cdot \mathbf{S}$$

其中：

- $\mathbf{T}$：平移矩阵（Translation）
- $\mathbf{R}$：旋转矩阵（Rotation）
- $\mathbf{S}$：缩放矩阵（Scaling）

#### 分解算法的数学推导

**矩阵结构分析**：

变换矩阵的分块结构：

- 左上角 $3 \times 3$ 子矩阵 $\mathbf{A}$：包含旋转和缩放
- 右上角列向量 $\vec{t}$：平移向量
- 左下角行向量 $\vec{0}^T$：零向量
- 右下角标量：1

$$\mathbf{M} = \text{block matrix structure}$$

其中 $\mathbf{A} \in \mathbb{R}^{3 \times 3}$ 是线性变换部分，$\vec{t} \in \mathbb{R}^3$ 是平移向量。

**第一步：提取平移**
$$\vec{t} = \mathbf{M}_{[0:3,3]}$$

**第二步：分解线性变换**
对矩阵 $\mathbf{A}$ 进行极分解：$\mathbf{A} = \mathbf{R} \cdot \mathbf{S}$

**缩放因子计算**：
$$s_x = \|\mathbf{A}_{[:,0]}\|, \quad s_y = \|\mathbf{A}_{[:,1]}\|, \quad s_z = \|\mathbf{A}_{[:,2]}\|$$

**旋转矩阵提取**：

旋转矩阵通过归一化列向量获得：
$$\mathbf{R} = [\frac{\mathbf{A}_{[:,0]}}{s_x}, \frac{\mathbf{A}_{[:,1]}}{s_y}, \frac{\mathbf{A}_{[:,2]}}{s_z}]$$

其中每一列都是归一化后的旋转轴。

#### 处理反射变换

**行列式检查**：
如果 $\det(\mathbf{A}) < 0$，说明包含反射变换：
$$s_z = -s_z$$
$$\mathbf{R}_{[:,2]} = -\mathbf{R}_{[:,2]}$$

#### 完整的分解实现

```cpp
struct Transform {
    Vector3f translation;
    Quaternionf rotation;
    Vector3f scale;
};

Transform decompose_matrix(const Matrix4f& matrix) {
    Transform result;

    // 1. 提取平移
    result.translation = matrix.block<3,1>(0,3);

    // 2. 提取线性变换部分
    Matrix3f A = matrix.block<3,3>(0,0);

    // 3. 计算缩放因子
    result.scale.x() = A.col(0).norm();
    result.scale.y() = A.col(1).norm();
    result.scale.z() = A.col(2).norm();

    // 4. 处理反射（负行列式）
    if (A.determinant() < 0) {
        result.scale.z() = -result.scale.z();
    }

    // 5. 提取旋转矩阵
    Matrix3f R;
    R.col(0) = A.col(0) / result.scale.x();
    R.col(1) = A.col(1) / result.scale.y();
    R.col(2) = A.col(2) / result.scale.z();

    // 6. 转换为四元数
    result.rotation = Quaternionf(R);

    return result;
}
    rotation_matrix.col(1) = upper_left.col(1) / scale.y();
    rotation_matrix.col(2) = upper_left.col(2) / scale.z();

    // 转换为四元数
    rotation = Quaternionf(rotation_matrix);
}
```

---

## 图元装配与裁剪

## 7.1 图元装配过程

### 7.1.1 图元类型

**基本图元**：

- 点（Points）
- 线段（Lines）
- 三角形（Triangles）

**扩展图元**：

- 线条带（Line Strip）
- 三角形带（Triangle Strip）
- 三角形扇（Triangle Fan）

### 7.1.2 索引缓冲对象（EBO）

**作用**：减少顶点数据冗余

**示例**：

```cpp
// 顶点数据（4个顶点定义矩形）
float vertices[] = {
     0.5f,  0.5f, 0.0f,  // 右上
     0.5f, -0.5f, 0.0f,  // 右下
    -0.5f, -0.5f, 0.0f,  // 左下
    -0.5f,  0.5f, 0.0f   // 左上
};

// 索引数据（2个三角形）
unsigned int indices[] = {
    0, 1, 3,  // 第一个三角形
    1, 2, 3   // 第二个三角形
};

// 创建EBO
unsigned int EBO;
glGenBuffers(1, &EBO);
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
```

## 7.2 裁剪算法

### 7.2.1 视锥体裁剪的数学理论

#### 视锥体的数学定义

**标准化设备坐标（NDC）中的视锥体**：
在齐次裁剪坐标系中，视锥体由六个半空间定义：

**六个裁剪平面**：

- 左平面：$x \geq -w$
- 右平面：$x \leq w$
- 下平面：$y \geq -w$
- 上平面：$y \leq w$
- 近平面：$z \geq -w$
- 远平面：$z \leq w$

其中 $(x, y, z, w)$ 是齐次裁剪坐标。

#### 点的裁剪测试

**数学条件**：
点 $\mathbf{P}_{clip} = (x, y, z, w)$ 在视锥体内当且仅当：
$$-w \leq x \leq w \quad \text{且} \quad -w \leq y \leq w \quad \text{且} \quad -w \leq z \leq w$$

**几何意义**：
这等价于透视除法后的NDC坐标满足：
$$-1 \leq \frac{x}{w} \leq 1, \quad -1 \leq \frac{y}{w} \leq 1, \quad -1 \leq \frac{z}{w} \leq 1$$

#### 工程实现

```cpp
bool is_inside_frustum(const Vector4f& clip_pos) {
    float w = clip_pos.w();

    // 检查w分量的有效性
    if (w <= 0) return false;  // 在相机后方

    return (clip_pos.x() >= -w && clip_pos.x() <= w &&
            clip_pos.y() >= -w && clip_pos.y() <= w &&
            clip_pos.z() >= -w && clip_pos.z() <= w);
}

// 计算点到裁剪平面的距离
float distance_to_plane(const Vector4f& point, int plane_index) {
    switch (plane_index) {
        case 0: return point.w() + point.x();  // 左平面
        case 1: return point.w() - point.x();  // 右平面
        case 2: return point.w() + point.y();  // 下平面
        case 3: return point.w() - point.y();  // 上平面
        case 4: return point.w() + point.z();  // 近平面
        case 5: return point.w() - point.z();  // 远平面
        default: return 0.0f;
    }
}
```

### 7.2.2 Sutherland-Hodgman裁剪算法

#### 算法的数学原理

**基本思想**：
对多边形逐个裁剪平面进行裁剪，每次裁剪产生一个新的多边形，直到所有裁剪平面都处理完毕。

**数学模型**：
设多边形的顶点序列为 $\{V_0, V_1, \ldots, V_{n-1}\}$，裁剪平面方程为：
$$\pi: \mathbf{n} \cdot \mathbf{p} + d = 0$$

其中 $\mathbf{n}$ 是平面法向量，$d$ 是距离参数。

#### 点与平面的位置关系

**符号距离函数**：
$$\text{dist}(\mathbf{p}, \pi) = \mathbf{n} \cdot \mathbf{p} + d$$

**位置判断**：

- $\text{dist}(\mathbf{p}, \pi) > 0$：点在平面正侧（内部）
- $\text{dist}(\mathbf{p}, \pi) = 0$：点在平面上
- $\text{dist}(\mathbf{p}, \pi) < 0$：点在平面负侧（外部）

#### 线段与平面的交点计算

**参数方程**：
线段 $\overline{P_1P_2}$ 的参数方程为：
$$\mathbf{L}(t) = \mathbf{P_1} + t(\mathbf{P_2} - \mathbf{P_1}), \quad t \in [0, 1]$$

**交点参数求解**：
将参数方程代入平面方程：
$$\mathbf{n} \cdot [\mathbf{P_1} + t(\mathbf{P_2} - \mathbf{P_1})] + d = 0$$

解得：
$$t = -\frac{\mathbf{n} \cdot \mathbf{P_1} + d}{\mathbf{n} \cdot (\mathbf{P_2} - \mathbf{P_1})} = -\frac{\text{dist}(\mathbf{P_1}, \pi)}{\mathbf{n} \cdot (\mathbf{P_2} - \mathbf{P_1})}$$

**交点坐标**：
$$\mathbf{P}_{intersection} = \mathbf{P_1} + t(\mathbf{P_2} - \mathbf{P_1})$$

#### 算法实现

```cpp
class SutherlandHodgmanClipper {
private:
    struct Plane {
        Vector3f normal;
        float d;

        float distance(const Vector3f& point) const {
            return normal.dot(point) + d;
        }

        bool is_inside(const Vector3f& point) const {
            return distance(point) >= 0;
        }
    };

public:
    std::vector<Vector3f> clip_polygon(const std::vector<Vector3f>& polygon,
                                      const std::vector<Plane>& planes) {
        std::vector<Vector3f> input = polygon;

        for (const auto& plane : planes) {
            std::vector<Vector3f> output;

            if (input.empty()) break;

            Vector3f prev_vertex = input.back();
            bool prev_inside = plane.is_inside(prev_vertex);

            for (const auto& curr_vertex : input) {
                bool curr_inside = plane.is_inside(curr_vertex);

                if (curr_inside) {
                    if (!prev_inside) {
                        // 从外部进入：添加交点
                        Vector3f intersection = compute_intersection(prev_vertex, curr_vertex, plane);
                        output.push_back(intersection);
                    }
                    // 添加当前顶点
                    output.push_back(curr_vertex);
                } else if (prev_inside) {
                    // 从内部离开：只添加交点
                    Vector3f intersection = compute_intersection(prev_vertex, curr_vertex, plane);
                    output.push_back(intersection);
                }
                // 两点都在外部：不添加任何点

                prev_vertex = curr_vertex;
                prev_inside = curr_inside;
            }

            input = output;
        }

        return input;
    }

private:
    Vector3f compute_intersection(const Vector3f& p1, const Vector3f& p2, const Plane& plane) {
        Vector3f direction = p2 - p1;
        float denominator = plane.normal.dot(direction);

        if (std::abs(denominator) < 1e-6f) {
            return p1;  // 线段平行于平面
        }

        float t = -plane.distance(p1) / denominator;
        return p1 + t * direction;
    }
};
```

---

## 光栅化算法详解

## 8.1 三角形光栅化基础

### 8.1.1 扫描线算法的数学原理

#### 算法概述与数学基础

**基本思想**：扫描线算法通过逐行扫描的方式填充三角形，是经典的多边形光栅化方法。

**核心数学原理**：

1. **直线方程**：利用直线的参数方程或隐式方程计算交点
2. **区间填充**：在每条扫描线上填充左右边界之间的像素
3. **增量计算**：利用相邻扫描线的相关性优化计算

#### 直线方程与交点计算

**参数直线方程**：
连接点 $P_1(x_1, y_1)$ 和 $P_2(x_2, y_2)$ 的直线：

参数方程（$t \in [0, 1]$）：
$$x(t) = x_1 + t(x_2 - x_1)$$
$$y(t) = y_1 + t(y_2 - y_1)$$

**扫描线交点计算**：
给定水平扫描线 $y = y_s$，求解参数 $t$：
$$y_s = y_1 + t(y_2 - y_1) \implies t = \frac{y_s - y_1}{y_2 - y_1}$$

代入x方程得交点：
$$x_s = x_1 + \frac{y_s - y_1}{y_2 - y_1}(x_2 - x_1) = x_1 + \frac{(y_s - y_1)(x_2 - x_1)}{y_2 - y_1}$$

**增量形式优化**：
相邻扫描线的x坐标增量：
$$\Delta x = \frac{x_2 - x_1}{y_2 - y_1} = \frac{\Delta x}{\Delta y}$$

因此：$x_{i+1} = x_i + \Delta x$

#### 边方程方法（Half-Space Test）

**隐式直线方程**：
对于直线 $AB$，隐式方程为：
$$f_{AB}(x, y) = (y_A - y_B)x + (x_B - x_A)y + (x_A y_B - x_B y_A) = 0$$

**半空间测试**：
点 $P(x, y)$ 相对于有向直线 $AB$ 的位置：

- $f_{AB}(P) > 0$：点在直线左侧
- $f_{AB}(P) = 0$：点在直线上
- $f_{AB}(P) < 0$：点在直线右侧

**三角形内部判断**：
对于逆时针方向的三角形 $ABC$，点 $P$ 在三角形内当且仅当：

**边函数定义**：

$$E_1(P) = (y_A - y_B)x_P + (x_B - x_A)y_P + (x_A y_B - x_B y_A) \geq 0$$

$$E_2(P) = (y_B - y_C)x_P + (x_C - x_B)y_P + (x_B y_C - x_C y_B) \geq 0$$

$$E_3(P) = (y_C - y_A)x_P + (x_A - x_C)y_P + (x_C y_A - x_A y_C) \geq 0$$

#### 优化的扫描线实现

```cpp
void optimized_scanline_triangle(const Triangle& t) {
    auto vertices = t.toVector4();

    // 按y坐标排序
    std::sort(vertices.begin(), vertices.end(),
              [](const Vector4f& a, const Vector4f& b) { return a.y() < b.y(); });

    Vector4f v0 = vertices[0], v1 = vertices[1], v2 = vertices[2];

    // 计算边的增量
    float dx01 = (v1.x() - v0.x()) / (v1.y() - v0.y());
    float dx02 = (v2.x() - v0.x()) / (v2.y() - v0.y());
    float dx12 = (v2.x() - v1.x()) / (v2.y() - v1.y());

    // 上半部分三角形 (v0 到 v1)
    float x_left = v0.x(), x_right = v0.x();
    for (int y = v0.y(); y <= v1.y(); y++) {
        fill_horizontal_line(x_left, x_right, y, t.getColor());
        x_left += dx01;
        x_right += dx02;
    }

    // 下半部分三角形 (v1 到 v2)
    x_left = v1.x();  // 重新设置左边界
    for (int y = v1.y(); y <= v2.y(); y++) {
        fill_horizontal_line(x_left, x_right, y, t.getColor());
        x_left += dx12;
        x_right += dx02;
    }
}
```

### 8.1.2 重心坐标系统（Barycentric Coordinates）

#### 重心坐标的数学基础

**定义**：对于三角形 $\triangle ABC$ 和平面内任意点 $P$，重心坐标是一组权重 $(\alpha, \beta, \gamma)$，使得：
$$P = \alpha A + \beta B + \gamma C$$
$$\alpha + \beta + \gamma = 1$$

**几何解释**：

- $\alpha, \beta, \gamma$ 分别表示点 $P$ 相对于顶点 $A, B, C$ 的"重量"
- 当 $\alpha, \beta, \gamma \geq 0$ 时，点 $P$ 在三角形内部
- 重心坐标提供了三角形内任意点的唯一表示

#### 重心坐标的计算方法

**面积比方法**：
重心坐标等于子三角形面积与总三角形面积的比值：
$$\alpha = \frac{S_{\triangle PBC}}{S_{\triangle ABC}}, \quad \beta = \frac{S_{\triangle APC}}{S_{\triangle ABC}}, \quad \gamma = \frac{S_{\triangle APB}}{S_{\triangle ABC}}$$

**向量叉积计算**：
利用叉积计算有向面积：
$$\alpha = \frac{(\vec{BP} \times \vec{BC}) \cdot \vec{n}}{(\vec{BA} \times \vec{BC}) \cdot \vec{n}}$$
其中 $\vec{n}$ 是三角形的法向量。

**GAMES101 Assignment 2实现**：

```cpp
// 基于面积的重心坐标计算
static std::tuple<float, float, float> computeBarycentric2D(float x, float y, const Vector3f* v) {
    float c1 = (x*(v[1].y() - v[2].y()) + (v[2].x() - v[1].x())*y + v[1].x()*v[2].y() - v[2].x()*v[1].y()) /
               (v[0].x()*(v[1].y() - v[2].y()) + (v[2].x() - v[1].x())*v[0].y() + v[1].x()*v[2].y() - v[2].x()*v[1].y());
    float c2 = (x*(v[2].y() - v[0].y()) + (v[0].x() - v[2].x())*y + v[2].x()*v[0].y() - v[0].x()*v[2].y()) /
               (v[1].x()*(v[2].y() - v[0].y()) + (v[0].x() - v[2].x())*v[1].y() + v[2].x()*v[0].y() - v[0].x()*v[2].y());
    float c3 = (x*(v[0].y() - v[1].y()) + (v[1].x() - v[0].x())*y + v[0].x()*v[1].y() - v[1].x()*v[0].y()) /
               (v[2].x()*(v[0].y() - v[1].y()) + (v[1].x() - v[0].x())*v[2].y() + v[0].x()*v[1].y() - v[1].x()*v[0].y());
    return {c1, c2, c3};
}

// 优化版本：避免重复计算
Vector3f barycentric_coordinates(const Vector2f& A, const Vector2f& B,
                                const Vector2f& C, const Vector2f& P) {
    Vector2f v0 = C - A;
    Vector2f v1 = B - A;
    Vector2f v2 = P - A;

    float dot00 = v0.dot(v0);
    float dot01 = v0.dot(v1);
    float dot02 = v0.dot(v2);
    float dot11 = v1.dot(v1);
    float dot12 = v1.dot(v2);

    float inv_denom = 1.0f / (dot00 * dot11 - dot01 * dot01);
    float u = (dot11 * dot02 - dot01 * dot12) * inv_denom;
    float v = (dot00 * dot12 - dot01 * dot02) * inv_denom;

    return Vector3f(1.0f - u - v, v, u);  // $(\alpha, \beta, \gamma)$
}
```

#### 重心坐标的几何意义

**面积解释**：

- $\alpha = \frac{\text{Area}(\triangle PBC)}{\text{Area}(\triangle ABC)}$：点P到边BC的"距离权重"
- $\beta = \frac{\text{Area}(\triangle APC)}{\text{Area}(\triangle ABC)}$：点P到边AC的"距离权重"
- $\gamma = \frac{\text{Area}(\triangle APB)}{\text{Area}(\triangle ABC)}$：点P到边AB的"距离权重"

**边界情况**：

- $P = A$：$(\alpha, \beta, \gamma) = (1, 0, 0)$
- $P = B$：$(\alpha, \beta, \gamma) = (0, 1, 0)$
- $P = C$：$(\alpha, \beta, \gamma) = (0, 0, 1)$
- $P$ 在边 $AB$ 上：$\gamma = 0$，$\alpha + \beta = 1$

#### 重心坐标的应用

**1. 点在三角形内部判断**：

```cpp
bool is_inside_triangle(float alpha, float beta, float gamma) {
    return alpha >= 0 && beta >= 0 && gamma >= 0;
}
```

**2. 属性插值**：
对于三角形顶点的任意属性（颜色、深度、纹理坐标等），可以用重心坐标进行插值：

```cpp
// 深度插值
float interpolated_depth = alpha * depth_A + beta * depth_B + gamma * depth_C;

// 颜色插值
Vector3f interpolated_color = alpha * color_A + beta * color_B + gamma * color_C;

// 纹理坐标插值
Vector2f interpolated_uv = alpha * uv_A + beta * uv_B + gamma * uv_C;
```

## 8.2 属性插值

### 8.2.1 透视校正插值

**问题**：屏幕空间的线性插值在透视投影下不正确

**解决方案**：在齐次坐标空间进行插值

**透视正确插值公式**：

深度倒数插值：
$$\frac{1}{z} = \frac{\alpha}{z_1} + \frac{\beta}{z_2} + \frac{\gamma}{z_3}$$

纹理坐标u分量插值：
$$\frac{u}{z} = \alpha\frac{u_1}{z_1} + \beta\frac{u_2}{z_2} + \gamma\frac{u_3}{z_3}$$

纹理坐标v分量插值：
$$\frac{v}{z} = \alpha\frac{v_1}{z_1} + \beta\frac{v_2}{z_2} + \gamma\frac{v_3}{z_3}$$

最终纹理坐标：
$$u = \frac{u/z}{1/z}, \quad v = \frac{v/z}{1/z}$$

**代码实现**：

```cpp
Vector2f perspective_correct_interpolation(const Vector3f& bary,
                                          const Vector2f& uv1, float z1,
                                          const Vector2f& uv2, float z2,
                                          const Vector2f& uv3, float z3) {
    float inv_z = bary.x() / z1 + bary.y() / z2 + bary.z() / z3;
    float u_over_z = bary.x() * uv1.x() / z1 +
                     bary.y() * uv2.x() / z2 +
                     bary.z() * uv3.x() / z3;
    float v_over_z = bary.x() * uv1.y() / z1 +
                     bary.y() * uv2.y() / z2 +
                     bary.z() * uv3.y() / z3;

    return Vector2f(u_over_z / inv_z, v_over_z / inv_z);
}
```

### 8.2.2 现代GPU并行光栅化算法

#### Tile-Based光栅化

**基本思想**：
现代GPU将屏幕分割成小的tile（通常8×8或16×16像素），每个tile并行处理。

**算法流程**：

1. **Tile分割**：将屏幕分成规则的tile网格
2. **三角形分配**：确定每个三角形覆盖哪些tile
3. **并行光栅化**：每个tile独立进行光栅化
4. **结果合并**：将各tile的结果合并到最终图像

**数学模型**：
对于tile $(i, j)$，其屏幕坐标范围为：

**Tile坐标计算**：
$$x_{min} = i \times \text{tile\_size}$$
$$x_{max} = (i + 1) \times \text{tile\_size} - 1$$
$$y_{min} = j \times \text{tile\_size}$$
$$y_{max} = (j + 1) \times \text{tile\_size} - 1$$

**三角形-Tile相交测试**：
使用分离轴定理（SAT）或包围盒测试快速判断三角形是否与tile相交。

#### GPU Warp/Wavefront并行模型

**SIMD执行模型**：
GPU以warp（NVIDIA）或wavefront（AMD）为单位执行，通常包含32个线程。

**并行光栅化实现**：

```cpp
// GPU kernel伪代码
__global__ void rasterize_triangle_kernel(Triangle* triangles, int num_triangles,
                                         float* framebuffer, float* depth_buffer,
                                         int width, int height) {
    int pixel_x = blockIdx.x * blockDim.x + threadIdx.x;
    int pixel_y = blockIdx.y * blockDim.y + threadIdx.y;

    if (pixel_x >= width || pixel_y >= height) return;

    float min_depth = FLT_MAX;
    Vector3f final_color(0, 0, 0);

    // 遍历所有三角形
    for (int i = 0; i < num_triangles; i++) {
        Triangle& tri = triangles[i];

        // 计算重心坐标
        auto [alpha, beta, gamma] = computeBarycentric2D(pixel_x, pixel_y, tri.vertices);

        // 内部测试
        if (alpha >= 0 && beta >= 0 && gamma >= 0) {
            // 插值深度
            float depth = alpha * tri.vertices[0].z +
                         beta * tri.vertices[1].z +
                         gamma * tri.vertices[2].z;

            // 深度测试
            if (depth < min_depth) {
                min_depth = depth;

                // 插值颜色
                final_color = alpha * tri.colors[0] +
                             beta * tri.colors[1] +
                             gamma * tri.colors[2];
            }
        }
    }

    // 写入framebuffer
    int pixel_index = pixel_y * width + pixel_x;
    framebuffer[pixel_index * 3 + 0] = final_color.x;
    framebuffer[pixel_index * 3 + 1] = final_color.y;
    framebuffer[pixel_index * 3 + 2] = final_color.z;
    depth_buffer[pixel_index] = min_depth;
}
```

#### Early-Z优化技术

**Z-Prepass**：
在主渲染pass之前，先进行一次只写深度的pass：

```cpp
// Z-Prepass阶段
void z_prepass(const std::vector<Triangle>& triangles) {
    for (const auto& tri : triangles) {
        rasterize_triangle_depth_only(tri);
    }
}

// 主渲染阶段
void main_render_pass(const std::vector<Triangle>& triangles) {
    for (const auto& tri : triangles) {
        rasterize_triangle_with_early_z(tri);
    }
}
```

**Early-Z测试**：
在片段着色器执行前进行深度测试，可以大幅减少不必要的着色计算。

#### 层次化Z-Buffer（Hi-Z）

**基本原理**：
构建深度缓冲区的mipmap层次结构，每个层级存储下一级的最小/最大深度值。

**快速剔除**：

```cpp
bool hierarchical_z_test(int x, int y, float z, int level) {
    int tile_x = x >> level;
    int tile_y = y >> level;

    float max_z = hi_z_buffer[level][tile_y * (width >> level) + tile_x];

    return z <= max_z;  // 如果当前深度大于tile最大深度，可以剔除
}
```

### 8.2.3 Mipmap与纹理过滤

**Mipmap原理**：预计算多级纹理，根据像素覆盖面积选择合适级别

**级别计算**：

```cpp
float calculate_mipmap_level(const Vector2f& duv_dx, const Vector2f& duv_dy,
                            int texture_width, int texture_height) {
    float du_dx = duv_dx.x() * texture_width;
    float dv_dx = duv_dx.y() * texture_height;
    float du_dy = duv_dy.x() * texture_width;
    float dv_dy = duv_dy.y() * texture_height;

    float max_sqr = std::max(du_dx * du_dx + dv_dx * dv_dx,
                            du_dy * du_dy + dv_dy * dv_dy);

    return 0.5f * std::log2(max_sqr);
}
```

**三线性过滤**：

1. 在两个相邻mipmap级别分别进行双线性过滤
2. 在两个结果间进行线性插值

---

## 深度测试与隐藏面消除

## 9.1 Z-Buffer算法

### 9.1.1 算法原理

**基本思想**：为每个像素维护一个深度值，只绘制最近的表面

**算法步骤**：

```cpp
// 初始化
for each pixel (x, y):
    color_buffer[x][y] = background_color
    depth_buffer[x][y] = infinity

// 渲染
for each triangle:
    for each pixel (x, y) in triangle:
        z = interpolated_depth(x, y)
        if z < depth_buffer[x][y]:
            depth_buffer[x][y] = z
            color_buffer[x][y] = shaded_color(x, y)
```

### 9.1.2 深度值计算的数学分析

#### 线性深度与非线性深度

**线性深度（观察空间）**：
在观察空间中，深度值与距离成线性关系：
$$z_{linear} = \frac{z_{eye} - n}{f - n}$$

其中 $z_{eye}$ 是观察空间中的深度，$n$ 和 $f$ 分别是近平面和远平面距离。

**非线性深度（透视投影后）**：
经过透视投影和透视除法后，NDC空间中的深度为：
$$z_{ndc} = \frac{f + n}{f - n} + \frac{2fn}{(f - n) \cdot z_{eye}}$$

#### 深度精度分析

**精度分布函数**：
深度缓冲区精度定义为：
$$\text{precision}(z) = \frac{dz_{buffer}}{dz_{eye}} = \frac{2fn}{z_{eye}^2(f-n)}$$

**关键观察**：

- 精度与 $z_{eye}^2$ 成反比
- 近平面附近精度最高
- 远平面附近精度急剧下降

#### Z-Fighting的数学原因

**浮点精度限制**：
对于24位深度缓冲区，最小可分辨深度差为：
$$\Delta z_{min} = \frac{1}{2^{24}} \approx 5.96 \times 10^{-8}$$

**临界距离计算**：
两个表面在距离 $z$ 处可分辨的最小间距为：
$$\Delta z_{world} = \frac{z^2(f-n)}{2fn} \cdot \Delta z_{min}$$

#### 深度精度优化策略

**1. 近远平面比值优化**：
最优比值关系：
$$\frac{f}{n} < 10^3$$

**2. 对数深度缓冲**：
使用对数分布改善精度：
$$z_{log} = \frac{\log(z_{eye}/n)}{\log(f/n)}$$

**3. 反向Z缓冲**：
将深度映射反转：
$$z_{reverse} = 1 - z_{ndc}$$

利用浮点数在0附近精度更高的特性。

#### 工程实现

```cpp
// 深度精度分析工具
class DepthPrecisionAnalyzer {
public:
    static float compute_precision(float z_eye, float near, float far) {
        return (2.0f * far * near) / (z_eye * z_eye * (far - near));
    }

    static float min_resolvable_distance(float z_eye, float near, float far, int depth_bits) {
        float depth_resolution = 1.0f / (1 << depth_bits);
        float precision = compute_precision(z_eye, near, far);
        return depth_resolution / precision;
    }

    static void analyze_depth_distribution(float near, float far, int samples = 100) {
        std::cout << "Depth Precision Analysis:\n";
        std::cout << "Near: " << near << ", Far: " << far << "\n";
        std::cout << "Ratio: " << far/near << "\n\n";

        for (int i = 0; i < samples; i++) {
            float t = static_cast<float>(i) / (samples - 1);
            float z_eye = near + t * (far - near);
            float precision = compute_precision(z_eye, near, far);
            float min_dist = min_resolvable_distance(z_eye, near, far, 24);

            std::cout << "z=" << z_eye << ", precision=" << precision
                      << ", min_dist=" << min_dist << "\n";
        }
    }
};

// 反向Z缓冲实现
Matrix4f create_reverse_z_projection(float fov, float aspect, float near, float far) {
    Matrix4f proj = Matrix4f::Zero();

    float tan_half_fov = std::tan(fov * 0.5f);

    proj(0, 0) = 1.0f / (aspect * tan_half_fov);
    proj(1, 1) = 1.0f / tan_half_fov;
    proj(2, 2) = near / (far - near);           // 反向映射
    proj(2, 3) = (far * near) / (far - near);
    proj(3, 2) = 1.0f;                         // 注意：这里是+1而不是-1

    return proj;
}
```

## 9.2 其他隐藏面消除算法

### 9.2.1 画家算法

**原理**：按深度从远到近绘制物体

**优点**：

- 简单易实现
- 支持透明度混合

**缺点**：

- 需要排序，复杂度高
- 无法处理循环遮挡

**实现**：

```cpp
struct Triangle {
    Vector3f vertices[3];
    float avg_depth;
    Color color;
};

bool depth_compare(const Triangle& a, const Triangle& b) {
    return a.avg_depth > b.avg_depth;  // 远到近排序
}

void painters_algorithm(std::vector<Triangle>& triangles) {
    // 计算每个三角形的平均深度
    for (auto& tri : triangles) {
        tri.avg_depth = (tri.vertices[0].z() +
                        tri.vertices[1].z() +
                        tri.vertices[2].z()) / 3.0f;
    }

    // 排序并绘制
    std::sort(triangles.begin(), triangles.end(), depth_compare);

    for (const auto& tri : triangles) {
        rasterize_triangle(tri);
    }
}
```

### 9.2.2 BSP树算法

**原理**：用二叉空间分割树预处理场景

**构建过程**：

1. 选择分割平面
2. 将多边形分为前、后两组
3. 递归构建子树

**遍历渲染**：

```cpp
void render_bsp_tree(BSPNode* node, const Vector3f& view_pos) {
    if (!node) return;

    float distance = node->plane.distance_to_point(view_pos);

    if (distance > 0) {
        // 观察者在平面前方
        render_bsp_tree(node->back, view_pos);   // 先画后面
        render_polygons(node->polygons);         // 再画平面上的多边形
        render_bsp_tree(node->front, view_pos);  // 最后画前面
    } else {
        // 观察者在平面后方
        render_bsp_tree(node->front, view_pos);
        render_polygons(node->polygons);
        render_bsp_tree(node->back, view_pos);
    }
}
```

---

## 光照模型与着色

## 10.1 光照的物理基础理论

### 10.1.1 辐射度量学的数学框架

#### 基本辐射量的定义

**辐射能量（Radiant Energy）**：
$$Q \quad [\text{焦耳, J}]$$
表示电磁辐射携带的总能量。

**辐射通量（Radiant Flux/Power）**：
$$\Phi = \frac{dQ}{dt} \quad [\text{瓦特, W}]$$
表示单位时间内通过某个表面的辐射能量。

**辐射强度（Radiant Intensity）**：
$$I(\omega) = \frac{d\Phi}{d\omega} \quad [\text{W/sr}]$$
表示点光源在某个方向上单位立体角内的辐射通量。

**辐照度（Irradiance）**：
$$E(\mathbf{p}) = \frac{d\Phi}{dA} \quad [\text{W/m}^2]$$
表示单位面积接收到的辐射通量。

**辐射度（Radiance）**：
$$L(\mathbf{p}, \omega) = \frac{d^2\Phi}{d\omega \, dA \cos\theta} \quad [\text{W/(sr}\cdot\text{m}^2\text{)}]$$

这是最重要的辐射量，其中 $\theta$ 是方向 $\omega$ 与表面法向量的夹角。

#### 辐射度的重要性质

**1. 感知相关性**：
辐射度直接对应于人眼或相机传感器接收到的光强。

**2. 传播不变性**：
在真空中，辐射度沿直线传播时保持不变：
$$L(\mathbf{p}_1, \omega_{12}) = L(\mathbf{p}_2, \omega_{21})$$

**3. 可加性**：
多个光源的辐射度可以直接相加：
$$L_{total} = \sum_i L_i$$

### 10.1.2 双向反射分布函数（BRDF）理论

#### BRDF的严格数学定义

**微分形式定义**：
$$f_r(\mathbf{p}, \omega_i, \omega_r) = \frac{dL_r(\mathbf{p}, \omega_r)}{dE_i(\mathbf{p}, \omega_i)} = \frac{dL_r(\mathbf{p}, \omega_r)}{L_i(\mathbf{p}, \omega_i) \cos\theta_i \, d\omega_i}$$

其中：

- $L_r(\mathbf{p}, \omega_r)$：反射辐射度
- $E_i(\mathbf{p}, \omega_i)$：入射辐照度
- $L_i(\mathbf{p}, \omega_i)$：入射辐射度

#### BRDF的物理约束条件

**1. 非负性约束**：
$$f_r(\mathbf{p}, \omega_i, \omega_r) \geq 0$$

**2. 能量守恒约束**：
$$\int_{\Omega} f_r(\mathbf{p}, \omega_i, \omega_r) \cos\theta_r \, d\omega_r \leq 1$$

这确保反射的能量不超过入射能量。

**3. 亥姆霍兹互易性**：
$$f_r(\mathbf{p}, \omega_i, \omega_r) = f_r(\mathbf{p}, \omega_r, \omega_i)$$

这是基于光路可逆性的物理原理。

#### BRDF的几何解释

**立体角微分**：
$$d\omega = \frac{dA \cos\theta}{r^2}$$

其中 $dA$ 是投影面积，$r$ 是距离，$\theta$ 是与法向量的夹角。

**半球积分**：
BRDF在上半球面上的积分给出了反射率：
$$\rho(\omega_i) = \int_{\Omega} f_r(\omega_i, \omega_r) \cos\theta_r \, d\omega_r$$

## 10.2 经典光照模型的数学推导

### 10.2.1 Lambert漫反射模型

#### 物理原理与假设

**理想漫反射表面的特征**：

1. **各向同性**：反射在所有方向上均匀分布
2. **完全漫反射**：没有镜面反射分量
3. **表面粗糙**：微观结构导致光线随机散射

#### Lambert BRDF的数学推导

**基本假设**：反射辐射度在所有方向上恒定
$$L_r(\omega_r) = \text{常数}$$

**能量守恒约束**：
$$\int_{\Omega} f_r \cos\theta_r \, d\omega_r = \rho_d$$

其中 $\rho_d$ 是漫反射率（albedo）。

**半球积分计算**：
$$\int_{\Omega} \cos\theta_r \, d\omega_r = \int_0^{2\pi} \int_0^{\pi/2} \cos\theta_r \sin\theta_r \, d\theta_r \, d\phi = \pi$$

**Lambert BRDF推导**：
由于 $f_r$ 为常数，结合能量守恒：
$$f_r \cdot \pi = \rho_d$$

因此：
$$f_r = \frac{\rho_d}{\pi}$$

#### Lambert余弦定律

**反射辐射度计算**：
$$L_r = \int_{\Omega} f_r L_i(\omega_i) \cos\theta_i \, d\omega_i$$

对于平行光源：
$$L_r = f_r L_i \cos\theta_i = \frac{\rho_d}{\pi} L_i \cos\theta_i$$

**物理意义**：

- $\cos\theta_i$ 项体现了投影面积效应
- 入射角越大，有效照射面积越小

#### 工程实现

```cpp
Vector3f lambert_diffuse(const Vector3f& light_dir, const Vector3f& normal,
                        const Vector3f& light_color, const Vector3f& albedo) {
    // 计算入射角余弦值
    float cos_theta = std::max(0.0f, normal.dot(light_dir));

    // Lambert BRDF: $\frac{albedo}{\pi}$
    // 最终颜色 = $BRDF \times 入射光 \times \cos(\theta) \times \pi$ (积分因子)
    // 简化为：$albedo \times light\_color \times \cos(\theta)$
    return albedo * light_color * cos_theta;
}

// 更严格的实现（包含$\pi$因子）
Vector3f lambert_brdf_strict(const Vector3f& light_dir, const Vector3f& normal,
                            const Vector3f& light_color, const Vector3f& albedo) {
    float cos_theta = std::max(0.0f, normal.dot(light_dir));

    // 严格的Lambert BRDF
    Vector3f brdf = albedo / M_PI;

    // 渲染方程的离散形式
    return brdf * light_color * cos_theta * M_PI;  // $\pi$来自立体角积分
}
```

### 10.2.2 Phong反射模型的数学推导

#### Phong模型的三分量结构

Phong模型将光照分解为三个独立的分量：

**1. 环境光（Ambient）**：
$$I_a = k_a \cdot I_{ambient}$$
模拟复杂的间接光照，是一个常数项。

**2. 漫反射（Diffuse）**：
$$I_d = k_d \cdot I_{light} \cdot (\mathbf{N} \cdot \mathbf{L})$$
使用Lambert余弦定律。

**3. 镜面反射（Specular）**：
$$I_s = k_s \cdot I_{light} \cdot (\mathbf{R} \cdot \mathbf{V})^n$$
模拟光滑表面的镜面高光。

#### 镜面反射的数学推导

**反射向量的计算**：
根据反射定律，入射向量 $\mathbf{L}$ 关于法向量 $\mathbf{N}$ 的反射向量为：
$$\mathbf{R} = 2(\mathbf{N} \cdot \mathbf{L})\mathbf{N} - \mathbf{L}$$

**推导过程**：
设入射向量为 $\mathbf{L}$，将其分解为法向分量和切向分量：
$$\mathbf{L} = \mathbf{L}_{\parallel} + \mathbf{L}_{\perp}$$

其中：

- $\mathbf{L}_{\parallel} = (\mathbf{L} \cdot \mathbf{N})\mathbf{N}$（法向分量）
- $\mathbf{L}_{\perp} = \mathbf{L} - \mathbf{L}_{\parallel}$（切向分量）

反射时，切向分量不变，法向分量反向：
$$\mathbf{R} = \mathbf{L}_{\perp} - \mathbf{L}_{\parallel} = \mathbf{L} - 2\mathbf{L}_{\parallel} = \mathbf{L} - 2(\mathbf{L} \cdot \mathbf{N})\mathbf{N}$$

整理得：
$$\mathbf{R} = 2(\mathbf{N} \cdot \mathbf{L})\mathbf{N} - \mathbf{L}$$

#### 完整的Phong光照方程

$$I_{total} = k_a I_a + k_d I_l (\mathbf{N} \cdot \mathbf{L}) + k_s I_l (\mathbf{R} \cdot \mathbf{V})^n$$

其中：

- $k_a, k_d, k_s$：材质系数
- $n$：光泽度指数（shininess）
- $\mathbf{V}$：视线方向向量

#### 工程实现

```cpp
Vector3f phong_lighting(const Vector3f& position, const Vector3f& normal,
                       const Vector3f& view_dir, const Vector3f& light_pos,
                       const Vector3f& light_color, const Material& material) {
    // 环境光分量
    Vector3f ambient = material.ambient * light_color;

    // 计算光线方向
    Vector3f light_dir = (light_pos - position).normalized();

    // 漫反射分量（Lambert）
    float diff = std::max(normal.dot(light_dir), 0.0f);
    Vector3f diffuse = material.diffuse * light_color * diff;

    // 计算反射向量
    Vector3f reflect_dir = 2.0f * normal.dot(light_dir) * normal - light_dir;
    reflect_dir.normalize();

    // 镜面反射分量
    float spec = std::pow(std::max(view_dir.dot(reflect_dir), 0.0f), material.shininess);
    Vector3f specular = material.specular * light_color * spec;

    return ambient + diffuse + specular;
}
```

### 10.2.3 Blinn-Phong模型的数学改进

#### Blinn-Phong的理论基础

**改进动机**：
Phong模型在计算反射向量时存在效率和稳定性问题，Blinn-Phong通过引入半角向量来解决这些问题。

**半角向量的数学定义**：
$$\mathbf{H} = \frac{\mathbf{L} + \mathbf{V}}{\|\mathbf{L} + \mathbf{V}\|}$$

其中 $\mathbf{L}$ 是光线方向，$\mathbf{V}$ 是视线方向。

#### 几何意义与物理解释

**几何意义**：
$\mathbf{H}$ 是光线方向和视线方向的角平分线，表示能够产生镜面反射的理想微表面法向量。

**物理解释**：
在微表面理论中，只有法向量与半角向量平行的微表面才会将光线从 $\mathbf{L}$ 方向反射到 $\mathbf{V}$ 方向。

#### Blinn-Phong镜面反射公式

**修改后的镜面反射项**：
$$I_s = k_s I_l (\mathbf{N} \cdot \mathbf{H})^{n'}$$

**指数关系**：
为了获得与Phong模型相似的视觉效果，通常需要调整光泽度指数：
$$n' \approx 4n_{phong}$$

#### 数学优势分析

**1. 计算效率**：

- **Phong**：$\mathbf{R} = 2(\mathbf{N} \cdot \mathbf{L})\mathbf{N} - \mathbf{L}$ （6次乘法，3次减法）
- **Blinn-Phong**：$\mathbf{H} = \frac{\mathbf{L} + \mathbf{V}}{\|\mathbf{L} + \mathbf{V}\|}$ （3次加法，1次归一化）

**2. 数值稳定性**：
避免了反射向量在掠射角附近的数值不稳定问题。

**3. 物理合理性**：
更好地符合微表面理论的物理基础。

**代码实现**：

```cpp
Vector3f blinn_phong_specular(const Vector3f& light_dir, const Vector3f& view_dir,
                             const Vector3f& normal, const Vector3f& light_color,
                             const Vector3f& specular_color, float shininess) {
    Vector3f half_dir = (light_dir + view_dir).normalized();
    float spec = std::pow(std::max(normal.dot(half_dir), 0.0f), shininess);
    return specular_color * light_color * spec;
}
```

## 10.3 着色技术

### 10.3.1 平面着色（Flat Shading）

**原理**：每个三角形使用单一颜色

**法向量计算**：

```cpp
Vector3f calculate_face_normal(const Vector3f& v1, const Vector3f& v2, const Vector3f& v3) {
    Vector3f edge1 = v2 - v1;
    Vector3f edge2 = v3 - v1;
    return edge1.cross(edge2).normalized();
}
```

**特点**：

- 计算简单
- 多面体外观明显
- 适合低多边形风格

### 10.3.2 Gouraud着色

**原理**：在顶点计算光照，三角形内部插值

**算法步骤**：

1. 计算顶点法向量（相邻面法向量平均）
2. 在顶点进行光照计算
3. 在三角形内部插值颜色

**顶点法向量计算**：

```cpp
void calculate_vertex_normals(Mesh& mesh) {
    // 初始化顶点法向量为零
    for (auto& vertex : mesh.vertices) {
        vertex.normal = Vector3f::Zero();
    }

    // 累加相邻面的法向量
    for (const auto& face : mesh.faces) {
        Vector3f face_normal = calculate_face_normal(
            mesh.vertices[face.v1].position,
            mesh.vertices[face.v2].position,
            mesh.vertices[face.v3].position
        );

        mesh.vertices[face.v1].normal += face_normal;
        mesh.vertices[face.v2].normal += face_normal;
        mesh.vertices[face.v3].normal += face_normal;
    }

    // 归一化
    for (auto& vertex : mesh.vertices) {
        vertex.normal.normalize();
    }
}
```

### 10.3.3 Phong着色

**原理**：插值法向量，在每个像素进行光照计算

**算法步骤**：

1. 在顶点存储法向量
2. 在三角形内部插值法向量
3. 在每个像素进行光照计算

**法向量插值**：

```cpp
Vector3f interpolate_normal(const Vector3f& bary,
                           const Vector3f& n1, const Vector3f& n2, const Vector3f& n3) {
    Vector3f interpolated = bary.x() * n1 + bary.y() * n2 + bary.z() * n3;
    return interpolated.normalized();
}
```

**质量对比**：

- **Flat** < **Gouraud** < **Phong**（质量递增）
- **Flat** > **Gouraud** > **Phong**（性能递减）

---

## 纹理映射技术

## 11.1 纹理映射基础理论

### 11.1.1 纹理坐标系统的数学基础

#### UV坐标系的定义

**标准化纹理坐标**：
纹理坐标 $(u, v)$ 定义在单位正方形内：
$$(u, v) \in [0, 1] \times [0, 1]$$

其中：

- $u$ 轴：水平方向，对应纹理的宽度
- $v$ 轴：垂直方向，对应纹理的高度

#### 坐标变换

**纹理坐标到像素坐标的映射**：

最近邻采样的像素坐标：
$$x_{pixel} = \lfloor u \cdot (W - 1) \rfloor$$
$$y_{pixel} = \lfloor v \cdot (H - 1) \rfloor$$

其中 $W$ 和 $H$ 分别是纹理的宽度和高度（以像素为单位）。

**连续坐标映射**：
对于需要插值的情况：

连续坐标计算：
$$x_{continuous} = u \cdot W - 0.5$$
$$y_{continuous} = v \cdot H - 0.5$$

减去0.5是为了将采样点放在像素中心。

#### 工程实现

```cpp
struct TextureCoordinate {
    float u, v;

    // 转换为像素坐标（整数）
    std::pair<int, int> to_pixel_coords(int width, int height) const {
        int x = static_cast<int>(u * (width - 1));
        int y = static_cast<int>(v * (height - 1));
        return {x, y};
    }

    // 转换为连续像素坐标（用于插值）
    std::pair<float, float> to_continuous_coords(int width, int height) const {
        float x = u * width - 0.5f;
        float y = v * height - 0.5f;
        return {x, y};
    }
};
```

### 11.1.2 纹理采样理论

#### 点采样（最近邻采样）

**数学定义**：
点采样选择距离采样点最近的纹理像素：
$$T_{nearest}(u, v) = T\left(\left\lfloor u \cdot W + 0.5 \right\rfloor, \left\lfloor v \cdot H + 0.5 \right\rfloor\right)$$

其中 $T(i, j)$ 表示纹理在像素 $(i, j)$ 处的颜色值。

#### 双线性过滤的数学推导

**问题设定**：
给定连续纹理坐标 $(u, v)$，计算对应的纹理值。

**坐标变换**：

连续坐标计算：
$$x = u \cdot W - 0.5$$
$$y = v \cdot H - 0.5$$

**四个邻近像素**：

像素坐标定义：
$$(x_0, y_0) = (\lfloor x \rfloor, \lfloor y \rfloor)$$
$$(x_1, y_0) = (x_0 + 1, y_0)$$
$$(x_0, y_1) = (x_0, y_0 + 1)$$
$$(x_1, y_1) = (x_0 + 1, y_0 + 1)$$

**插值权重**：

权重计算：
$$f_x = x - x_0$$
$$f_y = y - y_0$$

**双线性插值公式**：

分步计算：
$$T_{bilinear}(u, v) = [1-f_y]((1-f_x)T_{00} + f_x T_{10}) + f_y[(1-f_x)T_{01} + f_x T_{11}]$$

展开形式：
$$T_{bilinear}(u, v) = (1-f_x)(1-f_y)T_{00} + f_x(1-f_y)T_{10} + (1-f_x)f_y T_{01} + f_x f_y T_{11}$$

其中 $T_{ij}$ 表示像素 $(x_i, y_j)$ 的颜色值。

**几何解释**：
双线性插值等价于先在x方向进行两次线性插值，再在y方向进行一次线性插值：

**分步插值过程**：

x方向插值：
$$C_0 = (1-f_x)T_{00} + f_x T_{10}$$
$$C_1 = (1-f_x)T_{01} + f_x T_{11}$$

y方向插值：
$$T_{bilinear} = (1-f_y)C_0 + f_y C_1$$

#### 工程实现

```cpp
class TextureSampler {
public:
    static Color sample_nearest(const Texture& texture, float u, float v) {
        int x = static_cast<int>(u * texture.width + 0.5f) % texture.width;
        int y = static_cast<int>(v * texture.height + 0.5f) % texture.height;
        return texture.get_pixel(x, y);
    }

    static Color sample_bilinear(const Texture& texture, float u, float v) {
        float x = u * texture.width - 0.5f;
        float y = v * texture.height - 0.5f;

        int x0 = static_cast<int>(std::floor(x));
        int y0 = static_cast<int>(std::floor(y));
        int x1 = x0 + 1;
        int y1 = y0 + 1;

        float fx = x - x0;
        float fy = y - y0;

        // 获取四个邻近像素（带边界处理）
        Color c00 = texture.get_pixel_wrap(x0, y0);
        Color c10 = texture.get_pixel_wrap(x1, y0);
        Color c01 = texture.get_pixel_wrap(x0, y1);
        Color c11 = texture.get_pixel_wrap(x1, y1);

        // 双线性插值
        Color c0 = lerp(c00, c10, fx);
        Color c1 = lerp(c01, c11, fx);
        return lerp(c0, c1, fy);
    }

private:
    static Color lerp(const Color& a, const Color& b, float t) {
        return a * (1.0f - t) + b * t;
    }
};
```

### 11.1.3 纹理寻址模式的数学定义

#### 重复模式（Repeat/Wrap）

**数学定义**：
$$u_{repeat} = u - \lfloor u \rfloor = u \bmod 1$$

**性质**：

- 周期性：$u_{repeat}(u + k) = u_{repeat}(u)$ 对任意整数 $k$
- 值域：$u_{repeat} \in [0, 1)$

#### 镜像模式（Mirror/Reflect）

**数学定义**：

镜像映射函数：

当 $t \leq 0.5$ 时：$u_{mirror} = 2t$

当 $t > 0.5$ 时：$u_{mirror} = 2(1-t)$

其中 $t = (u/2) \bmod 1$。

**等价表示**：
$$u_{mirror} = 1 - \left|2 \cdot \left(\frac{u}{2} - \left\lfloor \frac{u}{2} + 0.5 \right\rfloor\right)\right|$$

#### 边缘拉伸模式（Clamp to Edge）

**数学定义**：
$$u_{clamp} = \max(0, \min(1, u))$$

**分段函数表示**：

钳制映射函数：

当 $u < 0$ 时：$u_{clamp} = 0$

当 $0 \leq u \leq 1$ 时：$u_{clamp} = u$

当 $u > 1$ 时：$u_{clamp} = 1$

#### 边界颜色模式（Border Color）

**数学定义**：

边界纹理映射函数：

当 $(u, v) \in [0, 1]^2$ 时：$T_{border}(u, v) = T(u, v)$

其他情况：$T_{border}(u, v) = C_{border}$

其中 $C_{border}$ 是预定义的边界颜色。

#### 工程实现

```cpp
enum class WrapMode {
    REPEAT,
    MIRROR,
    CLAMP,
    BORDER
};

class TextureAddressing {
public:
    static float apply_wrap_mode(float coord, WrapMode mode) {
        switch (mode) {
            case WrapMode::REPEAT:
                return coord - std::floor(coord);

            case WrapMode::MIRROR: {
                float t = (coord * 0.5f) - std::floor(coord * 0.5f);
                return (t <= 0.5f) ? (2.0f * t) : (2.0f * (1.0f - t));
            }

            case WrapMode::CLAMP:
                return std::max(0.0f, std::min(1.0f, coord));

            case WrapMode::BORDER:
                return coord;  // 边界检查在采样时处理

            default:
                return coord;
        }
    }

    static std::pair<float, float> apply_wrap_mode_2d(float u, float v,
                                                     WrapMode u_mode, WrapMode v_mode) {
        return {apply_wrap_mode(u, u_mode), apply_wrap_mode(v, v_mode)};
    }
};
```

## 11.2 高级纹理技术

### 11.2.1 Mipmap技术详解

**Mipmap生成算法**：

```cpp
void generate_mipmaps(Texture& texture) {
    int width = texture.width;
    int height = texture.height;
    int level = 0;

    while (width > 1 || height > 1) {
        int new_width = std::max(1, width / 2);
        int new_height = std::max(1, height / 2);

        Texture mip_level(new_width, new_height);

        for (int y = 0; y < new_height; ++y) {
            for (int x = 0; x < new_width; ++x) {
                // 2x2像素区域平均
                Color sum(0, 0, 0, 0);
                int count = 0;

                for (int dy = 0; dy < 2; ++dy) {
                    for (int dx = 0; dx < 2; ++dx) {
                        int src_x = x * 2 + dx;
                        int src_y = y * 2 + dy;

                        if (src_x < width && src_y < height) {
                            sum += texture.get_pixel(src_x, src_y);
                            count++;
                        }
                    }
                }

                mip_level.set_pixel(x, y, sum / count);
            }
        }

        texture.mip_levels[++level] = mip_level;
        width = new_width;
        height = new_height;
    }
}
```

**Mipmap级别计算**：

```cpp
float calculate_mipmap_level(const Vector2f& duv_dx, const Vector2f& duv_dy,
                            int texture_width, int texture_height) {
    float du_dx = duv_dx.x() * texture_width;
    float dv_dx = duv_dx.y() * texture_height;
    float du_dy = duv_dy.x() * texture_width;
    float dv_dy = duv_dy.y() * texture_height;

    float max_sqr = std::max(du_dx * du_dx + dv_dx * dv_dx,
                            du_dy * du_dy + dv_dy * dv_dy);

    return 0.5f * std::log2(max_sqr);
}
```

### 11.2.2 法线贴图（Normal Mapping）

**切线空间法向量**：

```cpp
Vector3f sample_normal_map(const Texture& normal_map, float u, float v) {
    Color normal_color = sample_bilinear(normal_map, u, v);

    // 从[0,1]映射到[-1,1]
    Vector3f normal;
    normal.x() = normal_color.r * 2.0f - 1.0f;
    normal.y() = normal_color.g * 2.0f - 1.0f;
    normal.z() = normal_color.b * 2.0f - 1.0f;

    return normal.normalized();
}
```

**TBN矩阵构建**：

```cpp
Matrix3f build_tbn_matrix(const Vector3f& normal, const Vector3f& tangent) {
    Vector3f N = normal.normalized();
    Vector3f T = tangent.normalized();

    // Gram-Schmidt正交化
    T = (T - N.dot(T) * N).normalized();
    Vector3f B = N.cross(T);

    Matrix3f TBN;
    TBN.col(0) = T;  // Tangent
    TBN.col(1) = B;  // Bitangent
    TBN.col(2) = N;  // Normal

    return TBN;
}
```

**切线空间到世界空间变换**：

```cpp
Vector3f transform_normal(const Vector3f& tangent_normal, const Matrix3f& TBN) {
    return (TBN * tangent_normal).normalized();
}
```

### 11.2.3 环境映射

**球面映射**：

```cpp
Vector2f sphere_mapping(const Vector3f& direction) {
    Vector3f d = direction.normalized();
    float u = 0.5f + std::atan2(d.z(), d.x()) / (2.0f * M_PI);
    float v = 0.5f - std::asin(d.y()) / M_PI;
    return Vector2f(u, v);
}
```

**立方体映射**：

```cpp
struct CubemapSample {
    int face;
    Vector2f uv;
};

CubemapSample cube_mapping(const Vector3f& direction) {
    Vector3f abs_dir = direction.cwiseAbs();
    CubemapSample sample;

    if (abs_dir.x() >= abs_dir.y() && abs_dir.x() >= abs_dir.z()) {
        // X面
        sample.face = direction.x() > 0 ? 0 : 1;  // +X : -X
        sample.uv.x() = direction.x() > 0 ? -direction.z() : direction.z();
        sample.uv.y() = -direction.y();
        sample.uv /= abs_dir.x();
    } else if (abs_dir.y() >= abs_dir.z()) {
        // Y面
        sample.face = direction.y() > 0 ? 2 : 3;  // +Y : -Y
        sample.uv.x() = direction.x();
        sample.uv.y() = direction.y() > 0 ? direction.z() : -direction.z();
        sample.uv /= abs_dir.y();
    } else {
        // Z面
        sample.face = direction.z() > 0 ? 4 : 5;  // +Z : -Z
        sample.uv.x() = direction.z() > 0 ? direction.x() : -direction.x();
        sample.uv.y() = -direction.y();
        sample.uv /= abs_dir.z();
    }

    // 转换到[0,1]范围
    sample.uv = (sample.uv + Vector2f(1, 1)) * 0.5f;
    return sample;
}
```

---

## 参数曲线理论

## 12.1 参数曲线的数学基础

### 12.1.1 参数表示的数学优势

#### 参数曲线的一般形式

**三维参数曲线**：
$$\mathbf{C}(t) = \begin{pmatrix} x(t) \\ y(t) \\ z(t) \end{pmatrix}, \quad t \in [a, b]$$

其中 $x(t)$、$y(t)$、$z(t)$ 是关于参数 $t$ 的连续可微函数。

#### 参数表示相比隐式表示的优势

**1. 计算便利性**：

- **参数形式**：直接代入参数值即可得到曲线上的点
- **隐式形式**：$F(x,y,z) = 0$ 需要求解方程

**2. 动画支持**：
参数 $t$ 可以直接作为时间参数，自然支持动画：
$$\mathbf{position}(t) = \mathbf{C}(t), \quad \mathbf{velocity}(t) = \mathbf{C}'(t)$$

**3. 多值函数处理**：
避免了 $y = f(x)$ 形式无法表示垂直线和闭合曲线的问题。

**4. 微分几何计算**：
切向量、法向量、曲率等几何量的计算更加直接。

### 12.1.2 曲线的微分几何性质

#### 切向量与速度

**切向量（速度向量）**：
$$\mathbf{T}(t) = \mathbf{C}'(t) = \begin{pmatrix} x'(t) \\ y'(t) \\ z'(t) \end{pmatrix}$$

**单位切向量**：
$$\hat{\mathbf{T}}(t) = \frac{\mathbf{T}(t)}{\|\mathbf{T}(t)\|} = \frac{\mathbf{C}'(t)}{\|\mathbf{C}'(t)\|}$$

#### 曲率的数学定义

**曲率的几何定义**：
曲率 $\kappa(t)$ 描述曲线在某点处偏离直线的程度：
$$\kappa(t) = \frac{\|\mathbf{T}'(t)\|}{\|\mathbf{C}'(t)\|} = \frac{\|\mathbf{C}'(t) \times \mathbf{C}''(t)\|}{\|\mathbf{C}'(t)\|^3}$$

**平面曲线的曲率公式**：
对于平面曲线 $\mathbf{C}(t) = (x(t), y(t))$：
$$\kappa(t) = \frac{|x'(t)y''(t) - y'(t)x''(t)|}{(x'(t)^2 + y'(t)^2)^{3/2}}$$

#### 弧长参数化

**弧长函数**：
$$s(t) = \int_a^t \|\mathbf{C}'(\tau)\| d\tau$$

**弧长参数化的优势**：
当曲线以弧长为参数时，$\|\mathbf{C}'(s)\| = 1$，简化了几何计算：
$$\kappa(s) = \|\mathbf{C}''(s)\|$$

**代码实现**：

```cpp
float calculate_curvature_2d(float t,
                            std::function<Vector2f(float)> curve,
                            std::function<Vector2f(float)> first_derivative,
                            std::function<Vector2f(float)> second_derivative) {
    Vector2f first = first_derivative(t);
    Vector2f second = second_derivative(t);

    float numerator = std::abs(first.x() * second.y() - first.y() * second.x());
    float denominator = std::pow(first.squaredNorm(), 1.5f);

    return numerator / denominator;
}
```

## 12.2 常见参数曲线的数学分析

### 12.2.1 直线的参数表示

#### 线性插值的数学形式

**两点间直线的参数方程**：
$$\mathbf{L}(t) = \mathbf{P}_0 + t(\mathbf{P}_1 - \mathbf{P}_0) = (1-t)\mathbf{P}_0 + t\mathbf{P}_1, \quad t \in [0, 1]$$

**几何意义**：

- $t = 0$：位于点 $\mathbf{P}_0$
- $t = 1$：位于点 $\mathbf{P}_1$
- $0 < t < 1$：位于线段 $\mathbf{P}_0\mathbf{P}_1$ 内部

**微分性质**：

- **切向量**：$\mathbf{L}'(t) = \mathbf{P}_1 - \mathbf{P}_0$（常向量）
- **曲率**：$\kappa(t) = 0$（直线曲率为零）

#### 工程实现

```cpp
class ParametricLine {
private:
    Vector3f p0, p1;

public:
    ParametricLine(const Vector3f& start, const Vector3f& end) : p0(start), p1(end) {}

    Vector3f evaluate(float t) const {
        return (1.0f - t) * p0 + t * p1;
    }

    Vector3f tangent() const {
        return (p1 - p0).normalized();
    }

    float length() const {
        return (p1 - p0).norm();
    }
};
```

### 12.2.2 圆与椭圆的参数表示

#### 圆的参数方程

**标准圆的参数形式**：
$$\mathbf{C}(t) = \mathbf{center} + r\begin{pmatrix} \cos(t) \\ \sin(t) \end{pmatrix}, \quad t \in [0, 2\pi]$$

**微分性质**：

- **切向量**：$\mathbf{C}'(t) = r\begin{pmatrix} -\sin(t) \\ \cos(t) \end{pmatrix}$
- **速度大小**：$\|\mathbf{C}'(t)\| = r$
- **曲率**：$\kappa = \frac{1}{r}$（常曲率）

#### 椭圆的参数方程

**标准椭圆**：
$$\mathbf{E}(t) = \mathbf{center} + \begin{pmatrix} a\cos(t) \\ b\sin(t) \end{pmatrix}, \quad t \in [0, 2\pi]$$

其中 $a$ 和 $b$ 分别是长轴和短轴的半长度。

**椭圆的曲率**：
$$\kappa(t) = \frac{ab}{(a^2\sin^2(t) + b^2\cos^2(t))^{3/2}}$$

**特殊点的曲率**：

- 长轴端点：$\kappa = \frac{b^2}{a^3}$
- 短轴端点：$\kappa = \frac{a^2}{b^3}$

#### 三维空间中的圆

**任意平面上的圆**：
$$\mathbf{C}(t) = \mathbf{center} + r(\cos(t)\mathbf{u} + \sin(t)\mathbf{v})$$

其中 $\mathbf{u}$ 和 $\mathbf{v}$ 是圆所在平面的两个正交单位向量。

### 12.2.3 螺旋线

**平面螺旋（阿基米德螺线）**：
$$\mathbf{S}(t) = (at\cos(t), at\sin(t)), \quad t \in [0, n \cdot 2\pi]$$

**空间螺旋**：
$$\mathbf{S}(t) = (a\cos(t), a\sin(t), bt), \quad t \in [0, n \cdot 2\pi]$$

---

## 贝塞尔曲线深度解析

## 13.1 贝塞尔曲线的数学原理

### 13.1.1 伯恩斯坦多项式的深度理论

#### 伯恩斯坦多项式的数学定义

**严格定义**：
$n$ 次伯恩斯坦基函数定义为：
$$B_i^n(t) = \binom{n}{i} t^i (1-t)^{n-i}, \quad i = 0, 1, \ldots, n$$

其中二项式系数：
$$\binom{n}{i} = \frac{n!}{i!(n-i)!}$$

#### 基本性质的数学证明

**1. 非负性**：$B_i^n(t) \geq 0$ 对所有 $t \in [0,1]$

- **证明**：$\binom{n}{i} \geq 0$，$t^i \geq 0$，$(1-t)^{n-i} \geq 0$

**2. 归一性（权重和为1）**：$\sum_{i=0}^{n} B_i^n(t) = 1$

- **证明**：利用二项式定理
$$\sum_{i=0}^{n} B_i^n(t) = \sum_{i=0}^{n} \binom{n}{i} t^i (1-t)^{n-i} = (t + (1-t))^n = 1$$

**3. 对称性**：$B_i^n(t) = B_{n-i}^n(1-t)$

- **证明**：
$$B_{n-i}^n(1-t) = \binom{n}{n-i} (1-t)^{n-i} t^i = \binom{n}{i} t^i (1-t)^{n-i} = B_i^n(t)$$

**4. 端点性质**：

- $B_i^n(0) = \delta_{i0}$（Kronecker delta）
- $B_i^n(1) = \delta_{in}$

**5. 递推关系**：
$$B_i^n(t) = (1-t)B_i^{n-1}(t) + tB_{i-1}^{n-1}(t)$$

这个递推关系是de Casteljau算法的数学基础。

#### 伯恩斯坦多项式的几何意义

**概率解释**：
$B_i^n(t)$ 可以解释为在 $n$ 次独立伯努利试验中，成功概率为 $t$ 时，恰好成功 $i$ 次的概率。

**权重函数性质**：

- 在 $t = 0$ 时，只有 $B_0^n(0) = 1$，其他为0
- 在 $t = 1$ 时，只有 $B_n^n(1) = 1$，其他为0
- 在 $t = i/n$ 时，$B_i^n(t)$ 达到最大值

### 13.1.2 贝塞尔曲线定义

**n次贝塞尔曲线**：
$$B(t) = \sum_{i=0}^{n} P_i \cdot B_i^n(t), \quad t \in [0,1]$$

**常见次数的显式公式**：

**线性（1次）**：
$$B(t) = (1-t)P_0 + tP_1$$

**二次**：
$$B(t) = (1-t)^2P_0 + 2t(1-t)P_1 + t^2P_2$$

**三次**：
$$B(t) = (1-t)^3P_0 + 3t(1-t)^2P_1 + 3t^2(1-t)P_2 + t^3P_3$$

### 13.1.3 项目中的朴素实现

**基于GAMES101 Assignment4的实现**：

```cpp
cv::Point2f naive_bezier(const std::vector<cv::Point2f>& points, float t) {
    // 三次贝塞尔曲线的直接计算
    auto& p0 = points[0], &p1 = points[1], &p2 = points[2], &p3 = points[3];

    float u = 1.0f - t;
    float tt = t * t;
    float uu = u * u;
    float uuu = uu * u;
    float ttt = tt * t;

    cv::Point2f point = uuu * p0;           // $(1-t)^3 \cdot P_0$
    point += 3 * uu * t * p1;               // $3(1-t)^2t \cdot P_1$
    point += 3 * u * tt * p2;               // $3(1-t)t^2 \cdot P_2$
    point += ttt * p3;                      // $t^3 \cdot P_3$

    return point;
}

void draw_bezier_curve(const std::vector<cv::Point2f>& control_points, cv::Mat& window) {
    for (double t = 0.0; t <= 1.0; t += 0.001) {
        auto point = naive_bezier(control_points, t);
        window.at<cv::Vec3b>[point.y, point.x](2) = 255;  // 红色通道
    }
}
```

## 13.2 de Casteljau算法的数学理论

### 13.2.1 算法的数学基础

#### de Casteljau算法的几何原理

**核心思想**：
de Casteljau算法通过递归的线性插值来计算贝塞尔曲线上的点，这种方法在数值上比直接计算伯恩斯坦多项式更稳定。

**数学表述**：
设控制点为 $\mathbf{P}_0, \mathbf{P}_1, \ldots, \mathbf{P}_n$，定义递归序列：
$$\mathbf{P}_i^{(0)} = \mathbf{P}_i, \quad i = 0, 1, \ldots, n$$
$$\mathbf{P}_i^{(k)} = (1-t)\mathbf{P}_i^{(k-1)} + t\mathbf{P}_{i+1}^{(k-1)}, \quad k = 1, 2, \ldots, n; \quad i = 0, 1, \ldots, n-k$$

最终结果：$\mathbf{B}(t) = \mathbf{P}_0^{(n)}$

#### 算法的数学证明

**定理**：de Casteljau算法计算的结果等于贝塞尔曲线的定义式。

**证明思路**：
利用数学归纳法证明：
$$\mathbf{P}_i^{(k)} = \sum_{j=0}^{k} \binom{k}{j} t^j (1-t)^{k-j} \mathbf{P}_{i+j}$$

**基础步骤**：$k=0$ 时显然成立。

**归纳步骤**：假设对 $k-1$ 成立，则：

递推关系：
$$\mathbf{P}_i^{(k)} = (1-t)\mathbf{P}_i^{(k-1)} + t\mathbf{P}_{i+1}^{(k-1)}$$

代入归纳假设：
$$\mathbf{P}_i^{(k)} = (1-t)\sum_{j=0}^{k-1} \binom{k-1}{j} t^j (1-t)^{k-1-j} \mathbf{P}_{i+j} + t\sum_{j=0}^{k-1} \binom{k-1}{j} t^j (1-t)^{k-1-j} \mathbf{P}_{i+1+j}$$

化简得到：
$$\mathbf{P}_i^{(k)} = \sum_{j=0}^{k} \binom{k}{j} t^j (1-t)^{k-j} \mathbf{P}_{i+j}$$

#### 算法的几何解释

**三次贝塞尔曲线示例**：
对于控制点 $\mathbf{P}_0, \mathbf{P}_1, \mathbf{P}_2, \mathbf{P}_3$：

**第一层插值**：

- $\mathbf{P}_0^{(1)} = (1-t)\mathbf{P}_0 + t\mathbf{P}_1$
- $\mathbf{P}_1^{(1)} = (1-t)\mathbf{P}_1 + t\mathbf{P}_2$
- $\mathbf{P}_2^{(1)} = (1-t)\mathbf{P}_2 + t\mathbf{P}_3$

**第二层插值**：

- $\mathbf{P}_0^{(2)} = (1-t)\mathbf{P}_0^{(1)} + t\mathbf{P}_1^{(1)}$
- $\mathbf{P}_1^{(2)} = (1-t)\mathbf{P}_1^{(1)} + t\mathbf{P}_2^{(1)}$

**第三层插值**：

- $\mathbf{P}_0^{(3)} = (1-t)\mathbf{P}_0^{(2)} + t\mathbf{P}_1^{(2)}$

最终 $\mathbf{B}(t) = \mathbf{P}_0^{(3)}$

### 13.2.2 递归实现

```cpp
cv::Point2f recursive_bezier(const std::vector<cv::Point2f>& control_points, float t) {
    if (control_points.size() == 1) {
        return control_points[0];
    }

    std::vector<cv::Point2f> new_points;

    for (size_t i = 0; i < control_points.size() - 1; ++i) {
        cv::Point2f interpolated = (1.0f - t) * control_points[i] + t * control_points[i + 1];
        new_points.push_back(interpolated);
    }

    return recursive_bezier(new_points, t);
}
```

### 13.2.3 迭代实现（更高效）

```cpp
cv::Point2f iterative_bezier(std::vector<cv::Point2f> points, float t) {
    int n = points.size();

    for (int level = 1; level < n; ++level) {
        for (int i = 0; i < n - level; ++i) {
            points[i] = (1.0f - t) * points[i] + t * points[i + 1];
        }
    }

    return points[0];
}
```

## 13.3 贝塞尔曲线的性质与应用

### 13.3.1 重要几何性质

**端点插值性**：

- $B(0) = P_0$
- $B(1) = P_n$

**端点切向量**：

- $B'(0) = n(P_1 - P_0)$
- $B'(1) = n(P_n - P_{n-1})$

**凸包性质**：
贝塞尔曲线完全位于控制点的凸包内

**仿射不变性**：
先变换控制点再生成曲线 = 先生成曲线再变换

### 13.3.2 导数计算

**一阶导数**：

```cpp
cv::Point2f bezier_derivative(const std::vector<cv::Point2f>& points, float t) {
    int n = points.size() - 1;
    std::vector<cv::Point2f> derivative_points;

    for (int i = 0; i < n; ++i) {
        derivative_points.push_back(n * (points[i + 1] - points[i]));
    }

    return recursive_bezier(derivative_points, t);
}
```

**曲率计算**：

```cpp
float bezier_curvature(const std::vector<cv::Point2f>& points, float t) {
    cv::Point2f first = bezier_derivative(points, t);
    cv::Point2f second = bezier_second_derivative(points, t);

    float numerator = std::abs(first.x * second.y - first.y * second.x);
    float denominator = std::pow(first.x * first.x + first.y * first.y, 1.5f);

    return numerator / denominator;
}
```

### 13.3.3 自适应细分

**基于曲率的细分**：

```cpp
void adaptive_bezier_subdivision(const std::vector<cv::Point2f>& points,
                                cv::Mat& window, float tolerance = 0.1f) {
    std::function<void(float, float, int)> subdivide =
        [&](float t_start, float t_end, int depth) {
        if (depth > 10) return;  // 防止无限递归

        float t_mid = (t_start + t_end) * 0.5f;

        cv::Point2f p_start = recursive_bezier(points, t_start);
        cv::Point2f p_mid = recursive_bezier(points, t_mid);
        cv::Point2f p_end = recursive_bezier(points, t_end);

        // 检查中点是否偏离直线太远
        cv::Point2f line_mid = (p_start + p_end) * 0.5f;
        float distance = cv::norm(p_mid - line_mid);

        if (distance > tolerance) {
            subdivide(t_start, t_mid, depth + 1);
            subdivide(t_mid, t_end, depth + 1);
        } else {
            cv::line(window, p_start, p_end, cv::Scalar(0, 255, 0), 2);
        }
    };

    subdivide(0.0f, 1.0f, 0);
}
```

---

## 样条曲线与曲面

## 14.1 样条曲线理论

### 14.1.1 样条的数学定义

#### 样条函数的严格定义

**样条函数**：
设节点序列 $t_0 < t_1 < \cdots < t_m$，$p$ 次样条函数 $S(t)$ 是满足以下条件的分段多项式：

1. 在每个区间 $[t_i, t_{i+1}]$ 上，$S(t)$ 是次数不超过 $p$ 的多项式
2. $S(t)$ 在整个定义域上具有 $C^{p-1}$ 连续性

#### B样条基函数的递推定义

**0次B样条基函数**：

基函数定义：

当 $t_i \leq t < t_{i+1}$ 时：$N_{i,0}(t) = 1$

其他情况：$N_{i,0}(t) = 0$

**高次B样条基函数（Cox-de Boor递推公式）**：
$$N_{i,p}(t) = \frac{t - t_i}{t_{i+p} - t_i} N_{i,p-1}(t) + \frac{t_{i+p+1} - t}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t)$$

**约定**：当分母为零时，对应项为零，即 $\frac{0}{0} = 0$。

#### B样条基函数的重要性质

**1. 非负性**：$N_{i,p}(t) \geq 0$ 对所有 $t$

**2. 局部支撑性**：$N_{i,p}(t) = 0$ 当 $t \notin [t_i, t_{i+p+1}]$

**3. 权重和为1**：$\sum_{i} N_{i,p}(t) = 1$ 对所有 $t$

**4. 连续性**：$N_{i,p}(t)$ 在节点处具有 $C^{p-1}$ 连续性

### 14.1.2 B样条曲线的数学理论

#### B样条曲线的定义

**数学表达式**：
$$\mathbf{C}(t) = \sum_{i=0}^{n} \mathbf{P}_i N_{i,p}(t)$$

其中：

- $\mathbf{P}_i$ 是控制点
- $N_{i,p}(t)$ 是 $p$ 次B样条基函数
- $n+1$ 是控制点的数量

#### 节点向量的作用

**节点向量**：$\mathbf{T} = \{t_0, t_1, \ldots, t_{m}\}$，其中 $m = n + p + 1$

**节点向量的分类**：

1. **均匀节点向量**：节点等间距分布
2. **非均匀节点向量**：节点间距不等
3. **开放节点向量**：首末节点重复度为 $p+1$

#### B样条曲线的性质

**1. 凸包性质**：曲线位于控制点的凸包内

**2. 局部控制性**：移动控制点 $\mathbf{P}_i$ 只影响参数区间 $[t_i, t_{i+p+1}]$ 内的曲线

**3. 变分递减性**：曲线与任意直线的交点数不超过控制多边形与该直线的交点数

**4. 仿射不变性**：仿射变换可直接作用于控制点

**代码实现**：

```cpp
class BSpline {
private:
    std::vector<Vector3f> control_points;
    std::vector<float> knot_vector;
    int degree;

public:
    float basis_function(int i, int p, float t) {
        if (p == 0) {
            return (t >= knot_vector[i] && t < knot_vector[i + 1]) ? 1.0f : 0.0f;
        }

        float left_coeff = 0.0f, right_coeff = 0.0f;

        if (knot_vector[i + p] != knot_vector[i]) {
            left_coeff = (t - knot_vector[i]) / (knot_vector[i + p] - knot_vector[i]);
        }

        if (knot_vector[i + p + 1] != knot_vector[i + 1]) {
            right_coeff = (knot_vector[i + p + 1] - t) / (knot_vector[i + p + 1] - knot_vector[i + 1]);
        }

        return left_coeff * basis_function(i, p - 1, t) +
               right_coeff * basis_function(i + 1, p - 1, t);
    }

    Vector3f evaluate(float t) {
        Vector3f point = Vector3f::Zero();

        for (int i = 0; i < control_points.size(); ++i) {
            point += control_points[i] * basis_function(i, degree, t);
        }

        return point;
    }
};
```

### 14.1.3 NURBS曲线的数学理论

#### NURBS的定义

**非均匀有理B样条（NURBS）**：
$$\mathbf{C}(t) = \frac{\sum_{i=0}^{n} w_i \mathbf{P}_i N_{i,p}(t)}{\sum_{i=0}^{n} w_i N_{i,p}(t)}$$

其中 $w_i$ 是控制点 $\mathbf{P}_i$ 的权重。

#### 有理基函数

**有理基函数定义**：
$$R_{i,p}(t) = \frac{w_i N_{i,p}(t)}{\sum_{j=0}^{n} w_j N_{j,p}(t)}$$

**NURBS曲线的简化表示**：
$$\mathbf{C}(t) = \sum_{i=0}^{n} \mathbf{P}_i R_{i,p}(t)$$

#### NURBS的几何意义

**齐次坐标表示**：
NURBS可以看作是四维空间中B样条曲线的透视投影：
$$\mathbf{C}^w(t) = \sum_{i=0}^{n} \mathbf{P}_i^w N_{i,p}(t)$$

其中 $\mathbf{P}_i^w = (w_i x_i, w_i y_i, w_i z_i, w_i)$ 是齐次控制点。

**透视投影**：
$$\mathbf{C}(t) = \frac{(\mathbf{C}^w_x(t), \mathbf{C}^w_y(t), \mathbf{C}^w_z(t))}{\mathbf{C}^w_w(t)}$$

#### NURBS的优势

**1. 精确表示圆锥曲线**：通过适当选择权重，可以精确表示圆、椭圆、抛物线、双曲线

**2. 局部权重控制**：改变权重 $w_i$ 可以局部调整曲线形状

**3. 投影不变性**：透视投影下NURBS仍为NURBS

**代码实现**：

```cpp
class NURBS : public BSpline {
private:
    std::vector<float> weights;

public:
    Vector3f evaluate(float t) override {
        Vector3f numerator = Vector3f::Zero();
        float denominator = 0.0f;

        for (int i = 0; i < control_points.size(); ++i) {
            float basis = basis_function(i, degree, t);
            numerator += weights[i] * control_points[i] * basis;
            denominator += weights[i] * basis;
        }

        return numerator / denominator;
    }
};
```

## 14.2 曲面理论

### 14.2.1 贝塞尔曲面的数学理论

#### 贝塞尔曲面的定义

**双参数贝塞尔曲面**：
$$\mathbf{S}(u,v) = \sum_{i=0}^{m} \sum_{j=0}^{n} \mathbf{P}_{ij} B_i^m(u) B_j^n(v)$$

其中：

- $\mathbf{P}_{ij}$ 是 $(m+1) \times (n+1)$ 控制点网格
- $B_i^m(u)$ 和 $B_j^n(v)$ 是伯恩斯坦基函数
- $(u,v) \in [0,1] \times [0,1]$ 是参数域

#### 曲面的几何性质

**边界曲线**：
贝塞尔曲面的四条边界都是贝塞尔曲线：

**四条边界曲线**：

左边界（$u=0$）：
$$\mathbf{S}(0,v) = \sum_{j=0}^{n} \mathbf{P}_{0j} B_j^n(v)$$

右边界（$u=1$）：
$$\mathbf{S}(1,v) = \sum_{j=0}^{n} \mathbf{P}_{mj} B_j^n(v)$$

下边界（$v=0$）：
$$\mathbf{S}(u,0) = \sum_{i=0}^{m} \mathbf{P}_{i0} B_i^m(u)$$

上边界（$v=1$）：
$$\mathbf{S}(u,1) = \sum_{i=0}^{m} \mathbf{P}_{in} B_i^m(u)$$

**角点插值**：
$$\mathbf{S}(0,0) = \mathbf{P}_{00}, \quad \mathbf{S}(1,0) = \mathbf{P}_{m0}, \quad \mathbf{S}(0,1) = \mathbf{P}_{0n}, \quad \mathbf{S}(1,1) = \mathbf{P}_{mn}$$

#### 曲面法向量计算

**偏导数**：
$$\frac{\partial \mathbf{S}}{\partial u} = \sum_{i=0}^{m} \sum_{j=0}^{n} \mathbf{P}_{ij} \frac{dB_i^m(u)}{du} B_j^n(v)$$

$$\frac{\partial \mathbf{S}}{\partial v} = \sum_{i=0}^{m} \sum_{j=0}^{n} \mathbf{P}_{ij} B_i^m(u) \frac{dB_j^n(v)}{dv}$$

**法向量**：
$$\mathbf{N}(u,v) = \frac{\partial \mathbf{S}}{\partial u} \times \frac{\partial \mathbf{S}}{\partial v}$$

**单位法向量**：
$$\hat{\mathbf{N}}(u,v) = \frac{\mathbf{N}(u,v)}{\|\mathbf{N}(u,v)\|}$$

**代码实现**：

```cpp
class BezierSurface {
private:
    std::vector<std::vector<Vector3f>> control_points;  // m+1 x n+1 网格
    int m, n;  // 度数

public:
    Vector3f evaluate(float u, float v) {
        Vector3f point = Vector3f::Zero();

        for (int i = 0; i <= m; ++i) {
            for (int j = 0; j <= n; ++j) {
                float basis_u = bernstein_polynomial(i, m, u);
                float basis_v = bernstein_polynomial(j, n, v);
                point += control_points[i][j] * basis_u * basis_v;
            }
        }

        return point;
    }

    Vector3f normal(float u, float v) {
        Vector3f du = partial_derivative_u(u, v);
        Vector3f dv = partial_derivative_v(u, v);
        return du.cross(dv).normalized();
    }

private:
    float bernstein_polynomial(int i, int n, float t) {
        return binomial_coefficient(n, i) *
               std::pow(t, i) * std::pow(1 - t, n - i);
    }
};
```

### 14.2.2 曲面细分

**均匀细分**：

```cpp
void subdivide_surface(BezierSurface& surface, int subdivisions) {
    float step = 1.0f / subdivisions;

    for (int i = 0; i <= subdivisions; ++i) {
        for (int j = 0; j <= subdivisions; ++j) {
            float u = i * step;
            float v = j * step;

            Vector3f point = surface.evaluate(u, v);
            Vector3f normal = surface.normal(u, v);

            // 添加到网格
            add_vertex(point, normal);
        }
    }

    // 生成三角形索引
    for (int i = 0; i < subdivisions; ++i) {
        for (int j = 0; j < subdivisions; ++j) {
            int idx = i * (subdivisions + 1) + j;

            // 第一个三角形
            add_triangle(idx, idx + 1, idx + subdivisions + 1);
            // 第二个三角形
            add_triangle(idx + 1, idx + subdivisions + 2, idx + subdivisions + 1);
        }
    }
}
```

---

## 网格几何处理

## 15.1 网格数据结构

### 15.1.1 半边数据结构

**核心概念**：

- 每条边分为两个半边
- 每个半边指向一个顶点
- 每个半边属于一个面

**数据结构定义**：

```cpp
struct HalfEdge {
    int vertex;           // 指向的顶点
    int face;            // 所属面
    int next;            // 同一面的下一条半边
    int prev;            // 同一面的前一条半边
    int twin;            // 对偶半边
};

struct Vertex {
    Vector3f position;
    Vector3f normal;
    int halfedge;        // 任意一条出边
};

struct Face {
    int halfedge;        // 任意一条边界半边
    Vector3f normal;
};

class HalfEdgeMesh {
private:
    std::vector<Vertex> vertices;
    std::vector<HalfEdge> halfedges;
    std::vector<Face> faces;

public:
    // 遍历顶点的所有邻接顶点
    std::vector<int> get_vertex_neighbors(int vertex_id) {
        std::vector<int> neighbors;
        int start_he = vertices[vertex_id].halfedge;
        int current_he = start_he;

        do {
            int twin_he = halfedges[current_he].twin;
            neighbors.push_back(halfedges[twin_he].vertex);
            current_he = halfedges[twin_he].next;
        } while (current_he != start_he);

        return neighbors;
    }
};
```

### 15.1.2 网格质量评估的数学理论

#### 三角形质量度量

**等周比（Isoperimetric Ratio）**：
$$Q = \frac{4\sqrt{3} \cdot A}{P^2}$$

其中：

- $A$ 是三角形面积
- $P$ 是三角形周长

**数学性质**：

- $Q = 1$ 对于等边三角形（最优）
- $Q \to 0$ 对于退化三角形
- $0 < Q \leq 1$ 对于所有有效三角形

**面积计算**：
对于顶点 $\mathbf{v}_1, \mathbf{v}_2, \mathbf{v}_3$：
$$A = \frac{1}{2}\|(\mathbf{v}_2 - \mathbf{v}_1) \times (\mathbf{v}_3 - \mathbf{v}_1)\|$$

**周长计算**：
$$P = \|\mathbf{v}_2 - \mathbf{v}_1\| + \|\mathbf{v}_3 - \mathbf{v}_2\| + \|\mathbf{v}_1 - \mathbf{v}_3\|$$

#### 其他质量度量

**长宽比（Aspect Ratio）**：
$$AR = \frac{a \cdot b \cdot c}{8(s-a)(s-b)(s-c)}$$

其中 $s = \frac{a+b+c}{2}$ 是半周长。

**最小角度**：
$$\theta_{min} = \min\{\arccos\frac{b^2+c^2-a^2}{2bc}, \arccos\frac{a^2+c^2-b^2}{2ac}, \arccos\frac{a^2+b^2-c^2}{2ab}\}$$

#### 工程实现

```cpp
class TriangleQuality {
public:
    static float isoperimetric_ratio(const Vector3f& v1, const Vector3f& v2, const Vector3f& v3) {
        Vector3f e1 = v2 - v1;
        Vector3f e2 = v3 - v2;
        Vector3f e3 = v1 - v3;

        float a = e1.norm();
        float b = e2.norm();
        float c = e3.norm();

        float area = 0.5f * e1.cross(-e3).norm();  // 使用叉积计算面积
        float perimeter = a + b + c;

        if (perimeter < 1e-8f) return 0.0f;  // 避免除零

        return 4.0f * std::sqrt(3.0f) * area / (perimeter * perimeter);
    }

    static float min_angle(const Vector3f& v1, const Vector3f& v2, const Vector3f& v3) {
        Vector3f e1 = (v2 - v1).normalized();
        Vector3f e2 = (v3 - v2).normalized();
        Vector3f e3 = (v1 - v3).normalized();

        float angle1 = std::acos(std::clamp(e1.dot(-e3), -1.0f, 1.0f));
        float angle2 = std::acos(std::clamp((-e1).dot(e2), -1.0f, 1.0f));
        float angle3 = std::acos(std::clamp((-e2).dot(e3), -1.0f, 1.0f));

        return std::min({angle1, angle2, angle3});
    }
};
```

**网格统计信息**：

```cpp
struct MeshStatistics {
    float min_edge_length;
    float max_edge_length;
    float avg_edge_length;
    float min_triangle_quality;
    float avg_triangle_quality;
    int degenerate_triangles;
};

MeshStatistics analyze_mesh(const HalfEdgeMesh& mesh) {
    MeshStatistics stats;
    // 实现统计计算...
    return stats;
}
```

## 15.2 网格处理算法

### 15.2.1 网格简化的数学理论

#### 二次误差度量（QEM）

**基本思想**：
每个顶点关联一个二次误差矩阵，用于度量顶点到其邻接平面的距离平方和。

**平面方程**：
对于三角形面 $f$，其平面方程为：
$$\pi_f: ax + by + cz + d = 0$$

其中 $\mathbf{n} = (a, b, c)^T$ 是单位法向量，$d$ 是到原点的距离。

**二次误差矩阵**：
对于平面 $\pi = (a, b, c, d)^T$，其对应的二次误差矩阵为：

二次误差矩阵 $\mathbf{Q}_\pi = \pi \pi^T$ 的结构：

- 第1行：$(a^2, ab, ac, ad)$
- 第2行：$(ab, b^2, bc, bd)$
- 第3行：$(ac, bc, c^2, cd)$
- 第4行：$(ad, bd, cd, d^2)$

$$\mathbf{Q}_\pi = \text{quadric error matrix}$$

**顶点的二次误差**：
顶点 $v$ 的二次误差矩阵是其所有邻接面的二次误差矩阵之和：
$$\mathbf{Q}_v = \sum_{f \in \text{faces}(v)} \mathbf{Q}_{\pi_f}$$

**点到平面距离的二次形式**：
点 $\mathbf{p} = (x, y, z, 1)^T$ 的二次误差为：
$$\text{error}(\mathbf{p}) = \mathbf{p}^T \mathbf{Q}_v \mathbf{p}$$

#### 边折叠的最优位置

**问题描述**：
当边 $(v_1, v_2)$ 折叠为新顶点 $\bar{v}$ 时，新顶点的二次误差矩阵为：
$$\mathbf{Q}_{\bar{v}} = \mathbf{Q}_{v_1} + \mathbf{Q}_{v_2}$$

**最优位置求解**：
最小化二次误差 $\mathbf{p}^T \mathbf{Q}_{\bar{v}} \mathbf{p}$，其中 $\mathbf{p} = (x, y, z, 1)^T$。

对 $x, y, z$ 求偏导并令其为零：
$$\frac{\partial}{\partial x}(\mathbf{p}^T \mathbf{Q}_{\bar{v}} \mathbf{p}) = 0$$

得到线性方程组：

系数矩阵为左上角 $3 \times 3$ 子矩阵，右端项为负的第4列前三个元素：

$$\mathbf{Q}_{3 \times 3} \cdot (x, y, z)^T = -(q_{14}, q_{24}, q_{34})^T$$

#### 工程实现

```cpp
class QEMSimplification {
private:
    struct QuadricMatrix {
        float q[10];  // 对称矩阵的上三角部分

        QuadricMatrix() { std::fill(q, q + 10, 0.0f); }

        // 从平面构造二次误差矩阵
        QuadricMatrix(const Vector4f& plane) {
            float a = plane.x(), b = plane.y(), c = plane.z(), d = plane.w();
            q[0] = a*a; q[1] = a*b; q[2] = a*c; q[3] = a*d;
                        q[4] = b*b; q[5] = b*c; q[6] = b*d;
                                    q[7] = c*c; q[8] = c*d;
                                                q[9] = d*d;
        }

        QuadricMatrix operator+(const QuadricMatrix& other) const {
            QuadricMatrix result;
            for (int i = 0; i < 10; ++i) {
                result.q[i] = q[i] + other.q[i];
            }
            return result;
        }

        float evaluate(const Vector3f& point) const {
            Vector4f p(point.x(), point.y(), point.z(), 1.0f);
            return p.x()*p.x()*q[0] + 2*p.x()*p.y()*q[1] + 2*p.x()*p.z()*q[2] + 2*p.x()*p.w()*q[3] +
                   p.y()*p.y()*q[4] + 2*p.y()*p.z()*q[5] + 2*p.y()*p.w()*q[6] +
                   p.z()*p.z()*q[7] + 2*p.z()*p.w()*q[8] +
                   p.w()*p.w()*q[9];
        }
    };

    std::vector<QuadricMatrix> vertex_quadrics;

public:
    float calculate_collapse_cost(const HalfEdgeMesh& mesh, int edge_id, Vector3f& optimal_pos) {
        auto [v1, v2] = mesh.get_edge_vertices(edge_id);
        QuadricMatrix combined = vertex_quadrics[v1] + vertex_quadrics[v2];

        // 尝试三个候选位置：v1, v2, 最优解
        Vector3f pos1 = mesh.get_vertex_position(v1);
        Vector3f pos2 = mesh.get_vertex_position(v2);
        Vector3f pos_optimal = solve_optimal_position(combined);

        float cost1 = combined.evaluate(pos1);
        float cost2 = combined.evaluate(pos2);
        float cost_optimal = combined.evaluate(pos_optimal);

        if (cost_optimal <= cost1 && cost_optimal <= cost2) {
            optimal_pos = pos_optimal;
            return cost_optimal;
        } else if (cost1 <= cost2) {
            optimal_pos = pos1;
            return cost1;
        } else {
            optimal_pos = pos2;
            return cost2;
        }
    }
};

### 15.2.2 网格细分的数学理论

#### Loop细分算法

**基本思想**：
Loop细分是一种逼近细分方案，通过在每个三角形中插入新顶点并重新连接来细化网格。

#### 顶点位置更新规则

**原有顶点的新位置**：
对于度数为 $n$ 的顶点 $v$，其新位置为：
$$\mathbf{v}_{new} = (1 - n\beta)\mathbf{v} + \beta\sum_{i=1}^{n}\mathbf{v}_i$$

其中 $\mathbf{v}_i$ 是 $v$ 的邻接顶点，权重 $\beta$ 定义为：

权重计算：

当 $n = 3$ 时：$\beta = \frac{3}{16}$

当 $n > 3$ 时：$\beta = \frac{3}{8n}$

**新顶点（边中点）的位置**：
对于边 $e = (v_1, v_2)$，设其两个邻接三角形的第三个顶点分别为 $v_3$ 和 $v_4$，则新顶点位置为：
$$\mathbf{v}_{edge} = \frac{3}{8}(\mathbf{v}_1 + \mathbf{v}_2) + \frac{1}{8}(\mathbf{v}_3 + \mathbf{v}_4)$$

#### 数学性质

**收敛性**：
Loop细分在 $C^2$ 连续性下收敛到光滑极限曲面，除了特殊点（度数不为6的顶点）。

**特征值分析**：
细分矩阵的特征值决定了收敛性质：
- 主特征值 $\lambda_0 = 1$
- 次特征值 $\lambda_1 = \lambda_2 = \frac{1}{2} + \frac{1}{4}\cos\frac{2\pi}{n}$

#### 工程实现

```cpp
class LoopSubdivision {
public:
    static void subdivide(HalfEdgeMesh& mesh) {
        std::vector<Vector3f> new_vertex_positions;
        std::vector<Vector3f> edge_midpoints;

        // 1. 计算原有顶点的新位置
        for (int i = 0; i < mesh.vertex_count(); ++i) {
            new_vertex_positions.push_back(compute_vertex_position(mesh, i));
        }

        // 2. 计算边中点位置
        for (int i = 0; i < mesh.edge_count(); ++i) {
            edge_midpoints.push_back(compute_edge_midpoint(mesh, i));
        }

        // 3. 重建网格拓扑
        rebuild_subdivided_mesh(mesh, new_vertex_positions, edge_midpoints);
    }

private:
    static Vector3f compute_vertex_position(const HalfEdgeMesh& mesh, int vertex_id) {
        std::vector<int> neighbors = mesh.get_vertex_neighbors(vertex_id);
        int n = neighbors.size();

        float beta = (n == 3) ? 3.0f/16.0f : 3.0f/(8.0f*n);

        Vector3f original_pos = mesh.get_vertex_position(vertex_id);
        Vector3f neighbor_sum = Vector3f::Zero();

        for (int neighbor : neighbors) {
            neighbor_sum += mesh.get_vertex_position(neighbor);
        }

        return (1.0f - n*beta) * original_pos + beta * neighbor_sum;
    }

    static Vector3f compute_edge_midpoint(const HalfEdgeMesh& mesh, int edge_id) {
        auto [v1, v2] = mesh.get_edge_vertices(edge_id);
        auto [v3, v4] = mesh.get_edge_opposite_vertices(edge_id);

        Vector3f pos1 = mesh.get_vertex_position(v1);
        Vector3f pos2 = mesh.get_vertex_position(v2);
        Vector3f pos3 = mesh.get_vertex_position(v3);
        Vector3f pos4 = mesh.get_vertex_position(v4);

        return 0.375f * (pos1 + pos2) + 0.125f * (pos3 + pos4);
    }
};
```

### 15.2.3 网格平滑

**拉普拉斯平滑**：

```cpp
void laplacian_smoothing(HalfEdgeMesh& mesh, float lambda = 0.5f, int iterations = 10) {
    for (int iter = 0; iter < iterations; ++iter) {
        std::vector<Vector3f> new_positions(mesh.vertex_count());

        for (int i = 0; i < mesh.vertex_count(); ++i) {
            if (mesh.is_boundary_vertex(i)) {
                new_positions[i] = mesh.get_vertex_position(i);
                continue;
            }

            std::vector<int> neighbors = mesh.get_vertex_neighbors(i);
            Vector3f laplacian = Vector3f::Zero();

            for (int neighbor : neighbors) {
                laplacian += mesh.get_vertex_position(neighbor);
            }
            laplacian /= neighbors.size();
            laplacian -= mesh.get_vertex_position(i);

            new_positions[i] = mesh.get_vertex_position(i) + lambda * laplacian;
        }

        mesh.update_vertex_positions(new_positions);
    }
}
```

## 光线追踪基础理论

## 16.1 光线追踪的物理与数学基础

### 16.1.1 几何光学的数学框架

#### 几何光学的基本假设

**1. 直线传播假设**：
在均匀介质中，光沿直线传播。这是光线追踪算法的核心假设。

**2. 独立性假设**：
不同光线之间不发生相互作用，可以独立计算每条光线的贡献。

**3. 几何尺度假设**：
光的波长 $\lambda$ 远小于场景中物体的特征尺度 $L$，即 $\lambda \ll L$。

#### 光线的参数化表示

**数学定义**：
三维空间中的光线可以用参数方程表示：
$$\mathbf{r}(t) = \mathbf{o} + t\mathbf{d}$$

其中：

- $\mathbf{o} \in \mathbb{R}^3$：光线起点（origin）
- $\mathbf{d} \in \mathbb{R}^3$：光线方向向量（direction），通常为单位向量
- $t \in [t_{min}, t_{max}]$：参数范围

**工程实现**：

```cpp
struct Ray {
    Vector3f origin;        // 起点 o
    Vector3f direction;     // 方向 d（单位向量）
    float t_min = 1e-4f;    // 最小参数（避免自相交）
    float t_max = 1e30f;    // 最大参数

    // 计算光线上的点
    Vector3f at(float t) const {
        return origin + t * direction;
    }

    // 检查参数是否在有效范围内
    bool is_valid_t(float t) const {
        return t >= t_min && t <= t_max;
    }
};
```

### 16.1.2 渲染方程的递归形式

#### 渲染方程的数学推导

**积分形式的渲染方程**：
$$L_o(\mathbf{p}, \omega_o) = L_e(\mathbf{p}, \omega_o) + \int_{\Omega} f_r(\mathbf{p}, \omega_i, \omega_o) L_i(\mathbf{p}, \omega_i) \cos\theta_i \, d\omega_i$$

**递归形式的推导**：
入射辐射度 $L_i(\mathbf{p}, \omega_i)$ 实际上是从方向 $\omega_i$ 射向点 $\mathbf{p}$ 的光线在其起始点的出射辐射度。

设光线与场景的下一个交点为 $\mathbf{p}'$，则：
$$L_i(\mathbf{p}, \omega_i) = L_o(\mathbf{p}', -\omega_i)$$

代入渲染方程得到递归形式：
$$L_o(\mathbf{p}, \omega_o) = L_e(\mathbf{p}, \omega_o) + \int_{\Omega} f_r(\mathbf{p}, \omega_i, \omega_o) L_o(\mathbf{p}', -\omega_i) \cos\theta_i \, d\omega_i$$

#### 光线追踪的数学本质

**积分方程的求解**：
渲染方程是一个Fredholm积分方程，光线追踪通过递归求解这个积分方程。

**Neumann级数展开**：
渲染方程可以展开为无穷级数：
$$L = L_e + TL_e + T^2L_e + T^3L_e + \cdots$$

其中 $T$ 是传输算子：
$$[TL](\mathbf{p}, \omega_o) = \int_{\Omega} f_r(\mathbf{p}, \omega_i, \omega_o) L(\mathbf{p}', -\omega_i) \cos\theta_i \, d\omega_i$$

**物理解释**：

- $L_e$：直接光照（0次反射）
- $TL_e$：一次反射光照
- $T^2L_e$：二次反射光照
- $\vdots$

#### 光线追踪的收敛性

**收敛条件**：
当传输算子 $T$ 的谱半径小于1时，Neumann级数收敛：
$$\rho(T) < 1$$

这在物理上对应于能量守恒条件：反射的总能量小于入射能量。

## 16.2 Whitted光线追踪算法

### 16.2.1 Whitted算法的数学模型

#### 算法的理论基础

**Whitted模型的简化假设**：

1. **完美镜面反射**：只考虑镜面方向的反射
2. **完美透射**：只考虑折射方向的透射
3. **点光源**：光源被建模为点光源
4. **递归终止**：通过深度限制终止递归

#### 反射定律的数学推导

**反射向量计算**：
给定入射向量 $\mathbf{d}$ 和表面法向量 $\mathbf{n}$，反射向量 $\mathbf{r}$ 为：
$$\mathbf{r} = \mathbf{d} - 2(\mathbf{d} \cdot \mathbf{n})\mathbf{n}$$

**推导过程**：
设入射向量为 $\mathbf{d}$，分解为法向分量和切向分量：

- 法向分量：$\mathbf{d}_{\parallel} = (\mathbf{d} \cdot \mathbf{n})\mathbf{n}$
- 切向分量：$\mathbf{d}_{\perp} = \mathbf{d} - \mathbf{d}_{\parallel}$

反射时切向分量不变，法向分量反向：
$$\mathbf{r} = \mathbf{d}_{\perp} - \mathbf{d}_{\parallel} = \mathbf{d} - 2\mathbf{d}_{\parallel} = \mathbf{d} - 2(\mathbf{d} \cdot \mathbf{n})\mathbf{n}$$

#### Snell定律与折射

**Snell定律**：
$$n_1 \sin\theta_1 = n_2 \sin\theta_2$$

其中 $n_1, n_2$ 是两种介质的折射率，$\theta_1, \theta_2$ 是入射角和折射角。

**折射向量的向量形式**：
$$\mathbf{t} = \frac{n_1}{n_2}\mathbf{d} + \left(\frac{n_1}{n_2}\cos\theta_1 - \cos\theta_2\right)\mathbf{n}$$

其中：
$$\cos\theta_1 = -\mathbf{d} \cdot \mathbf{n}$$
$$\cos\theta_2 = \sqrt{1 - \left(\frac{n_1}{n_2}\right)^2(1 - \cos^2\theta_1)}$$

**全内反射条件**：
当 $\left(\frac{n_1}{n_2}\right)^2(1 - \cos^2\theta_1) > 1$ 时发生全内反射。

#### Whitted算法的完整实现

```cpp
Vector3f whitted_ray_tracing(const Ray& ray, const Scene& scene, int depth) {
    // 递归终止条件
    if (depth <= 0) return Vector3f::Zero();

    // 光线与场景求交
    Intersection hit = scene.intersect(ray);
    if (!hit.happened) return scene.background_color;

    // 初始化颜色为自发光
    Vector3f color = hit.material->emission;

    // 直接光照计算
    for (const auto& light : scene.lights) {
        Vector3f light_dir = light->sample_direction(hit.position);

        // 阴影测试
        Ray shadow_ray(hit.position + EPSILON * hit.normal, light_dir);
        if (!scene.is_occluded(shadow_ray, light->distance(hit.position))) {
            // 计算直接光照贡献
            Vector3f light_color = light->intensity / light->distance_squared(hit.position);
            Vector3f brdf_value = hit.material->evaluate_brdf(-ray.direction, light_dir, hit.normal);
            float cos_theta = std::max(0.0f, hit.normal.dot(light_dir));

            color += brdf_value * light_color * cos_theta;
        }
    }

    // 镜面反射
    if (hit.material->is_reflective() && depth > 0) {
        Vector3f reflect_dir = reflect(ray.direction, hit.normal);
        Ray reflect_ray(hit.position + EPSILON * hit.normal, reflect_dir);

        Vector3f reflected_color = whitted_ray_tracing(reflect_ray, scene, depth - 1);
        color += hit.material->reflectance * reflected_color;
    }

    // 折射/透射
    if (hit.material->is_transparent() && depth > 0) {
        float eta = hit.front_face ? (1.0f / hit.material->ior) : hit.material->ior;
        Vector3f refract_dir = refract(ray.direction, hit.normal, eta);

        if (refract_dir.squaredNorm() > 0) {  // 检查是否发生全内反射
            Vector3f offset = hit.front_face ? (-EPSILON * hit.normal) : (EPSILON * hit.normal);
            Ray refract_ray(hit.position + offset, refract_dir);

            Vector3f refracted_color = whitted_ray_tracing(refract_ray, scene, depth - 1);
            color += hit.material->transmittance * refracted_color;
        }
    }

    return color;
}

// 反射向量计算
Vector3f reflect(const Vector3f& incident, const Vector3f& normal) {
    return incident - 2.0f * incident.dot(normal) * normal;
}

// 折射向量计算
Vector3f refract(const Vector3f& incident, const Vector3f& normal, float eta) {
    float cos_i = -incident.dot(normal);
    float sin_t2 = eta * eta * (1.0f - cos_i * cos_i);

    if (sin_t2 >= 1.0f) {
        return Vector3f::Zero();  // 全内反射
    }

    float cos_t = std::sqrt(1.0f - sin_t2);
    return eta * incident + (eta * cos_i - cos_t) * normal;
}
```

```

### 16.2.2 项目中的实现框架

**基于GAMES101 Assignment5-6的结构**：
```cpp
Vector3f Scene::castRay(const Ray &ray, int depth) const {
    if (depth > this->maxDepth) {
        return Vector3f(0.0, 0.0, 0.0);
    }

    Intersection intersection = Scene::intersect(ray);
    if (!intersection.happened) {
        return this->backgroundColor;
    }

    Material *m = intersection.m;
    Object *hitObject = intersection.obj;
    Vector3f hitColor = this->backgroundColor;
    Vector3f hitPoint = intersection.coords;
    Vector3f N = intersection.normal;
    Vector2f uv = intersection.uv;

    switch (m->getType()) {
        case REFLECTION_AND_REFRACTION: {
            Vector3f reflectionDirection = reflect(ray.direction, N);
            Vector3f refractionDirection = refract(ray.direction, N, m->ior);

            Vector3f reflectionRayOrig = (dotProduct(reflectionDirection, N) < 0) ?
                hitPoint - N * EPSILON : hitPoint + N * EPSILON;
            Vector3f refractionRayOrig = (dotProduct(refractionDirection, N) < 0) ?
                hitPoint - N * EPSILON : hitPoint + N * EPSILON;

            Vector3f reflectionColor = castRay(Ray(reflectionRayOrig, reflectionDirection), depth + 1);
            Vector3f refractionColor = castRay(Ray(refractionRayOrig, refractionDirection), depth + 1);

            float kr = fresnel(ray.direction, N, m->ior);
            hitColor = reflectionColor * kr + refractionColor * (1 - kr);
            break;
        }
        case REFLECTION: {
            float kr = fresnel(ray.direction, N, m->ior);
            Vector3f reflectionDirection = reflect(ray.direction, N);
            Vector3f reflectionRayOrig = (dotProduct(reflectionDirection, N) < 0) ?
                hitPoint - N * EPSILON : hitPoint + N * EPSILON;
            hitColor = castRay(Ray(reflectionRayOrig, reflectionDirection), depth + 1) * kr;
            break;
        }
        default: {
            // 漫反射材质的直接光照计算
            Vector3f lightAmt = 0, specularColor = 0;
            Vector3f shadowPointOrig = (dotProduct(ray.direction, N) < 0) ?
                hitPoint + N * EPSILON : hitPoint - N * EPSILON;

            for (auto& light : this->get_lights()) {
                Vector3f lightDir = light->position - hitPoint;
                float lightDistance2 = dotProduct(lightDir, lightDir);
                lightDir = normalize(lightDir);
                float LdotN = std::max(0.f, dotProduct(lightDir, N));

                // 阴影测试
                auto shadow_res = trace(Ray(shadowPointOrig, lightDir), this->get_objects());
                bool inShadow = shadow_res && (shadow_res->t * shadow_res->t < lightDistance2);

                lightAmt += inShadow ? 0 : light->intensity * LdotN;
                Vector3f reflectionDirection = reflect(-lightDir, N);
                specularColor += powf(std::max(0.f, -dotProduct(reflectionDirection, ray.direction)),
                    m->specularExponent) * light->intensity;
            }

            hitColor = lightAmt * m->Kd * m->diffuseColor + specularColor * m->Ks;
            break;
        }
    }

    return hitColor;
}
```

## 16.3 光线-物体相交算法

### 16.3.1 光线-球体相交

**数学推导**：
球体方程：$||p - c||^2 = r^2$
光线方程：$p = o + td$

代入得到：$||o + td - c||^2 = r^2$

展开：$(o - c + td) \cdot (o - c + td) = r^2$

整理得到二次方程：$at^2 + bt + c = 0$

其中：

- $a = d \cdot d = 1$（假设d是单位向量）
- $b = 2d \cdot (o - c)$
- $c = (o - c) \cdot (o - c) - r^2$

**代码实现**：

```cpp
bool intersect_sphere(const Ray& ray, const Vector3f& center, float radius,
                     float& t_near, float& t_far) {
    Vector3f oc = ray.origin - center;
    float a = ray.direction.dot(ray.direction);
    float b = 2.0f * oc.dot(ray.direction);
    float c = oc.dot(oc) - radius * radius;

    float discriminant = b * b - 4 * a * c;
    if (discriminant < 0) return false;

    float sqrt_discriminant = std::sqrt(discriminant);
    t_near = (-b - sqrt_discriminant) / (2.0f * a);
    t_far = (-b + sqrt_discriminant) / (2.0f * a);

    if (t_near > t_far) std::swap(t_near, t_far);

    return t_near >= ray.t_min && t_near <= ray.t_max;
}
```

### 16.3.2 光线-三角形相交

**Möller-Trumbore算法**：

```cpp
bool intersect_triangle(const Ray& ray, const Vector3f& v0, const Vector3f& v1, const Vector3f& v2,
                       float& t, float& u, float& v) {
    Vector3f edge1 = v1 - v0;
    Vector3f edge2 = v2 - v0;
    Vector3f h = ray.direction.cross(edge2);
    float a = edge1.dot(h);

    if (a > -EPSILON && a < EPSILON) return false;  // 光线平行于三角形

    float f = 1.0f / a;
    Vector3f s = ray.origin - v0;
    u = f * s.dot(h);

    if (u < 0.0f || u > 1.0f) return false;

    Vector3f q = s.cross(edge1);
    v = f * ray.direction.dot(q);

    if (v < 0.0f || u + v > 1.0f) return false;

    t = f * edge2.dot(q);

    return t > EPSILON && t >= ray.t_min && t <= ray.t_max;
}
```

### 16.3.3 光线-平面相交

**数学推导**：
平面方程：$\mathbf{n} \cdot (\mathbf{p} - \mathbf{p}_0) = 0$
光线方程：$\mathbf{p} = \mathbf{o} + t\mathbf{d}$

代入：$\mathbf{n} \cdot (\mathbf{o} + t\mathbf{d} - \mathbf{p}_0) = 0$
解得：$t = \frac{\mathbf{n} \cdot (\mathbf{p}_0 - \mathbf{o})}{\mathbf{n} \cdot \mathbf{d}}$

**代码实现**：

```cpp
bool intersect_plane(const Ray& ray, const Vector3f& point, const Vector3f& normal,
                    float& t) {
    float denom = normal.dot(ray.direction);
    if (std::abs(denom) < EPSILON) return false;  // 光线平行于平面

    t = normal.dot(point - ray.origin) / denom;
    return t >= ray.t_min && t <= ray.t_max;
}
```

---

## 光线-几何体相交算法

## 17.1 包围盒相交算法

### 17.1.1 轴对齐包围盒（AABB）的数学理论

#### AABB的数学定义

**轴对齐包围盒**：
AABB是一个与坐标轴平行的长方体，可以用两个对角顶点定义：
$$\text{AABB} = \{(x,y,z) : x_{min} \leq x \leq x_{max}, y_{min} \leq y \leq y_{max}, z_{min} \leq z \leq z_{max}\}$$

#### 光线-AABB相交的数学推导

**光线参数方程**：
$$\mathbf{r}(t) = \mathbf{o} + t\mathbf{d}$$

**平面相交计算**：
对于每个坐标轴 $i$，光线与两个平面 $x_i = x_{min}$ 和 $x_i = x_{max}$ 的相交参数为：
$$t_{1i} = \frac{x_{min} - o_i}{d_i}, \quad t_{2i} = \frac{x_{max} - o_i}{d_i}$$

**近远平面确定**：
$$t_{near,i} = \min(t_{1i}, t_{2i}), \quad t_{far,i} = \max(t_{1i}, t_{2i})$$

**相交条件**：
光线与AABB相交当且仅当：
$$t_{enter} = \max(t_{near,x}, t_{near,y}, t_{near,z}) \leq t_{exit} = \min(t_{far,x}, t_{far,y}, t_{far,z})$$

#### 数值稳定性考虑

**除零处理**：
当 $d_i = 0$ 时，光线平行于第 $i$ 轴：

- 如果 $o_i < x_{min}$ 或 $o_i > x_{max}$，则无相交
- 否则，$t_{near,i} = -\infty$，$t_{far,i} = +\infty$

#### 优化的AABB相交实现

```cpp
struct AABB {
    Vector3f min_point, max_point;

    AABB() : min_point(Vector3f::Constant(INFINITY)),
             max_point(Vector3f::Constant(-INFINITY)) {}

    AABB(const Vector3f& min_p, const Vector3f& max_p)
        : min_point(min_p), max_point(max_p) {}

    // 计算表面积（用于SAH）
    float surface_area() const {
        Vector3f extent = max_point - min_point;
        return 2.0f * (extent.x() * extent.y() +
                      extent.y() * extent.z() +
                      extent.z() * extent.x());
    }

    // 计算体积
    float volume() const {
        Vector3f extent = max_point - min_point;
        return extent.x() * extent.y() * extent.z();
    }

    void expand(const Vector3f& point) {
        min_point = min_point.cwiseMin(point);
        max_point = max_point.cwiseMax(point);
    }
};

bool intersect_aabb_robust(const Ray& ray, const AABB& box, float& t_min, float& t_max) {
    t_min = ray.t_min;
    t_max = ray.t_max;

    for (int i = 0; i < 3; ++i) {
        if (std::abs(ray.direction[i]) < 1e-8f) {
            // 光线平行于第i轴
            if (ray.origin[i] < box.min_point[i] || ray.origin[i] > box.max_point[i]) {
                return false;
            }
        } else {
            float inv_dir = 1.0f / ray.direction[i];
            float t1 = (box.min_point[i] - ray.origin[i]) * inv_dir;
            float t2 = (box.max_point[i] - ray.origin[i]) * inv_dir;

            if (t1 > t2) std::swap(t1, t2);

            t_min = std::max(t_min, t1);
            t_max = std::min(t_max, t2);

            if (t_min > t_max) return false;
        }
    }

    return true;
}
```

### 17.1.2 有向包围盒（OBB）

**OBB定义**：

```cpp
struct OBB {
    Vector3f center;
    Vector3f axes[3];      // 三个正交轴
    Vector3f half_extents; // 沿各轴的半长度

    AABB to_aabb() const {
        Vector3f extent = Vector3f::Zero();
        for (int i = 0; i < 3; ++i) {
            extent += axes[i].cwiseAbs() * half_extents[i];
        }
        return AABB(center - extent, center + extent);
    }
};
```

## 17.2 复杂几何体相交

### 17.2.1 光线-网格相交

**网格相交算法**：

```cpp
class TriangleMesh {
private:
    std::vector<Vector3f> vertices;
    std::vector<Vector3i> triangles;
    AABB bounding_box;

public:
    bool intersect(const Ray& ray, Intersection& hit) {
        if (!intersect_aabb(ray, bounding_box)) return false;

        bool hit_found = false;
        float closest_t = ray.t_max;

        for (const auto& triangle : triangles) {
            Vector3f v0 = vertices[triangle[0]];
            Vector3f v1 = vertices[triangle[1]];
            Vector3f v2 = vertices[triangle[2]];

            float t, u, v;
            if (intersect_triangle(ray, v0, v1, v2, t, u, v) && t < closest_t) {
                closest_t = t;
                hit.t = t;
                hit.position = ray.at(t);
                hit.normal = (v1 - v0).cross(v2 - v0).normalized();
                hit.uv = Vector2f(u, v);
                hit_found = true;
            }
        }

        return hit_found;
    }
};
```

### 17.2.2 光线-隐式曲面相交

**隐式曲面定义**：f(x, y, z) = 0

**牛顿迭代法求交**：

```cpp
bool intersect_implicit_surface(const Ray& ray,
                               std::function<float(Vector3f)> f,
                               std::function<Vector3f(Vector3f)> gradient,
                               float& t) {
    float t_current = ray.t_min;
    const int max_iterations = 100;
    const float tolerance = 1e-6f;

    for (int i = 0; i < max_iterations; ++i) {
        Vector3f point = ray.at(t_current);
        float value = f(point);

        if (std::abs(value) < tolerance) {
            t = t_current;
            return true;
        }

        Vector3f grad = gradient(point);
        float denominator = grad.dot(ray.direction);

        if (std::abs(denominator) < tolerance) break;

        t_current -= value / denominator;

        if (t_current < ray.t_min || t_current > ray.t_max) break;
    }

    return false;
}
```

---

## 空间加速数据结构

## 18.1 BVH（层次包围盒）

### 18.1.1 BVH的数学理论基础

#### 层次包围盒的数学原理

**核心思想**：
BVH（Bounding Volume Hierarchy）通过递归地将几何对象分组并用包围盒包围，构建一个二叉树结构，从而实现对光线-场景相交测试的加速。

**数学基础**：
设场景中有 $n$ 个几何对象 $\{O_1, O_2, \ldots, O_n\}$，BVH将其组织成一个二叉树 $T$，满足：

1. **包围性质**：每个内部节点的包围盒包含其所有子节点的包围盒
2. **分离性质**：叶子节点包含的几何对象在空间上相对集中
3. **平衡性质**：树的深度尽可能小，理想情况下为 $O(\log n)$

#### 相交测试的复杂度分析

**朴素方法**：
对于每条光线，需要与所有 $n$ 个对象进行相交测试，时间复杂度为 $O(n)$。

**BVH加速**：
利用包围盒的层次结构，平均时间复杂度降低到 $O(\log n)$：

- 如果光线与节点的包围盒不相交，则可以跳过整个子树
- 只有当光线与包围盒相交时，才需要递归测试子节点

**BVH节点定义**：

```cpp
struct BVHBuildNode {
    AABB bounds;
    BVHBuildNode* left;
    BVHBuildNode* right;
    Object* object;        // 叶子节点存储对象
    int split_axis;        // 分割轴
    int first_prim_offset; // 第一个图元的偏移
    int n_primitives;      // 图元数量

    void init_leaf(int first, int n, const AABB& b) {
        first_prim_offset = first;
        n_primitives = n;
        bounds = b;
        left = right = nullptr;
    }

    void init_interior(int axis, BVHBuildNode* c0, BVHBuildNode* c1) {
        left = c0;
        right = c1;
        bounds = AABB();
        bounds.expand(c0->bounds);
        bounds.expand(c1->bounds);
        split_axis = axis;
        n_primitives = 0;
    }
};
```

### 18.1.2 BVH构建算法的数学理论

#### 分割策略的数学分析

**1. 中点分割（Midpoint Split）**：
选择最长轴的中点进行分割：
$$x_{split} = \frac{x_{min} + x_{max}}{2}$$

**优点**：简单快速，保证树的平衡性
**缺点**：可能产生空的子树或不均匀的分布

**2. 表面积启发式（SAH - Surface Area Heuristic）**：
基于期望相交测试次数的最优化分割策略。

#### SAH的数学推导

**期望相交测试次数**：
对于一个包围盒 $B$，其子节点 $B_L$ 和 $B_R$，光线与该节点相交的期望测试次数为：
$$C(B) = C_{traversal} + P(B_L|B) \cdot C(B_L) + P(B_R|B) \cdot C(B_R)$$

其中：

- $C_{traversal}$ 是遍历节点的固定开销
- $P(B_L|B)$ 是光线与 $B$ 相交时也与 $B_L$ 相交的条件概率
- $C(B_L)$ 是左子树的期望测试次数

**几何概率假设**：
假设光线方向均匀分布，则：
$$P(B_L|B) = \frac{SA(B_L)}{SA(B)}$$

其中 $SA(B)$ 是包围盒 $B$ 的表面积。

**SAH代价函数**：
$$SAH(split) = C_{traversal} + \frac{SA(B_L)}{SA(B)} \cdot N_L \cdot C_{intersect} + \frac{SA(B_R)}{SA(B)} \cdot N_R \cdot C_{intersect}$$

其中 $N_L$ 和 $N_R$ 分别是左右子树的图元数量。

#### 基于GAMES101项目的实现

```cpp
BVHBuildNode* BVHAccel::recursiveBuild(std::vector<Object*> objects) {
    BVHBuildNode* node = new BVHBuildNode();

    // 计算所有对象的包围盒
    AABB bounds;
    for (int i = 0; i < objects.size(); ++i) {
        bounds.expand(objects[i]->getBounds());
    }

    if (objects.size() == 1) {
        // 创建叶子节点
        node->bounds = objects[0]->getBounds();
        node->object = objects[0];
        node->left = nullptr;
        node->right = nullptr;
        return node;
    } else if (objects.size() == 2) {
        node->left = recursiveBuild(std::vector{objects[0]});
        node->right = recursiveBuild(std::vector{objects[1]});
        node->bounds = AABB();
        node->bounds.expand(node->left->bounds);
        node->bounds.expand(node->right->bounds);
        return node;
    } else {
        // 选择分割轴（最长轴）
        AABB centroid_bounds;
        for (int i = 0; i < objects.size(); ++i) {
            centroid_bounds.expand(objects[i]->getBounds().centroid());
        }

        int dim = centroid_bounds.max_extent();

        switch (splitMethod) {
            case SplitMethod::NAIVE: {
                // 中点分割
                std::sort(objects.begin(), objects.end(), [dim](const auto& a, const auto& b) {
                    return a->getBounds().centroid()[dim] < b->getBounds().centroid()[dim];
                });

                auto beginning = objects.begin();
                auto middling = objects.begin() + (objects.size() / 2);
                auto ending = objects.end();

                auto leftshapes = std::vector<Object*>(beginning, middling);
                auto rightshapes = std::vector<Object*>(middling, ending);

                assert(objects.size() == (leftshapes.size() + rightshapes.size()));

                node->left = recursiveBuild(leftshapes);
                node->right = recursiveBuild(rightshapes);
                break;
            }
            case SplitMethod::SAH: {
                // SAH分割（表面积启发式）
                // 实现SAH算法...
                break;
            }
        }

        node->bounds = AABB();
        node->bounds.expand(node->left->bounds);
        node->bounds.expand(node->right->bounds);
    }

    return node;
}
```

### 18.1.3 BVH遍历算法

```cpp
Intersection BVHAccel::getIntersection(BVHBuildNode* node, const Ray& ray) const {
    Intersection isect;
    if (!node) return isect;

    // 检查光线是否与节点包围盒相交
    Vector3f inv_dir = Vector3f(1.0f / ray.direction.x(),
                               1.0f / ray.direction.y(),
                               1.0f / ray.direction.z());
    std::array<int, 3> dir_is_neg = {
        ray.direction.x() > 0 ? 0 : 1,
        ray.direction.y() > 0 ? 0 : 1,
        ray.direction.z() > 0 ? 0 : 1
    };

    if (!node->bounds.intersect_p(ray, inv_dir, dir_is_neg)) {
        return isect;
    }

    // 叶子节点：与对象求交
    if (node->left == nullptr && node->right == nullptr) {
        return node->object->getIntersection(ray);
    }

    // 内部节点：递归遍历子节点
    Intersection hit1 = getIntersection(node->left, ray);
    Intersection hit2 = getIntersection(node->right, ray);

    return hit1.distance < hit2.distance ? hit1 : hit2;
}
```

## 18.2 SAH（表面积启发式）

### 18.2.1 SAH理论基础

**成本函数**：

```
Cost = C_trav + P_left × N_left × C_isect + P_right × N_right × C_isect
```

其中：

- C_trav：遍历成本
- P_left/P_right：光线击中左/右子树的概率
- N_left/N_right：左/右子树的图元数量
- C_isect：相交测试成本

**概率计算**：

```
P_left = SA_left / SA_parent
P_right = SA_right / SA_parent
```

### 18.2.2 SAH实现

```cpp
struct SAHBucket {
    int count = 0;
    AABB bounds;
};

float evaluate_sah(const std::vector<Object*>& objects, int split_axis, float split_pos) {
    AABB left_bounds, right_bounds;
    int left_count = 0, right_count = 0;

    for (const auto& obj : objects) {
        Vector3f centroid = obj->getBounds().centroid();
        if (centroid[split_axis] < split_pos) {
            left_bounds.expand(obj->getBounds());
            left_count++;
        } else {
            right_bounds.expand(obj->getBounds());
            right_count++;
        }
    }

    float cost = 1.0f + // 遍历成本
                (left_count * left_bounds.surface_area() +
                 right_count * right_bounds.surface_area()) /
                parent_bounds.surface_area();

    return cost;
}

int find_best_split_sah(const std::vector<Object*>& objects) {
    const int n_buckets = 12;
    float min_cost = INFINITY;
    int best_split = -1;

    for (int dim = 0; dim < 3; ++dim) {
        // 创建桶
        std::vector<SAHBucket> buckets(n_buckets);

        // 将对象分配到桶中
        for (const auto& obj : objects) {
            int bucket = n_buckets * centroid_bounds.offset(obj->getBounds().centroid())[dim];
            bucket = std::min(bucket, n_buckets - 1);
            buckets[bucket].count++;
            buckets[bucket].bounds.expand(obj->getBounds());
        }

        // 计算每个分割位置的成本
        for (int i = 0; i < n_buckets - 1; ++i) {
            AABB b0, b1;
            int count0 = 0, count1 = 0;

            for (int j = 0; j <= i; ++j) {
                b0.expand(buckets[j].bounds);
                count0 += buckets[j].count;
            }

            for (int j = i + 1; j < n_buckets; ++j) {
                b1.expand(buckets[j].bounds);
                count1 += buckets[j].count;
            }

            float cost = 1.0f + (count0 * b0.surface_area() + count1 * b1.surface_area()) /
                         bounds.surface_area();

            if (cost < min_cost) {
                min_cost = cost;
                best_split = i;
            }
        }
    }

    return best_split;
}
```

## 18.3 其他加速结构

### 18.3.1 八叉树（Octree）

**基本原理**：递归地将3D空间分割为8个子立方体

**数据结构定义**：

```cpp
class Octree {
private:
    struct OctreeNode {
        AABB bounds;
        std::vector<Object*> objects;
        std::array<std::unique_ptr<OctreeNode>, 8> children;
        bool is_leaf;

        OctreeNode(const AABB& b) : bounds(b), is_leaf(true) {}
    };

    std::unique_ptr<OctreeNode> root;
    int max_depth;
    int max_objects_per_node;

public:
    void build(const std::vector<Object*>& objects, const AABB& scene_bounds) {
        root = std::make_unique<OctreeNode>(scene_bounds);
        build_recursive(root.get(), objects, 0);
    }

private:
    void build_recursive(OctreeNode* node, const std::vector<Object*>& objects, int depth) {
        if (depth >= max_depth || objects.size() <= max_objects_per_node) {
            node->objects = objects;
            return;
        }

        // 创建8个子节点
        Vector3f center = node->bounds.center();
        Vector3f min_pt = node->bounds.min_point;
        Vector3f max_pt = node->bounds.max_point;

        // 8个子立方体的包围盒
        std::array<AABB, 8> child_bounds = {
            AABB(Vector3f(min_pt.x(), min_pt.y(), min_pt.z()),
                 Vector3f(center.x(), center.y(), center.z())),  // 000
            AABB(Vector3f(center.x(), min_pt.y(), min_pt.z()),
                 Vector3f(max_pt.x(), center.y(), center.z())),  // 100
            AABB(Vector3f(min_pt.x(), center.y(), min_pt.z()),
                 Vector3f(center.x(), max_pt.y(), center.z())),  // 010
            AABB(Vector3f(center.x(), center.y(), min_pt.z()),
                 Vector3f(max_pt.x(), max_pt.y(), center.z())),  // 110
            AABB(Vector3f(min_pt.x(), min_pt.y(), center.z()),
                 Vector3f(center.x(), center.y(), max_pt.z())),  // 001
            AABB(Vector3f(center.x(), min_pt.y(), center.z()),
                 Vector3f(max_pt.x(), center.y(), max_pt.z())),  // 101
            AABB(Vector3f(min_pt.x(), center.y(), center.z()),
                 Vector3f(center.x(), max_pt.y(), max_pt.z())),  // 011
            AABB(Vector3f(center.x(), center.y(), center.z()),
                 Vector3f(max_pt.x(), max_pt.y(), max_pt.z()))   // 111
        };

        // 将对象分配到子节点
        std::array<std::vector<Object*>, 8> child_objects;
        for (const auto& obj : objects) {
            for (int i = 0; i < 8; ++i) {
                if (child_bounds[i].intersects(obj->getBounds())) {
                    child_objects[i].push_back(obj);
                }
            }
        }

        // 递归构建非空子节点
        node->is_leaf = false;
        for (int i = 0; i < 8; ++i) {
            if (!child_objects[i].empty()) {
                node->children[i] = std::make_unique<OctreeNode>(child_bounds[i]);
                build_recursive(node->children[i].get(), child_objects[i], depth + 1);
            }
        }
    }

public:
    Intersection intersect(const Ray& ray) const {
        return intersect_recursive(root.get(), ray);
    }

private:
    Intersection intersect_recursive(OctreeNode* node, const Ray& ray) const {
        if (!node || !node->bounds.intersect(ray)) {
            return Intersection();
        }

        if (node->is_leaf) {
            Intersection closest_hit;
            float closest_t = INFINITY;

            for (const auto& obj : node->objects) {
                Intersection hit = obj->getIntersection(ray);
                if (hit.happened && hit.distance < closest_t) {
                    closest_hit = hit;
                    closest_t = hit.distance;
                }
            }
            return closest_hit;
        }

        // 遍历子节点
        Intersection closest_hit;
        float closest_t = INFINITY;

        for (const auto& child : node->children) {
            if (child) {
                Intersection hit = intersect_recursive(child.get(), ray);
                if (hit.happened && hit.distance < closest_t) {
                    closest_hit = hit;
                    closest_t = hit.distance;
                }
            }
        }

        return closest_hit;
    }
};
```

**优缺点分析**：

- ✅ **优点**：空间分割均匀，易于理解和实现
- ❌ **缺点**：对象可能跨越多个节点，存储冗余

### 18.3.2 kD树（k-Dimensional Tree）

**基本原理**：沿坐标轴交替分割空间

**数据结构**：

```cpp
struct KDNode {
    AABB bounds;
    int split_axis;        // 分割轴：0=x, 1=y, 2=z
    float split_value;     // 分割位置

    std::unique_ptr<KDNode> left;   // 小于split_value的子树
    std::unique_ptr<KDNode> right;  // 大于等于split_value的子树

    std::vector<Object*> objects;   // 叶子节点存储的对象
    bool is_leaf;
};

class KDTree {
private:
    std::unique_ptr<KDNode> root;
    int max_depth;
    int max_objects_per_leaf;

public:
    void build(const std::vector<Object*>& objects, const AABB& bounds) {
        root = build_recursive(objects, bounds, 0);
    }

private:
    std::unique_ptr<KDNode> build_recursive(const std::vector<Object*>& objects,
                                           const AABB& bounds, int depth) {
        auto node = std::make_unique<KDNode>();
        node->bounds = bounds;

        // 终止条件
        if (depth >= max_depth || objects.size() <= max_objects_per_leaf) {
            node->is_leaf = true;
            node->objects = objects;
            return node;
        }

        // 选择分割轴（循环选择或基于最长轴）
        int axis = depth % 3;  // 或者选择bounds的最长轴

        // 计算分割位置（中位数或中点）
        std::vector<float> centroids;
        for (const auto& obj : objects) {
            centroids.push_back(obj->getBounds().center()[axis]);
        }

        std::sort(centroids.begin(), centroids.end());
        float split_pos = centroids[centroids.size() / 2];  // 中位数

        node->split_axis = axis;
        node->split_value = split_pos;
        node->is_leaf = false;

        // 分割对象
        std::vector<Object*> left_objects, right_objects;
        for (const auto& obj : objects) {
            float centroid = obj->getBounds().center()[axis];
            if (centroid < split_pos) {
                left_objects.push_back(obj);
            } else {
                right_objects.push_back(obj);
            }
        }

        // 计算子节点包围盒
        AABB left_bounds = bounds, right_bounds = bounds;
        left_bounds.max_point[axis] = split_pos;
        right_bounds.min_point[axis] = split_pos;

        // 递归构建子树
        if (!left_objects.empty()) {
            node->left = build_recursive(left_objects, left_bounds, depth + 1);
        }
        if (!right_objects.empty()) {
            node->right = build_recursive(right_objects, right_bounds, depth + 1);
        }

        return node;
    }
};
```

**遍历算法**：

```cpp
Intersection traverse_kd_tree(KDNode* node, const Ray& ray) {
    if (!node || !node->bounds.intersect(ray)) {
        return Intersection();
    }

    if (node->is_leaf) {
        // 与叶子节点中的所有对象求交
        Intersection closest_hit;
        float closest_t = INFINITY;

        for (const auto& obj : node->objects) {
            Intersection hit = obj->getIntersection(ray);
            if (hit.happened && hit.distance < closest_t) {
                closest_hit = hit;
                closest_t = hit.distance;
            }
        }
        return closest_hit;
    }

    // 确定光线与分割平面的关系
    float t_split = (node->split_value - ray.origin[node->split_axis]) /
                    ray.direction[node->split_axis];

    KDNode* first_child, *second_child;
    if (ray.origin[node->split_axis] < node->split_value) {
        first_child = node->left.get();
        second_child = node->right.get();
    } else {
        first_child = node->right.get();
        second_child = node->left.get();
    }

    // 遍历第一个子节点
    Intersection hit = traverse_kd_tree(first_child, ray);

    // 如果找到交点且在分割平面之前，直接返回
    if (hit.happened && hit.distance < t_split) {
        return hit;
    }

    // 否则遍历第二个子节点
    Intersection hit2 = traverse_kd_tree(second_child, ray);

    // 返回最近的交点
    if (hit2.happened && (!hit.happened || hit2.distance < hit.distance)) {
        return hit2;
    }
    return hit;
}
```

### 18.3.3 加速结构性能对比

**理论复杂度**：

| 结构    | 构建时间   | 内存消耗     | 查询时间 | 适用场景         |
| ------- | ---------- | ------------ | -------- | ---------------- |
| BVH     | O(n log n) | O(n)         | O(log n) | 通用，动态场景   |
| Octree  | O(n log n) | O(n)         | O(log n) | 均匀分布的场景   |
| kD-Tree | O(n log n) | O(n)         | O(log n) | 静态场景，点查询 |
| Grid    | O(n)       | O(n + cells) | O(1)     | 均匀密度场景     |

**实际性能测试**：

```cpp
struct PerformanceTest {
    std::string structure_name;
    double build_time;
    double query_time;
    size_t memory_usage;
    int ray_count;

    void print_results() const {
        std::cout << structure_name << ":\n";
        std::cout << "  构建时间: " << build_time << "ms\n";
        std::cout << "  平均查询时间: " << query_time / ray_count << "ms\n";
        std::cout << "  内存使用: " << memory_usage / 1024.0 / 1024.0 << "MB\n";
    }
};

void benchmark_acceleration_structures(const std::vector<Object*>& objects,
                                     const std::vector<Ray>& test_rays) {
    std::vector<PerformanceTest> results;

    // 测试BVH
    {
        auto start = std::chrono::high_resolution_clock::now();
        BVHAccel bvh(objects);
        auto build_end = std::chrono::high_resolution_clock::now();

        auto query_start = std::chrono::high_resolution_clock::now();
        for (const auto& ray : test_rays) {
            bvh.Intersect(ray);
        }
        auto query_end = std::chrono::high_resolution_clock::now();

        PerformanceTest test;
        test.structure_name = "BVH";
        test.build_time = std::chrono::duration<double, std::milli>(build_end - start).count();
        test.query_time = std::chrono::duration<double, std::milli>(query_end - query_start).count();
        test.ray_count = test_rays.size();
        results.push_back(test);
    }

    // 类似地测试其他结构...

    // 输出结果
    for (const auto& result : results) {
        result.print_results();
    }
}
```

---

## 蒙特卡洛方法与积分

## 19.1 蒙特卡洛积分理论

### 19.1.1 蒙特卡洛积分的数学基础

#### 基本蒙特卡洛估计

**积分估计公式**：
对于一维积分 $\int_a^b f(x) dx$，蒙特卡洛估计为：
$$\int_a^b f(x) dx \approx \frac{b-a}{N} \sum_{i=1}^N f(X_i)$$

其中 $X_i$ 是在区间 $[a,b]$ 上均匀分布的随机样本。

**多维积分推广**：
对于 $d$ 维积分：
$$\int_{\Omega} f(\mathbf{x}) d\mathbf{x} \approx \frac{|\Omega|}{N} \sum_{i=1}^N f(\mathbf{X}_i)$$

其中 $|\Omega|$ 是积分域的体积。

#### 理论保证

**强大数定律**：
$$\lim_{N \to \infty} \frac{1}{N} \sum_{i=1}^N f(X_i) = E[f(X)] = \int f(x) p(x) dx \quad \text{a.s.}$$

**中心极限定理**：
$$\sqrt{N}\left(\frac{1}{N} \sum_{i=1}^N f(X_i) - E[f(X)]\right) \xrightarrow{d} \mathcal{N}(0, \sigma^2)$$

其中 $\sigma^2 = \text{Var}[f(X)]$。

**收敛速度**：
标准误差为 $O(N^{-1/2})$，**与维度无关**，这是蒙特卡洛方法的重要优势。

### 19.1.2 重要性采样理论

#### 重要性采样的数学推导

**基本变换**：
$$\int f(\mathbf{x}) d\mathbf{x} = \int \frac{f(\mathbf{x})}{p(\mathbf{x})} p(\mathbf{x}) d\mathbf{x} = E\left[\frac{f(\mathbf{X})}{p(\mathbf{X})}\right]$$

其中 $p(\mathbf{x})$ 是概率密度函数，$\mathbf{X} \sim p(\mathbf{x})$。

**蒙特卡洛估计**：
$$\int f(\mathbf{x}) d\mathbf{x} \approx \frac{1}{N} \sum_{i=1}^N \frac{f(\mathbf{X}_i)}{p(\mathbf{X}_i)}$$

#### 方差分析与最优采样

**估计量的方差**：
$$\text{Var}\left[\frac{f(\mathbf{X})}{p(\mathbf{X})}\right] = \int \frac{f^2(\mathbf{x})}{p(\mathbf{x})} d\mathbf{x} - \left(\int f(\mathbf{x}) d\mathbf{x}\right)^2$$

**最优概率密度函数**：
使方差最小的最优采样密度为：
$$p^*(\mathbf{x}) = \frac{|f(\mathbf{x})|}{\int |f(\mathbf{y})| d\mathbf{y}}$$

此时方差为：
$$\text{Var}^* = \left(\int |f(\mathbf{x})| d\mathbf{x}\right)^2 - \left(\int f(\mathbf{x}) d\mathbf{x}\right)^2$$

**实用采样策略**：
在实际应用中，选择 $p(\mathbf{x}) \propto |f(\mathbf{x})|$ 可以显著减少方差。

**代码实现**：

```cpp
class ImportanceSampler {
private:
    std::function<float(float)> pdf;           // 概率密度函数
    std::function<float(float)> inverse_cdf;   // 累积分布函数的逆

public:
    float sample() {
        float u = random_float();  // [0,1)均匀随机数
        return inverse_cdf(u);
    }

    float evaluate_pdf(float x) {
        return pdf(x);
    }
};

// 余弦加权半球采样（用于漫反射）
Vector3f cosine_weighted_hemisphere_sample() {
    float u1 = random_float();
    float u2 = random_float();

    float cos_theta = std::sqrt(u1);
    float sin_theta = std::sqrt(1.0f - u1);
    float phi = 2.0f * M_PI * u2;

    return Vector3f(sin_theta * std::cos(phi),
                   sin_theta * std::sin(phi),
                   cos_theta);
}

float cosine_hemisphere_pdf(float cos_theta) {
    return cos_theta / M_PI;
}
```

### 19.1.3 方差减少技术的数学理论

#### 分层采样（Stratified Sampling）

**基本原理**：
将积分域分割成 $M$ 个不相交的子域 $\Omega_j$，在每个子域内独立采样：
$$\int_{\Omega} f(\mathbf{x}) d\mathbf{x} = \sum_{j=1}^M \int_{\Omega_j} f(\mathbf{x}) d\mathbf{x}$$

**方差减少效果**：
分层采样的方差为：
$$\text{Var}_{strat} = \sum_{j=1}^M \frac{|\Omega_j|^2}{n_j} \sigma_j^2$$

其中 $\sigma_j^2$ 是第 $j$ 层内的方差，通常 $\text{Var}_{strat} \leq \text{Var}_{uniform}$。

#### 多重重要性采样（MIS）

**问题背景**：
当有多个采样策略时，如何组合它们以获得最优结果？

**平衡启发式（Balance Heuristic）**：
对于 $n$ 个采样策略，权重函数为：
$$w_i(\mathbf{x}) = \frac{n_i p_i(\mathbf{x})}{\sum_{j=1}^n n_j p_j(\mathbf{x})}$$

其中 $n_i$ 是策略 $i$ 的样本数，$p_i(\mathbf{x})$ 是对应的概率密度函数。

**幂启发式（Power Heuristic）**：
$$w_i(\mathbf{x}) = \frac{(n_i p_i(\mathbf{x}))^\beta}{\sum_{j=1}^n (n_j p_j(\mathbf{x}))^\beta}$$

通常取 $\beta = 2$。

**MIS估计量**：
$$\hat{I}_{MIS} = \sum_{i=1}^n \frac{1}{n_i} \sum_{j=1}^{n_i} w_i(\mathbf{X}_{i,j}) \frac{f(\mathbf{X}_{i,j})}{p_i(\mathbf{X}_{i,j})}$$

#### 工程实现

```cpp
// 分层采样实现
class StratifiedSampler {
public:
    std::vector<Vector2f> generate_2d_samples(int sqrt_samples) {
        std::vector<Vector2f> samples;
        float inv_sqrt = 1.0f / sqrt_samples;

        for (int i = 0; i < sqrt_samples; ++i) {
            for (int j = 0; j < sqrt_samples; ++j) {
                float jitter_x = random_float();
                float jitter_y = random_float();

                float x = (i + jitter_x) * inv_sqrt;
                float y = (j + jitter_y) * inv_sqrt;

                samples.emplace_back(x, y);
            }
        }

        // 随机打乱以避免相关性
        std::shuffle(samples.begin(), samples.end(), rng);
        return samples;
    }
};

// 多重重要性采样实现
class MISIntegrator {
public:
    static float power_heuristic(float pdf_a, float pdf_b, int beta = 2) {
        float weight_a = std::pow(pdf_a, beta);
        float weight_b = std::pow(pdf_b, beta);
        return weight_a / (weight_a + weight_b);
    }

    Vector3f estimate_direct_lighting(const Intersection& hit) {
        Vector3f L(0, 0, 0);

        // 策略1：BRDF采样
        Vector3f brdf_dir = sample_brdf(hit);
        float brdf_pdf = evaluate_brdf_pdf(hit, brdf_dir);
        float light_pdf = evaluate_light_pdf(hit, brdf_dir);

        if (brdf_pdf > 0) {
            float weight = power_heuristic(brdf_pdf, light_pdf);
            Vector3f brdf_value = evaluate_brdf(hit, brdf_dir);
            Vector3f incoming = trace_ray(hit.position, brdf_dir);
            L += weight * brdf_value * incoming / brdf_pdf;
        }

        // 策略2：光源采样
        Vector3f light_dir = sample_light(hit);
        light_pdf = evaluate_light_pdf(hit, light_dir);
        brdf_pdf = evaluate_brdf_pdf(hit, light_dir);

        if (light_pdf > 0) {
            float weight = power_heuristic(light_pdf, brdf_pdf);
            Vector3f brdf_value = evaluate_brdf(hit, light_dir);
            Vector3f incoming = trace_ray(hit.position, light_dir);
            L += weight * brdf_value * incoming / light_pdf;
        }

        return L;
    }
};
                                trace_ray(hit.position, brdf_dir) *
                                weight_brdf / brdf_pdf;

    // 光源采样
    Vector3f light_dir = sample_light(hit);
    light_pdf = evaluate_light_pdf(hit, light_dir);
    brdf_pdf = evaluate_brdf_pdf(hit, light_dir);
    float weight_light = mis_weight(light_pdf, brdf_pdf);

    Vector3f light_contribution = evaluate_brdf(hit, light_dir) *
                                 trace_ray(hit.position, light_dir) *
                                 weight_light / light_pdf;

    return brdf_contribution + light_contribution;
}
```

## 19.2 渲染中的蒙特卡洛应用

### 19.2.1 直接光照的蒙特卡洛估计

**渲染方程的直接光照部分**：

```
$$L_{direct} = \int_\Omega f_r(\omega_i, \omega_o) L_i(\omega_i) \cos \theta_i d\omega_i$$
```

**蒙特卡洛估计**：

```cpp
Vector3f estimate_direct_lighting(const Intersection& hit, const Vector3f& wo) {
    Vector3f direct_lighting(0, 0, 0);
    int samples = 64;

    for (int i = 0; i < samples; ++i) {
        // 采样光源
        Intersection light_sample;
        float light_pdf;
        scene.sample_light(light_sample, light_pdf);

        Vector3f light_dir = (light_sample.coords - hit.coords).normalized();
        float distance = (light_sample.coords - hit.coords).norm();

        // 阴影测试
        Ray shadow_ray(hit.coords + EPSILON * hit.normal, light_dir);
        shadow_ray.t_max = distance - EPSILON;

        if (!scene.intersect(shadow_ray).happened) {
            // 计算BRDF
            Vector3f brdf = hit.m->eval(light_dir, wo, hit.normal);

            // 计算贡献
            float cos_theta = std::max(0.0f, hit.normal.dot(light_dir));
            Vector3f contribution = brdf * light_sample.emit * cos_theta / light_pdf;

            direct_lighting += contribution;
        }
    }

    return direct_lighting / samples;
}
```

### 19.2.2 全局光照的路径追踪

**路径追踪算法**：

```cpp
Vector3f path_tracing(const Ray& ray, int depth) {
    if (depth <= 0) return Vector3f(0, 0, 0);

    Intersection hit = scene.intersect(ray);
    if (!hit.happened) return scene.background_color;

    Vector3f color(0, 0, 0);

    // 自发光
    color += hit.m->getEmission();

    // 直接光照
    color += estimate_direct_lighting(hit, -ray.direction);

    // 间接光照（俄罗斯轮盘赌）
    float russian_roulette = 0.8f;
    if (random_float() < russian_roulette) {
        // 采样BRDF
        Vector3f wi = sample_hemisphere(hit.normal);
        float pdf = 1.0f / (2.0f * M_PI);  // 均匀半球采样

        Vector3f brdf = hit.m->eval(wi, -ray.direction, hit.normal);
        float cos_theta = std::max(0.0f, hit.normal.dot(wi));

        Ray indirect_ray(hit.coords + EPSILON * hit.normal, wi);
        Vector3f indirect = path_tracing(indirect_ray, depth - 1);

        color += brdf * indirect * cos_theta / (pdf * russian_roulette);
    }

    return color;
}
```

### 19.2.3 双向路径追踪

**基本思想**：同时从光源和摄像机追踪路径，在中间连接

**算法框架**：

```cpp
Vector3f bidirectional_path_tracing(const Ray& camera_ray) {
    // 从摄像机追踪路径
    std::vector<PathVertex> camera_path;
    trace_path_from_camera(camera_ray, camera_path);

    // 从光源追踪路径
    std::vector<PathVertex> light_path;
    trace_path_from_light(light_path);

    Vector3f color(0, 0, 0);

    // 尝试所有可能的连接
    for (int i = 0; i < camera_path.size(); ++i) {
        for (int j = 0; j < light_path.size(); ++j) {
            Vector3f contribution = connect_paths(camera_path, i, light_path, j);
            color += contribution;
        }
    }

    return color;
}

struct PathVertex {
    Vector3f position;
    Vector3f normal;
    Vector3f wi, wo;  // 入射和出射方向
    Material* material;
    float pdf_forward, pdf_backward;
    Vector3f throughput;  // 路径权重
};

Vector3f connect_paths(const std::vector<PathVertex>& camera_path, int cam_idx,
                      const std::vector<PathVertex>& light_path, int light_idx) {
    if (cam_idx >= camera_path.size() || light_idx >= light_path.size()) {
        return Vector3f(0, 0, 0);
    }

    const PathVertex& cam_vertex = camera_path[cam_idx];
    const PathVertex& light_vertex = light_path[light_idx];

    // 检查连接的可见性
    Vector3f connection_dir = (light_vertex.position - cam_vertex.position).normalized();
    float distance = (light_vertex.position - cam_vertex.position).norm();

    Ray visibility_ray(cam_vertex.position + EPSILON * cam_vertex.normal, connection_dir);
    visibility_ray.t_max = distance - EPSILON;

    if (scene.intersect(visibility_ray).happened) {
        return Vector3f(0, 0, 0);  // 被遮挡
    }

    // 计算连接的贡献
    Vector3f brdf_cam = cam_vertex.material->eval(connection_dir, cam_vertex.wo, cam_vertex.normal);
    Vector3f brdf_light = light_vertex.material->eval(-connection_dir, light_vertex.wi, light_vertex.normal);

    float cos_cam = std::max(0.0f, cam_vertex.normal.dot(connection_dir));
    float cos_light = std::max(0.0f, light_vertex.normal.dot(-connection_dir));

    Vector3f geometry_term = Vector3f(cos_cam * cos_light / (distance * distance));

    return cam_vertex.throughput * brdf_cam * geometry_term * brdf_light * light_vertex.throughput;
}
```

---

## 全局光照与路径追踪

## 20.1 渲染方程深度解析

### 20.1.1 渲染方程的数学推导与物理意义

#### 渲染方程的完整数学形式

**积分形式的渲染方程**：
$$L_o(\mathbf{p}, \omega_o) = L_e(\mathbf{p}, \omega_o) + \int_{\Omega} f_r(\mathbf{p}, \omega_i, \omega_o) L_i(\mathbf{p}, \omega_i) \cos \theta_i \, d\omega_i$$

#### 各项的物理意义与数学定义

**1. 出射辐射度 $L_o(\mathbf{p}, \omega_o)$**：
从表面点 $\mathbf{p}$ 沿方向 $\omega_o$ 的出射辐射度，单位为 $\text{W} \cdot \text{m}^{-2} \cdot \text{sr}^{-1}$

**2. 自发光项 $L_e(\mathbf{p}, \omega_o)$**：
表面点 $\mathbf{p}$ 自身发出的辐射度（对于光源）

**3. BRDF $f_r(\mathbf{p}, \omega_i, \omega_o)$**：
双向反射分布函数，定义为：
$$f_r(\mathbf{p}, \omega_i, \omega_o) = \frac{dL_o(\mathbf{p}, \omega_o)}{dE_i(\mathbf{p}, \omega_i)} = \frac{dL_o(\mathbf{p}, \omega_o)}{L_i(\mathbf{p}, \omega_i) \cos \theta_i \, d\omega_i}$$

**4. 入射辐射度 $L_i(\mathbf{p}, \omega_i)$**：
从方向 $\omega_i$ 入射到点 $\mathbf{p}$ 的辐射度

**5. 余弦项 $\cos \theta_i$**：
Lambert余弦定律，其中 $\theta_i$ 是入射方向与表面法向量的夹角

**6. 立体角积分域 $\Omega$**：
以点 $\mathbf{p}$ 为中心的上半球面，$\Omega = 2\pi$ 立体角

#### 递归形式与光传输

**递归渲染方程**：
$$L_o(\mathbf{p}, \omega_o) = L_e(\mathbf{p}, \omega_o) + \int_{\Omega} f_r(\mathbf{p}, \omega_i, \omega_o) L_o(\mathbf{p}', -\omega_i) \cos \theta_i \, d\omega_i$$

其中 $\mathbf{p}'$ 是沿方向 $\omega_i$ 的光线与场景的下一个交点：
$$\mathbf{p}' = \mathbf{p} + t \omega_i$$

这个递归形式体现了光在场景中的多次弹射传播。

### 20.1.2 光传输算子的数学理论

#### 算子形式的渲染方程

**线性算子表示**：
$$\mathbf{L} = \mathbf{E} + \mathbf{T}\mathbf{L}$$

其中：

- $\mathbf{L}$：辐射度函数（在所有表面点和方向上的分布）
- $\mathbf{E}$：自发光项
- $\mathbf{T}$：光传输算子

**光传输算子的定义**：
$$(\mathbf{T}\mathbf{L})(\mathbf{p}, \omega_o) = \int_{\Omega} f_r(\mathbf{p}, \omega_i, \omega_o) \mathbf{L}(\mathbf{p}', -\omega_i) \cos \theta_i \, d\omega_i$$

#### Neumann级数展开

**级数解**：
从算子方程 $\mathbf{L} = \mathbf{E} + \mathbf{T}\mathbf{L}$ 可得：
$$\mathbf{L} = (\mathbf{I} - \mathbf{T})^{-1}\mathbf{E} = \sum_{n=0}^{\infty} \mathbf{T}^n \mathbf{E}$$

**各项的物理意义**：

光线弹射次数与光照贡献：

直接光照（0次弹射）：
$$\mathbf{T}^0\mathbf{E} = \mathbf{E}$$

一次间接光照（1次弹射）：
$$\mathbf{T}^1\mathbf{E} = \mathbf{T}\mathbf{E}$$

二次间接光照（2次弹射）：
$$\mathbf{T}^2\mathbf{E} = \mathbf{T}^2\mathbf{E}$$

n次间接光照（n次弹射）：
$$\mathbf{T}^n\mathbf{E}$$

#### 收敛性分析

**收敛条件**：
级数收敛当且仅当 $\|\mathbf{T}\| < 1$，即光传输算子的谱半径小于1。

**物理意义**：
这对应于能量守恒定律——每次反射都会损失一部分能量，因此无限次弹射后总能量收敛。

**实际应用**：
在路径追踪中，通过俄罗斯轮盘赌（Russian Roulette）来无偏地截断无限级数。

## 20.2 路径追踪算法详解

### 20.2.1 基础路径追踪

**算法原理**：从摄像机发射光线，在每个交点随机选择一个方向继续追踪

**基于GAMES101 Assignment7的实现**：

```cpp
Vector3f Scene::castRay(const Ray &ray, int depth) const {
    if (depth > this->maxDepth) {
        return Vector3f(0.0, 0.0, 0.0);
    }

    Intersection intersection = Scene::intersect(ray);
    if (!intersection.happened) {
        return this->backgroundColor;
    }

    Material *m = intersection.m;
    Object *hitObject = intersection.obj;
    Vector3f hitColor = this->backgroundColor;
    Vector3f hitPoint = intersection.coords;
    Vector3f N = intersection.normal;
    Vector2f uv = intersection.uv;

    switch (m->getType()) {
        case DIFFUSE: {
            // 直接光照采样
            Vector3f L_dir(0, 0, 0);

            // 对光源进行采样
            Intersection light_pos;
            float light_pdf = 0.0f;
            sampleLight(light_pos, light_pdf);

            Vector3f obj2light = light_pos.coords - hitPoint;
            Vector3f obj2lightdir = obj2light.normalized();
            float distance = obj2light.norm();

            // 发射阴影光线
            Ray shadowRay(hitPoint, obj2lightdir);
            Intersection shadowIntersection = intersect(shadowRay);

            // 检查是否被遮挡
            if (shadowIntersection.distance - distance > -EPSILON) {
                Vector3f f_r = m->eval(obj2lightdir, -ray.direction, N);
                L_dir = light_pos.emit * f_r * dotProduct(obj2lightdir, N) / light_pdf / distance / distance;
            }

            // 间接光照采样（俄罗斯轮盘赌）
            Vector3f L_indir(0, 0, 0);
            float ksi = get_random_float();
            if (ksi < RussianRoulette) {
                Vector3f wi = toWorld(sampleHemisphere(uv), N);
                Ray indirectRay(hitPoint, wi);
                Intersection indirectIntersection = intersect(indirectRay);

                if (indirectIntersection.happened && !indirectIntersection.obj->hasEmit()) {
                    Vector3f f_r = m->eval(wi, -ray.direction, N);
                    float pdf = 1.0f / (2.0f * M_PI);  // 均匀半球采样
                    L_indir = castRay(indirectRay, depth + 1) * f_r * dotProduct(wi, N) / pdf / RussianRoulette;
                }
            }

            hitColor = L_dir + L_indir;
            break;
        }
    }

    return hitColor;
}
```

### 20.2.2 重要性采样优化

**BRDF重要性采样**：

```cpp
// 余弦加权采样（适用于Lambert材质）
Vector3f cosine_sample_hemisphere(const Vector2f& u) {
    float cos_theta = std::sqrt(u[0]);
    float sin_theta = std::sqrt(1.0f - u[0]);
    float phi = 2.0f * M_PI * u[1];

    return Vector3f(sin_theta * std::cos(phi),
                   sin_theta * std::sin(phi),
                   cos_theta);
}

float cosine_hemisphere_pdf(float cos_theta) {
    return cos_theta / M_PI;
}

// 镜面反射采样
Vector3f sample_specular_reflection(const Vector3f& wi, const Vector3f& normal) {
    return wi - 2.0f * wi.dot(normal) * normal;
}

// 微表面模型采样（GGX分布）
Vector3f sample_ggx_distribution(const Vector2f& u, float alpha) {
    float cos_theta = std::sqrt((1.0f - u[0]) / (1.0f + (alpha * alpha - 1.0f) * u[0]));
    float sin_theta = std::sqrt(1.0f - cos_theta * cos_theta);
    float phi = 2.0f * M_PI * u[1];

    return Vector3f(sin_theta * std::cos(phi),
                   sin_theta * std::sin(phi),
                   cos_theta);
}
```

### 20.2.3 多重重要性采样

**结合BRDF采样和光源采样**：

```cpp
Vector3f estimate_direct_lighting_mis(const Intersection& hit, const Vector3f& wo) {
    Vector3f L(0, 0, 0);

    // 光源采样
    Intersection light_sample;
    float light_pdf;
    scene.sample_light(light_sample, light_pdf);

    if (light_pdf > 0) {
        Vector3f wi = (light_sample.coords - hit.coords).normalized();

        // 检查可见性
        if (!scene.occluded(hit.coords, light_sample.coords)) {
            Vector3f f = hit.material->eval(wi, wo, hit.normal);
            float brdf_pdf = hit.material->pdf(wi, wo, hit.normal);

            if (brdf_pdf > 0) {
                float weight = power_heuristic(light_pdf, brdf_pdf);
                float cos_theta = std::max(0.0f, hit.normal.dot(wi));
                L += f * light_sample.emit * cos_theta * weight / light_pdf;
            }
        }
    }

    // BRDF采样
    Vector3f wi;
    float brdf_pdf;
    Vector3f f = hit.material->sample_f(wo, wi, hit.normal, brdf_pdf);

    if (brdf_pdf > 0) {
        Ray ray(hit.coords + EPSILON * hit.normal, wi);
        Intersection light_hit = scene.intersect(ray);

        if (light_hit.happened && light_hit.obj->hasEmit()) {
            float light_pdf_value = scene.pdf_light(hit.coords, light_hit.coords);
            float weight = power_heuristic(brdf_pdf, light_pdf_value);
            float cos_theta = std::max(0.0f, hit.normal.dot(wi));
            L += f * light_hit.obj->getEmission() * cos_theta * weight / brdf_pdf;
        }
    }

    return L;
}

// Power启发式权重函数
float power_heuristic(float pdf_a, float pdf_b, int beta = 2) {
    float a = std::pow(pdf_a, beta);
    float b = std::pow(pdf_b, beta);
    return a / (a + b);
}
```

## 20.3 高级全局光照技术

### 20.3.1 光子映射

**基本思想**：

1. **光子发射**：从光源发射光子，记录其在场景中的交互
2. **光子存储**：将光子存储在空间数据结构中
3. **密度估计**：在渲染时查询附近光子估计辐射度

**光子结构**：

```cpp
struct Photon {
    Vector3f position;     // 光子位置
    Vector3f direction;    // 入射方向
    Vector3f power;        // 光子能量
    short plane;           // kD树分割平面
};

class PhotonMap {
private:
    std::vector<Photon> photons;
    int stored_photons;
    int max_photons;

public:
    void store(const Photon& photon) {
        if (stored_photons < max_photons) {
            photons[stored_photons] = photon;
            stored_photons++;
        }
    }

    Vector3f irradiance_estimate(const Vector3f& position, const Vector3f& normal,
                                float max_distance, int max_photons) {
        // 查找最近的光子
        std::vector<std::pair<float, int>> nearest_photons;
        find_nearest_photons(position, max_distance, max_photons, nearest_photons);

        if (nearest_photons.empty()) return Vector3f(0, 0, 0);

        Vector3f irradiance(0, 0, 0);
        float max_dist_sqr = nearest_photons.back().first;

        for (const auto& [dist_sqr, idx] : nearest_photons) {
            const Photon& photon = photons[idx];

            // 检查光子方向与表面法向量的关系
            if (photon.direction.dot(normal) < 0) {
                irradiance += photon.power;
            }
        }

        // 密度估计：$irradiance = \frac{power}{area}$
        return irradiance / (M_PI * max_dist_sqr);
    }
};
```

**光子追踪过程**：

```cpp
void trace_photon(const Ray& ray, const Vector3f& power, int depth) {
    if (depth <= 0 || power.norm() < EPSILON) return;

    Intersection hit = scene.intersect(ray);
    if (!hit.happened) return;

    // 存储光子（除了第一次交互）
    if (depth < max_depth) {
        Photon photon;
        photon.position = hit.coords;
        photon.direction = ray.direction;
        photon.power = power;
        photon_map.store(photon);
    }

    // 俄罗斯轮盘赌决定是否继续
    float survival_prob = std::min(0.9f, power.maxCoeff());
    if (random_float() > survival_prob) return;

    // 采样新方向
    Vector3f new_direction;
    Vector3f brdf = hit.material->sample_f(-ray.direction, new_direction, hit.normal);

    Vector3f new_power = power * brdf * hit.normal.dot(new_direction) / survival_prob;
    Ray new_ray(hit.coords + EPSILON * hit.normal, new_direction);

    trace_photon(new_ray, new_power, depth - 1);
}
```

### 20.3.2 实时全局光照近似

**屏幕空间环境光遮蔽（SSAO）**：

```cpp
float calculate_ssao(const Vector2f& screen_pos, const Vector3f& position,
                    const Vector3f& normal, const Texture& depth_buffer) {
    float occlusion = 0.0f;
    int samples = 64;
    float radius = 0.5f;

    for (int i = 0; i < samples; ++i) {
        // 在法向量半球内采样
        Vector3f sample_dir = generate_hemisphere_sample(normal);
        Vector3f sample_pos = position + radius * sample_dir;

        // 投影到屏幕空间
        Vector2f sample_screen = world_to_screen(sample_pos);

        // 采样深度缓冲
        float sample_depth = depth_buffer.sample(sample_screen);
        float actual_depth = world_to_depth(sample_pos);

        // 比较深度
        if (actual_depth > sample_depth + bias) {
            occlusion += 1.0f;
        }
    }

    return 1.0f - (occlusion / samples);
}
```

**光传播体积（Light Propagation Volumes）**：

```cpp
class LightPropagationVolume {
private:
    struct VoxelGrid {
        std::vector<Vector3f> red_coeffs;    // 红色通道球谐系数
        std::vector<Vector3f> green_coeffs;  // 绿色通道球谐系数
        std::vector<Vector3f> blue_coeffs;   // 蓝色通道球谐系数
        int resolution;
    };

    VoxelGrid grid;

public:
    void inject_light(const std::vector<VirtualPointLight>& vpls) {
        // 将虚拟点光源注入体素网格
        for (const auto& vpl : vpls) {
            Vector3i voxel_coord = world_to_voxel(vpl.position);

            // 计算球谐系数
            Vector3f sh_coeffs = compute_spherical_harmonics(vpl.direction, vpl.intensity);

            grid.red_coeffs[voxel_index(voxel_coord)] += sh_coeffs * vpl.color.r;
            grid.green_coeffs[voxel_index(voxel_coord)] += sh_coeffs * vpl.color.g;
            grid.blue_coeffs[voxel_index(voxel_coord)] += sh_coeffs * vpl.color.b;
        }
    }

    void propagate_light() {
        // 迭代传播光照
        for (int iteration = 0; iteration < 4; ++iteration) {
            VoxelGrid new_grid = grid;

            for (int z = 0; z < grid.resolution; ++z) {
                for (int y = 0; y < grid.resolution; ++y) {
                    for (int x = 0; x < grid.resolution; ++x) {
                        Vector3i coord(x, y, z);

                        // 从6个邻居传播光照
                        propagate_from_neighbors(coord, new_grid);
                    }
                }
            }

            grid = new_grid;
        }
    }

    Vector3f sample_indirect_lighting(const Vector3f& position, const Vector3f& normal) {
        Vector3i voxel_coord = world_to_voxel(position);

        // 三线性插值采样球谐系数
        Vector3f red_sh = trilinear_sample(grid.red_coeffs, voxel_coord);
        Vector3f green_sh = trilinear_sample(grid.green_coeffs, voxel_coord);
        Vector3f blue_sh = trilinear_sample(grid.blue_coeffs, voxel_coord);

        // 计算法向量方向的辐射度
        float sh_basis = evaluate_spherical_harmonics(normal);

        return Vector3f(red_sh.dot(Vector3f(sh_basis)),
                       green_sh.dot(Vector3f(sh_basis)),
                       blue_sh.dot(Vector3f(sh_basis)));
    }
};
```

---

## 动画基础理论

## 21.1 动画的数学基础

### 21.1.1 插值理论的数学基础

#### 线性插值的数学定义

**一维线性插值**：
给定两个数据点 $(t_0, f_0)$ 和 $(t_1, f_1)$，线性插值函数为：
$$f(t) = f_0 + \frac{t - t_0}{t_1 - t_0}(f_1 - f_0) = (1-u)f_0 + uf_1$$

其中 $u = \frac{t - t_0}{t_1 - t_0} \in [0,1]$ 是标准化参数。

**几何意义**：
线性插值在几何上表示连接两点的直线段，满足：

- **端点插值性**：$f(t_0) = f_0$，$f(t_1) = f_1$
- **线性性**：$f(\alpha t_0 + (1-\alpha)t_1) = \alpha f_0 + (1-\alpha)f_1$

#### 多维线性插值

**向量插值**：
对于向量 $\mathbf{v}_0, \mathbf{v}_1 \in \mathbb{R}^n$：
$$\mathbf{v}(t) = (1-t)\mathbf{v}_0 + t\mathbf{v}_1$$

**性质**：

- **分量独立性**：每个分量独立进行线性插值
- **仿射不变性**：仿射变换与插值可交换

**代码实现**：

```cpp
template<typename T>
T lerp(const T& a, const T& b, float t) {
    return a + t * (b - a);
}

// 向量插值
Vector3f lerp_vector(const Vector3f& v1, const Vector3f& v2, float t) {
    return Vector3f(lerp(v1.x(), v2.x(), t),
                   lerp(v1.y(), v2.y(), t),
                   lerp(v1.z(), v2.z(), t));
}

// 颜色插值
Color lerp_color(const Color& c1, const Color& c2, float t) {
    return Color(lerp(c1.r, c2.r, t),
                lerp(c1.g, c2.g, t),
                lerp(c1.b, c2.b, t),
                lerp(c1.a, c2.a, t));
}
```

#### 球面线性插值（SLERP）的数学理论

**问题背景**：
对于单位球面上的点（如单位四元数），线性插值的结果不在球面上，需要特殊的插值方法。

**SLERP的数学定义**：
对于单位球面上的两点 $\mathbf{q}_1$ 和 $\mathbf{q}_2$，球面线性插值为：
$$\text{slerp}(\mathbf{q}_1, \mathbf{q}_2, t) = \frac{\sin((1-t)\theta)}{\sin\theta}\mathbf{q}_1 + \frac{\sin(t\theta)}{\sin\theta}\mathbf{q}_2$$

其中 $\theta = \arccos(\mathbf{q}_1 \cdot \mathbf{q}_2)$ 是两个四元数之间的角度。

**几何意义**：
SLERP沿着连接两点的大圆弧进行插值，保持：

- **单位长度**：插值结果始终在单位球面上
- **等角速度**：角速度恒定
- **最短路径**：沿最短的大圆弧路径

**数学推导**：
设 $\mathbf{q}(t) = a(t)\mathbf{q}_1 + b(t)\mathbf{q}_2$，要求：

1. $\|\mathbf{q}(t)\| = 1$（单位长度）
2. $\mathbf{q}(0) = \mathbf{q}_1$，$\mathbf{q}(1) = \mathbf{q}_2$（端点条件）
3. 等角速度条件

解得：$a(t) = \frac{\sin((1-t)\theta)}{\sin\theta}$，$b(t) = \frac{\sin(t\theta)}{\sin\theta}$

```cpp
Quaternionf slerp(const Quaternionf& q1, const Quaternionf& q2, float t) {
    float dot = q1.dot(q2);

    // 选择最短路径
    Quaternionf q2_corrected = (dot < 0) ? Quaternionf(-q2.coeffs()) : q2;
    dot = std::abs(dot);

    // 如果四元数非常接近，使用线性插值
    if (dot > 0.9995f) {
        Quaternionf result = Quaternionf(q1.coeffs() + t * (q2_corrected.coeffs() - q1.coeffs()));
        result.normalize();
        return result;
    }

    // 球面线性插值
    float theta = std::acos(dot);
    float sin_theta = std::sin(theta);

    float w1 = std::sin((1.0f - t) * theta) / sin_theta;
    float w2 = std::sin(t * theta) / sin_theta;

    return Quaternionf(w1 * q1.coeffs() + w2 * q2_corrected.coeffs());
}
```

### 21.1.2 样条插值

**Catmull-Rom样条**：
通过控制点的平滑曲线
$$f(t) = \frac{1}{2}[2P_1 + (-P_0 + P_2)t + (2P_0 - 5P_1 + 4P_2 - P_3)t^2 + (-P_0 + 3P_1 - 3P_2 + P_3)t^3]$$

```cpp
Vector3f catmull_rom_spline(const Vector3f& p0, const Vector3f& p1,
                           const Vector3f& p2, const Vector3f& p3, float t) {
    float t2 = t * t;
    float t3 = t2 * t;

    Vector3f a = -0.5f * p0 + 1.5f * p1 - 1.5f * p2 + 0.5f * p3;
    Vector3f b = p0 - 2.5f * p1 + 2.0f * p2 - 0.5f * p3;
    Vector3f c = -0.5f * p0 + 0.5f * p2;
    Vector3f d = p1;

    return a * t3 + b * t2 + c * t + d;
}
```

**B样条基函数**：

```cpp
float b_spline_basis(int i, int k, float t, const std::vector<float>& knots) {
    if (k == 0) {
        return (t >= knots[i] && t < knots[i + 1]) ? 1.0f : 0.0f;
    }

    float left_coeff = 0.0f, right_coeff = 0.0f;

    if (knots[i + k] != knots[i]) {
        left_coeff = (t - knots[i]) / (knots[i + k] - knots[i]);
    }

    if (knots[i + k + 1] != knots[i + 1]) {
        right_coeff = (knots[i + k + 1] - t) / (knots[i + k + 1] - knots[i + 1]);
    }

    return left_coeff * b_spline_basis(i, k - 1, t, knots) +
           right_coeff * b_spline_basis(i + 1, k - 1, t, knots);
}
```

## 21.2 关键帧动画

### 21.2.1 关键帧系统设计

**关键帧数据结构**：

```cpp
template<typename T>
struct Keyframe {
    float time;
    T value;

    // 切线信息（用于Hermite插值）
    T in_tangent;
    T out_tangent;

    // 插值类型
    enum InterpolationType {
        LINEAR,
        CUBIC,
        BEZIER,
        STEP
    } interpolation;
};

template<typename T>
class AnimationCurve {
private:
    std::vector<Keyframe<T>> keyframes;

public:
    void add_keyframe(float time, const T& value,
                     typename Keyframe<T>::InterpolationType interp = Keyframe<T>::LINEAR) {
        Keyframe<T> kf;
        kf.time = time;
        kf.value = value;
        kf.interpolation = interp;

        // 保持时间顺序
        auto it = std::lower_bound(keyframes.begin(), keyframes.end(), kf,
                                  [](const Keyframe<T>& a, const Keyframe<T>& b) {
                                      return a.time < b.time;
                                  });
        keyframes.insert(it, kf);
    }

    T evaluate(float time) const {
        if (keyframes.empty()) return T();
        if (keyframes.size() == 1) return keyframes[0].value;

        // 边界情况
        if (time <= keyframes.front().time) return keyframes.front().value;
        if (time >= keyframes.back().time) return keyframes.back().value;

        // 找到相邻的关键帧
        auto it = std::lower_bound(keyframes.begin(), keyframes.end(), time,
                                  [](const Keyframe<T>& kf, float t) {
                                      return kf.time < t;
                                  });

        const Keyframe<T>& kf1 = *(it - 1);
        const Keyframe<T>& kf2 = *it;

        float t = (time - kf1.time) / (kf2.time - kf1.time);

        switch (kf1.interpolation) {
            case Keyframe<T>::LINEAR:
                return lerp(kf1.value, kf2.value, t);

            case Keyframe<T>::CUBIC:
                return cubic_interpolate(kf1.value, kf1.out_tangent,
                                       kf2.value, kf2.in_tangent, t);

            case Keyframe<T>::STEP:
                return kf1.value;

            default:
                return lerp(kf1.value, kf2.value, t);
        }
    }
};
```

### 21.2.2 动画混合

**线性混合**：

```cpp
class AnimationBlender {
private:
    struct AnimationLayer {
        AnimationCurve<Vector3f> position;
        AnimationCurve<Quaternionf> rotation;
        AnimationCurve<Vector3f> scale;
        float weight;
        bool additive;
    };

    std::vector<AnimationLayer> layers;

public:
    void add_layer(const AnimationLayer& layer) {
        layers.push_back(layer);
    }

    Transform evaluate(float time) const {
        Transform result;
        result.position = Vector3f::Zero();
        result.rotation = Quaternionf::Identity();
        result.scale = Vector3f::Ones();

        float total_weight = 0.0f;

        for (const auto& layer : layers) {
            if (layer.weight <= 0.0f) continue;

            Transform layer_transform;
            layer_transform.position = layer.position.evaluate(time);
            layer_transform.rotation = layer.rotation.evaluate(time);
            layer_transform.scale = layer.scale.evaluate(time);

            if (layer.additive) {
                // 加性混合
                result.position += layer_transform.position * layer.weight;
                result.rotation = result.rotation *
                    Quaternionf::Identity().slerp(layer.weight, layer_transform.rotation);
                result.scale += (layer_transform.scale - Vector3f::Ones()) * layer.weight;
            } else {
                // 线性混合
                float normalized_weight = layer.weight;
                if (total_weight > 0) {
                    normalized_weight = layer.weight / (total_weight + layer.weight);
                }

                result.position = lerp(result.position, layer_transform.position, normalized_weight);
                result.rotation = result.rotation.slerp(normalized_weight, layer_transform.rotation);
                result.scale = lerp(result.scale, layer_transform.scale, normalized_weight);

                total_weight += layer.weight;
            }
        }

        return result;
    }
};
```

## 21.3 骨骼动画

### 21.3.1 骨骼层次结构

**骨骼数据结构**：

```cpp
struct Bone {
    std::string name;
    int parent_index;
    std::vector<int> children_indices;

    // 绑定姿态（T-pose）
    Transform bind_pose;
    Matrix4f inverse_bind_matrix;

    // 当前变换
    Transform local_transform;
    Transform world_transform;
};

class Skeleton {
private:
    std::vector<Bone> bones;
    std::unordered_map<std::string, int> bone_name_to_index;

public:
    void add_bone(const std::string& name, int parent_index, const Transform& bind_pose) {
        Bone bone;
        bone.name = name;
        bone.parent_index = parent_index;
        bone.bind_pose = bind_pose;
        bone.local_transform = bind_pose;
        bone.inverse_bind_matrix = bind_pose.to_matrix().inverse();

        int bone_index = bones.size();
        bones.push_back(bone);
        bone_name_to_index[name] = bone_index;

        // 更新父骨骼的子骨骼列表
        if (parent_index >= 0) {
            bones[parent_index].children_indices.push_back(bone_index);
        }
    }

    void update_world_transforms() {
        for (int i = 0; i < bones.size(); ++i) {
            update_bone_world_transform(i);
        }
    }

private:
    void update_bone_world_transform(int bone_index) {
        Bone& bone = bones[bone_index];

        if (bone.parent_index >= 0) {
            const Bone& parent = bones[bone.parent_index];
            bone.world_transform = parent.world_transform * bone.local_transform;
        } else {
            bone.world_transform = bone.local_transform;
        }
    }

public:
    std::vector<Matrix4f> get_bone_matrices() const {
        std::vector<Matrix4f> matrices;
        matrices.reserve(bones.size());

        for (const auto& bone : bones) {
            Matrix4f bone_matrix = bone.world_transform.to_matrix() * bone.inverse_bind_matrix;
            matrices.push_back(bone_matrix);
        }

        return matrices;
    }
};
```

### 21.3.2 蒙皮算法

**线性混合蒙皮（Linear Blend Skinning）**：

```cpp
struct VertexWeight {
    int bone_indices[4];
    float weights[4];

    void normalize() {
        float sum = weights[0] + weights[1] + weights[2] + weights[3];
        if (sum > 0.0f) {
            weights[0] /= sum;
            weights[1] /= sum;
            weights[2] /= sum;
            weights[3] /= sum;
        }
    }
};

class SkinnedMesh {
private:
    std::vector<Vector3f> bind_positions;
    std::vector<Vector3f> bind_normals;
    std::vector<VertexWeight> vertex_weights;

    std::vector<Vector3f> deformed_positions;
    std::vector<Vector3f> deformed_normals;

public:
    void deform(const std::vector<Matrix4f>& bone_matrices) {
        deformed_positions.resize(bind_positions.size());
        deformed_normals.resize(bind_normals.size());

        for (int i = 0; i < bind_positions.size(); ++i) {
            const Vector3f& bind_pos = bind_positions[i];
            const Vector3f& bind_normal = bind_normals[i];
            const VertexWeight& weight = vertex_weights[i];

            Vector3f deformed_pos = Vector3f::Zero();
            Vector3f deformed_normal = Vector3f::Zero();

            for (int j = 0; j < 4; ++j) {
                if (weight.weights[j] > 0.0f) {
                    int bone_index = weight.bone_indices[j];
                    const Matrix4f& bone_matrix = bone_matrices[bone_index];

                    // 变换位置
                    Vector4f pos_homogeneous(bind_pos.x(), bind_pos.y(), bind_pos.z(), 1.0f);
                    Vector4f transformed_pos = bone_matrix * pos_homogeneous;
                    deformed_pos += weight.weights[j] * transformed_pos.head<3>();

                    // 变换法向量
                    Matrix3f normal_matrix = bone_matrix.block<3,3>(0,0);
                    deformed_normal += weight.weights[j] * (normal_matrix * bind_normal);
                }
            }

            deformed_positions[i] = deformed_pos;
            deformed_normals[i] = deformed_normal.normalized();
        }
    }
};
```

**双四元数蒙皮（Dual Quaternion Skinning）**：
解决线性混合蒙皮的体积损失问题

```cpp
struct DualQuaternion {
    Quaternionf real;
    Quaternionf dual;

    DualQuaternion() : real(Quaternionf::Identity()), dual(Quaternionf(0,0,0,0)) {}

    DualQuaternion(const Matrix4f& transform) {
        // 提取旋转和平移
        Matrix3f rotation = transform.block<3,3>(0,0);
        Vector3f translation = transform.block<3,1>(0,3);

        real = Quaternionf(rotation);

        // $dual = 0.5 \times translation \times real$
        Quaternionf trans_quat(0, translation.x(), translation.y(), translation.z());
        dual = Quaternionf(0.5f * (trans_quat * real).coeffs());
    }

    DualQuaternion operator+(const DualQuaternion& other) const {
        DualQuaternion result;
        result.real = Quaternionf(real.coeffs() + other.real.coeffs());
        result.dual = Quaternionf(dual.coeffs() + other.dual.coeffs());
        return result;
    }

    DualQuaternion operator*(float scalar) const {
        DualQuaternion result;
        result.real = Quaternionf(scalar * real.coeffs());
        result.dual = Quaternionf(scalar * dual.coeffs());
        return result;
    }

    void normalize() {
        float norm = real.norm();
        real = Quaternionf(real.coeffs() / norm);
        dual = Quaternionf(dual.coeffs() / norm);
    }

    Vector3f transform_point(const Vector3f& point) const {
        // 从双四元数恢复变换并应用
        Vector3f translation = 2.0f * (dual * real.conjugate()).vec();
        return real * point + translation;
    }
};

void deform_with_dual_quaternions(const std::vector<Matrix4f>& bone_matrices) {
    for (int i = 0; i < bind_positions.size(); ++i) {
        const VertexWeight& weight = vertex_weights[i];

        DualQuaternion blended_dq;

        for (int j = 0; j < 4; ++j) {
            if (weight.weights[j] > 0.0f) {
                int bone_index = weight.bone_indices[j];
                DualQuaternion bone_dq(bone_matrices[bone_index]);

                // 确保四元数在同一半球
                if (j > 0 && blended_dq.real.dot(bone_dq.real) < 0) {
                    bone_dq = bone_dq * (-1.0f);
                }

                blended_dq = blended_dq + bone_dq * weight.weights[j];
            }
        }

        blended_dq.normalize();
        deformed_positions[i] = blended_dq.transform_point(bind_positions[i]);
    }
}
```

## 物理仿真数学基础

## 22.1 牛顿力学基础

### 22.1.1 运动学方程的数学基础

#### 基本运动量的定义

**位置、速度、加速度的数学关系**：

基本物理量定义：

位置：
$$\mathbf{x}(t) \in \mathbb{R}^3$$

速度：
$$\mathbf{v}(t) = \frac{d\mathbf{x}}{dt}$$

加速度：
$$\mathbf{a}(t) = \frac{d\mathbf{v}}{dt} = \frac{d^2\mathbf{x}}{dt^2}$$

#### 匀加速运动的解析解

**常加速度运动方程**：
当加速度 $\mathbf{a}$ 为常数时，运动方程的解析解为：

**常加速度运动方程**：

速度方程：
$$\mathbf{v}(t) = \mathbf{v}_0 + \mathbf{a}t$$

位置方程：
$$\mathbf{x}(t) = \mathbf{x}_0 + \mathbf{v}_0 t + \frac{1}{2}\mathbf{a}t^2$$

**推导过程**：
从加速度的定义出发：
$$\frac{d\mathbf{v}}{dt} = \mathbf{a}$$

积分得到：
$$\mathbf{v}(t) = \int_0^t \mathbf{a} \, d\tau + \mathbf{v}_0 = \mathbf{a}t + \mathbf{v}_0$$

再次积分：
$$\mathbf{x}(t) = \int_0^t \mathbf{v}(\tau) \, d\tau + \mathbf{x}_0 = \int_0^t (\mathbf{a}\tau + \mathbf{v}_0) \, d\tau + \mathbf{x}_0 = \frac{1}{2}\mathbf{a}t^2 + \mathbf{v}_0 t + \mathbf{x}_0$$

**代码实现**：

```cpp
struct Particle {
    Vector2D position;
    Vector2D velocity;
    Vector2D acceleration;
    Vector2D forces;
    float mass;
    bool pinned;

    void update_euler(float dt) {
        if (pinned) return;

        acceleration = forces / mass;
        velocity += acceleration * dt;
        position += velocity * dt;

        // 清除力
        forces = Vector2D(0, 0);
    }

    void update_verlet(float dt, Vector2D gravity) {
        if (pinned) return;

        Vector2D new_position = position + (position - last_position) + acceleration * dt * dt;
        last_position = position;
        position = new_position;
    }

private:
    Vector2D last_position;  // Verlet积分需要
};
```

### 22.1.2 牛顿第二定律的数学表述

#### 牛顿第二定律的向量形式

**基本形式**：
$$\mathbf{F} = m\mathbf{a}$$

其中 $\mathbf{F}$ 是作用在质量为 $m$ 的物体上的合外力，$\mathbf{a}$ 是物体的加速度。

**微分方程形式**：
$$\mathbf{F} = m\frac{d^2\mathbf{x}}{dt^2}$$

这是一个二阶常微分方程，描述了力与运动的关系。

#### 多力作用的叠加原理

**力的叠加**：
当多个力同时作用在物体上时，根据力的叠加原理：
$$\sum_{i=1}^{n} \mathbf{F}_i = m\mathbf{a}$$

因此加速度为：
$$\mathbf{a} = \frac{1}{m}\sum_{i=1}^{n} \mathbf{F}_i = \frac{\mathbf{F}_1 + \mathbf{F}_2 + \cdots + \mathbf{F}_n}{m}$$

#### 常见力的数学模型

**重力**：
$$\mathbf{F}_{gravity} = m\mathbf{g}$$

**弹性力（胡克定律）**：
$$\mathbf{F}_{spring} = -k(\|\mathbf{x} - \mathbf{x}_0\| - L_0)\frac{\mathbf{x} - \mathbf{x}_0}{\|\mathbf{x} - \mathbf{x}_0\|}$$

**阻尼力**：
$$\mathbf{F}_{damping} = -\gamma\mathbf{v}$$

其中 $\gamma$ 是阻尼系数。

**在仿真中的应用**：

```cpp
class ForceAccumulator {
private:
    Vector2D total_force;

public:
    void clear() {
        total_force = Vector2D(0, 0);
    }

    void add_force(const Vector2D& force) {
        total_force += force;
    }

    void add_gravity(float mass, const Vector2D& gravity) {
        total_force += mass * gravity;
    }

    void add_spring_force(const Vector2D& position, const Vector2D& other_position,
                         float rest_length, float spring_constant) {
        Vector2D displacement = other_position - position;
        float current_length = displacement.norm();

        if (current_length > 0) {
            Vector2D direction = displacement / current_length;
            float extension = current_length - rest_length;
            Vector2D spring_force = spring_constant * extension * direction;
            total_force += spring_force;
        }
    }

    void add_damping_force(const Vector2D& velocity, float damping_coefficient) {
        total_force -= damping_coefficient * velocity;
    }

    Vector2D get_total_force() const {
        return total_force;
    }
};
```

### 22.1.3 能量守恒

**机械能**：
$$E = K + U = \frac{1}{2}mv^2 + U(x)$$

**动能**：
$$K = \frac{1}{2}mv^2$$

**势能示例**：

- **重力势能**：$U = mgh$
- **弹性势能**：$U = \frac{1}{2}kx^2$

**能量守恒验证**：

```cpp
class EnergyMonitor {
public:
    float calculate_kinetic_energy(const std::vector<Mass*>& masses) {
        float total_ke = 0.0f;
        for (const auto& mass : masses) {
            if (!mass->pinned) {
                float speed_squared = mass->velocity.norm2();
                total_ke += 0.5f * mass->mass * speed_squared;
            }
        }
        return total_ke;
    }

    float calculate_gravitational_potential(const std::vector<Mass*>& masses,
                                          const Vector2D& gravity) {
        float total_pe = 0.0f;
        for (const auto& mass : masses) {
            // 假设重力向下，y坐标越高势能越大
            total_pe += mass->mass * (-gravity.y) * mass->position.y;
        }
        return total_pe;
    }

    float calculate_elastic_potential(const std::vector<Spring*>& springs) {
        float total_pe = 0.0f;
        for (const auto& spring : springs) {
            Vector2D displacement = spring->m2->position - spring->m1->position;
            float current_length = displacement.norm();
            float extension = current_length - spring->rest_length;
            total_pe += 0.5f * spring->k * extension * extension;
        }
        return total_pe;
    }

    float calculate_total_energy(const std::vector<Mass*>& masses,
                               const std::vector<Spring*>& springs,
                               const Vector2D& gravity) {
        return calculate_kinetic_energy(masses) +
               calculate_gravitational_potential(masses, gravity) +
               calculate_elastic_potential(springs);
    }
};
```

## 22.2 弹簧-质点系统

### 22.2.1 胡克定律

**基本形式**：
$$F = -kx$$
其中k是弹簧常数，x是形变量

**向量形式**：

```cpp
Vector2D calculate_spring_force(const Vector2D& pos1, const Vector2D& pos2,
                               float rest_length, float spring_constant) {
    Vector2D displacement = pos2 - pos1;
    float current_length = displacement.norm();

    if (current_length < EPSILON) {
        return Vector2D(0, 0);  // 避免除零
    }

    Vector2D direction = displacement / current_length;
    float extension = current_length - rest_length;

    // 胡克定律：$F = k \times 形变量 \times 方向$
    return spring_constant * extension * direction;
}
```

### 22.2.2 阻尼力

**线性阻尼**：
$$F_{damping} = -\gamma v$$

**弹簧阻尼**：

```cpp
Vector2D calculate_spring_damping(const Vector2D& vel1, const Vector2D& vel2,
                                 const Vector2D& spring_direction,
                                 float damping_coefficient) {
    // 相对速度
    Vector2D relative_velocity = vel2 - vel1;

    // 沿弹簧方向的速度分量
    float velocity_along_spring = relative_velocity.dot(spring_direction);

    // 阻尼力只作用于弹簧方向
    return -damping_coefficient * velocity_along_spring * spring_direction;
}
```

### 22.2.3 完整的弹簧-质点系统

**基于GAMES101 Assignment8的实现**：

```cpp
class Mass {
public:
    Vector2D position;
    Vector2D last_position;  // Verlet积分用
    Vector2D velocity;
    Vector2D forces;
    float mass;
    bool pinned;

    Mass(Vector2D pos, float m, bool pin = false)
        : position(pos), last_position(pos), velocity(0, 0),
          forces(0, 0), mass(m), pinned(pin) {}
};

class Spring {
public:
    Mass* m1;
    Mass* m2;
    float rest_length;
    float k;  // 弹簧常数

    Spring(Mass* mass1, Mass* mass2, float spring_constant)
        : m1(mass1), m2(mass2), k(spring_constant) {
        Vector2D displacement = m2->position - m1->position;
        rest_length = displacement.norm();
    }

    void apply_force() {
        Vector2D displacement = m2->position - m1->position;
        float current_length = displacement.norm();

        if (current_length < EPSILON) return;

        Vector2D direction = displacement / current_length;
        float extension = current_length - rest_length;
        Vector2D spring_force = k * extension * direction;

        // 牛顿第三定律：作用力与反作用力
        m1->forces += spring_force;
        m2->forces -= spring_force;
    }
};

class Rope {
private:
    std::vector<Mass*> masses;
    std::vector<Spring*> springs;

public:
    Rope(Vector2D start, Vector2D end, int num_nodes, float node_mass,
         float spring_k, std::vector<int> pinned_nodes) {

        // 创建质点
        for (int i = 0; i 光线传输的物理意义 num_nodes; ++i) {
            float t = static_cast<float>(i) / (num_nodes - 1);
            Vector2D position = start + t * (end - start);
            bool is_pinned = std::find(pinned_nodes.begin(), pinned_nodes.end(), i)
                           != pinned_nodes.end();
            masses.push_back(new Mass(position, node_mass, is_pinned));
        }

        // 创建弹簧
        for (int i = 0; i < num_nodes - 1; ++i) {
            springs.push_back(new Spring(masses[i], masses[i + 1], spring_k));
        }
    }

    void simulate_euler(float delta_t, Vector2D gravity) {
        // 1. 计算弹簧力
        for (auto& spring : springs) {
            spring->apply_force();
        }

        // 2. 更新质点
        for (auto& mass : masses) {
            if (!mass->pinned) {
                // 添加重力
                mass->forces += mass->mass * gravity;

                // 欧拉积分
                Vector2D acceleration = mass->forces / mass->mass;
                mass->velocity += acceleration * delta_t;
                mass->position += mass->velocity * delta_t;

                // 全局阻尼
                mass->velocity *= 0.99f;
            }

            // 清除力
            mass->forces = Vector2D(0, 0);
        }
    }

    void simulate_verlet(float delta_t, Vector2D gravity) {
        // 1. 计算约束力（弹簧力）
        for (auto& spring : springs) {
            // Verlet积分中，我们直接调整位置来满足约束
            Vector2D displacement = spring->m2->position - spring->m1->position;
            float current_length = displacement.norm();

            if (current_length > EPSILON) {
                Vector2D direction = displacement / current_length;
                float difference = current_length - spring->rest_length;
                Vector2D correction = 0.5f * difference * direction;

                if (!spring->m1->pinned) {
                    spring->m1->position += correction;
                }
                if (!spring->m2->pinned) {
                    spring->m2->position -= correction;
                }
            }
        }

        // 2. Verlet积分
        for (auto& mass : masses) {
            if (!mass->pinned) {
                Vector2D temp_position = mass->position;

                // Verlet公式：$x(t+dt) = 2x(t) - x(t-dt) + a \cdot dt^2$
                Vector2D acceleration = gravity;  // 只考虑重力
                mass->position = 2.0f * mass->position - mass->last_position +
                               acceleration * delta_t * delta_t;

                mass->last_position = temp_position;

                // Verlet阻尼
                mass->position = mass->position * 0.99f + mass->last_position * 0.01f;
            }
        }
    }
};
```

## 22.3 数值积分方法

### 22.3.1 显式欧拉法

**基本公式**：

```
x(t+h) = x(t) + h·v(t)
v(t+h) = v(t) + h·a(t)
```

**优缺点**：

- ✅ **优点**：简单易实现，计算量小
- ❌ **缺点**：数值不稳定，能量不守恒，大时间步长会发散

**稳定性分析**：

```cpp
// 弹簧-质点系统的稳定性条件
float calculate_max_stable_timestep(float mass, float spring_constant) {
    // 对于弹簧-质点系统：$dt < \frac{2}{\omega}$，其中$\omega = \sqrt{\frac{k}{m}}$
    float omega = std::sqrt(spring_constant / mass);
    return 2.0f / omega;
}

void adaptive_euler_integration(Rope& rope, float target_dt, Vector2D gravity) {
    float max_safe_dt = calculate_max_stable_timestep(rope.get_min_mass(),
                                                     rope.get_max_spring_constant());

    if (target_dt <= max_safe_dt) {
        rope.simulate_euler(target_dt, gravity);
    } else {
        // 分割时间步
        int substeps = static_cast<int>(std::ceil(target_dt / max_safe_dt));
        float substep_dt = target_dt / substeps;

        for (int i = 0; i < substeps; ++i) {
            rope.simulate_euler(substep_dt, gravity);
        }
    }
}
```

### 22.3.2 Verlet积分

**位置Verlet**：

```
$$x(t+h) = 2x(t) - x(t-h) + a(t)h^2$$
```

**速度Verlet**：
$$x(t+h) = x(t) + v(t)h + \frac{1}{2}a(t)h^2$$
$$v(t+h) = v(t) + \frac{1}{2}[a(t) + a(t+h)]h$$

**优势**：

- 时间可逆性
- 更好的能量守恒
- 对于约束系统更稳定

**实现细节**：

```cpp
class VerletIntegrator {
public:
    static void integrate_position(Mass& mass, float dt, const Vector2D& acceleration) {
        if (mass.pinned) return;

        Vector2D new_position = mass.position + (mass.position - mass.last_position) +
                               acceleration * dt * dt;
        mass.last_position = mass.position;
        mass.position = new_position;
    }

    static void integrate_velocity(Mass& mass, float dt, const Vector2D& old_acceleration,
                                  const Vector2D& new_acceleration) {
        if (mass.pinned) return;

        // 速度Verlet：v(t+dt) = v(t) + 0.5*[a(t) + a(t+dt)]*dt
        mass.velocity += 0.5f * (old_acceleration + new_acceleration) * dt;
    }

    static Vector2D calculate_velocity_from_positions(const Mass& mass, float dt) {
        // 从位置差分估算速度
        return (mass.position - mass.last_position) / dt;
    }
};
```

### 22.3.3 隐式积分方法

**隐式欧拉**：

```
x(t+h) = x(t) + h·v(t+h)
v(t+h) = v(t) + h·a(t+h)
```

**需要求解线性系统**：

```cpp
class ImplicitEulerSolver {
private:
    // 系统矩阵：$(M - h^2K)\Delta v = h(F + hKv)$
    // M: 质量矩阵, K: 刚度矩阵, F: 外力

public:
    void solve_implicit_step(std::vector<Mass*>& masses,
                           std::vector<Spring*>& springs,
                           float dt, const Vector2D& gravity) {
        int n = masses.size();

        // 构建系统矩阵和右端向量
        Eigen::MatrixXf system_matrix = Eigen::MatrixXf::Zero(2*n, 2*n);
        Eigen::VectorXf rhs = Eigen::VectorXf::Zero(2*n);

        // 质量矩阵部分
        for (int i = 0; i < n; ++i) {
            if (!masses[i]->pinned) {
                float mass = masses[i]->mass;
                system_matrix(2*i, 2*i) = mass;
                system_matrix(2*i+1, 2*i+1) = mass;
            }
        }

        // 刚度矩阵部分
        for (const auto& spring : springs) {
            add_spring_to_system_matrix(system_matrix, spring, dt);
        }

        // 外力
        for (int i = 0; i < n; ++i) {
            if (!masses[i]->pinned) {
                Vector2D force = masses[i]->mass * gravity;
                rhs(2*i) = dt * force.x;
                rhs(2*i+1) = dt * force.y;
            }
        }

        // 求解线性系统
        Eigen::VectorXf delta_v = system_matrix.ldlt().solve(rhs);

        // 更新速度和位置
        for (int i = 0; i < n; ++i) {
            if (!masses[i]->pinned) {
                masses[i]->velocity.x += delta_v(2*i);
                masses[i]->velocity.y += delta_v(2*i+1);
                masses[i]->position += dt * masses[i]->velocity;
            }
        }
    }

private:
    void add_spring_to_system_matrix(Eigen::MatrixXf& matrix, Spring* spring, float dt) {
        // 添加弹簧刚度到系统矩阵
        // 这里需要计算弹簧的雅可比矩阵
        // 实现细节较复杂，涉及非线性弹簧力的线性化
    }
};
```

### 22.3.4 Runge-Kutta方法

**四阶Runge-Kutta（RK4）**：

```cpp
class RungeKuttaIntegrator {
public:
    static void rk4_step(Mass& mass, float dt,
                        std::function<Vector2D(const Vector2D&, const Vector2D&)> force_function) {
        if (mass.pinned) return;

        Vector2D x0 = mass.position;
        Vector2D v0 = mass.velocity;

        // k1
        Vector2D k1_v = dt * (force_function(x0, v0) / mass.mass);
        Vector2D k1_x = dt * v0;

        // k2
        Vector2D k2_v = dt * (force_function(x0 + 0.5f * k1_x, v0 + 0.5f * k1_v) / mass.mass);
        Vector2D k2_x = dt * (v0 + 0.5f * k1_v);

        // k3
        Vector2D k3_v = dt * (force_function(x0 + 0.5f * k2_x, v0 + 0.5f * k2_v) / mass.mass);
        Vector2D k3_x = dt * (v0 + 0.5f * k2_v);

        // k4
        Vector2D k4_v = dt * (force_function(x0 + k3_x, v0 + k3_v) / mass.mass);
        Vector2D k4_x = dt * (v0 + k3_v);

        // 更新
        mass.velocity = v0 + (k1_v + 2.0f * k2_v + 2.0f * k3_v + k4_v) / 6.0f;
        mass.position = x0 + (k1_x + 2.0f * k2_x + 2.0f * k3_x + k4_x) / 6.0f;
    }
};
```

## 22.4 约束求解

### 22.4.1 位置约束

**距离约束**：
$$C(\mathbf{x}_1, \mathbf{x}_2) = \|\mathbf{x}_2 - \mathbf{x}_1\| - L = 0$$

**约束投影方法**：

```cpp
void satisfy_distance_constraint(Mass* m1, Mass* m2, float rest_length) {
    Vector2D displacement = m2->position - m1->position;
    float current_length = displacement.norm();

    if (current_length < EPSILON) return;

    Vector2D direction = displacement / current_length;
    float difference = current_length - rest_length;
    Vector2D correction = 0.5f * difference * direction;

    // 根据质量分配修正量
    float total_mass = m1->mass + m2->mass;
    float w1 = m2->mass / total_mass;  // 质量越大，修正越小
    float w2 = m1->mass / total_mass;

    if (!m1->pinned) {
        m1->position += w1 * correction;
    }
    if (!m2->pinned) {
        m2->position -= w2 * correction;
    }
}
```

### 22.4.2 Position Based Dynamics (PBD)

**基本算法流程**：

```cpp
class PBDSolver {
public:
    void simulate_step(std::vector<Mass*>& masses,
                      std::vector<Constraint*>& constraints,
                      float dt, const Vector2D& gravity) {
        // 1. 预测位置
        for (auto& mass : masses) {
            if (!mass->pinned) {
                mass->velocity += dt * gravity;
                mass->predicted_position = mass->position + dt * mass->velocity;
            }
        }

        // 2. 迭代求解约束
        for (int iter = 0; iter < solver_iterations; ++iter) {
            for (auto& constraint : constraints) {
                constraint->project(masses);
            }
        }

        // 3. 更新速度和位置
        for (auto& mass : masses) {
            if (!mass->pinned) {
                mass->velocity = (mass->predicted_position - mass->position) / dt;
                mass->position = mass->predicted_position;
            }
        }
    }

private:
    int solver_iterations = 5;
};

class DistanceConstraint : public Constraint {
private:
    int index1, index2;
    float rest_length;
    float stiffness;

public:
    void project(std::vector<Mass*>& masses) override {
        Mass* m1 = masses[index1];
        Mass* m2 = masses[index2];

        Vector2D displacement = m2->predicted_position - m1->predicted_position;
        float current_length = displacement.norm();

        if (current_length < EPSILON) return;

        Vector2D direction = displacement / current_length;
        float constraint_value = current_length - rest_length;

        // 计算修正量
        float w1 = m1->pinned ? 0.0f : 1.0f / m1->mass;
        float w2 = m2->pinned ? 0.0f : 1.0f / m2->mass;
        float lambda = -constraint_value / (w1 + w2);

        Vector2D correction1 = stiffness * lambda * w1 * direction;
        Vector2D correction2 = -stiffness * lambda * w2 * direction;

        if (!m1->pinned) {
            m1->predicted_position += correction1;
        }
        if (!m2->pinned) {
            m2->predicted_position += correction2;
        }
    }
};
```

---

## 质点弹簧系统

## 23.1 系统建模

### 23.1.1 质点弹簧系统的数学建模

#### 系统的数学描述

**状态向量**：
质点弹簧系统的状态可以用状态向量描述：
$$\mathbf{s} = \begin{pmatrix} \mathbf{x}_1 \\ \mathbf{v}_1 \\ \mathbf{x}_2 \\ \mathbf{v}_2 \\ \vdots \\ \mathbf{x}_n \\ \mathbf{v}_n \end{pmatrix} \in \mathbb{R}^{6n}$$

其中 $\mathbf{x}_i \in \mathbb{R}^3$ 是第 $i$ 个质点的位置，$\mathbf{v}_i \in \mathbb{R}^3$ 是速度。

**系统动力学方程**：
$$\frac{d\mathbf{s}}{dt} = \begin{pmatrix} \mathbf{v}_1 \\ \mathbf{a}_1 \\ \mathbf{v}_2 \\ \mathbf{a}_2 \\ \vdots \\ \mathbf{v}_n \\ \mathbf{a}_n \end{pmatrix}$$

其中加速度 $\mathbf{a}_i = \frac{\mathbf{F}_i}{m_i}$ 由牛顿第二定律确定。

#### 拓扑结构的数学表示

**邻接矩阵**：
系统的连接关系可以用邻接矩阵 $\mathbf{A} \in \{0,1\}^{n \times n}$ 表示：

邻接矩阵元素定义：

当质点 $i$ 和 $j$ 之间有弹簧连接时：$A_{ij} = 1$

其他情况：$A_{ij} = 0$

**链式结构（绳子）的数学模型**：

```cpp
class RopeTopology {
public:
    static std::vector<Spring*> create_chain(std::vector<Mass*>& masses, float k) {
        std::vector<Spring*> springs;

        for (int i = 0; i < masses.size() - 1; ++i) {
            springs.push_back(new Spring(masses[i], masses[i + 1], k));
        }

        return springs;
    }
};
```

**网格结构（布料）**：

```cpp
class ClothTopology {
public:
    static std::vector<Spring*> create_cloth_springs(
        std::vector<std::vector<Mass*>>& mass_grid, float k) {

        std::vector<Spring*> springs;
        int rows = mass_grid.size();
        int cols = mass_grid[0].size();

        // 结构弹簧（相邻质点）
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                // 水平弹簧
                if (j < cols - 1) {
                    springs.push_back(new Spring(mass_grid[i][j], mass_grid[i][j + 1], k));
                }
                // 垂直弹簧
                if (i < rows - 1) {
                    springs.push_back(new Spring(mass_grid[i][j], mass_grid[i + 1][j], k));
                }
            }
        }

        // 剪切弹簧（对角线）
        for (int i = 0; i < rows - 1; ++i) {
            for (int j = 0; j < cols - 1; ++j) {
                springs.push_back(new Spring(mass_grid[i][j], mass_grid[i + 1][j + 1], k * 0.5f));
                springs.push_back(new Spring(mass_grid[i + 1][j], mass_grid[i][j + 1], k * 0.5f));
            }
        }

        // 弯曲弹簧（跨越一个质点）
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols - 2; ++j) {
                springs.push_back(new Spring(mass_grid[i][j], mass_grid[i][j + 2], k * 0.25f));
            }
        }
        for (int i = 0; i < rows - 2; ++i) {
            for (int j = 0; j < cols; ++j) {
                springs.push_back(new Spring(mass_grid[i][j], mass_grid[i + 2][j], k * 0.25f));
            }
        }

        return springs;
    }
};
```

### 23.1.2 材料属性

**弹性模量与弹簧常数的关系**：
$$k = \frac{E \times A}{L}$$
其中E是杨氏模量，A是截面积，L是原长

**不同材料的参数**：

```cpp
struct MaterialProperties {
    float youngs_modulus;     // 杨氏模量 (Pa)
    float density;            // 密度 $(kg/m^3)$
    float poisson_ratio;      // 泊松比
    float damping_coefficient; // 阻尼系数

    static MaterialProperties steel() {
        return {200e9f, 7850.0f, 0.3f, 0.01f};
    }

    static MaterialProperties rubber() {
        return {0.01e9f, 1000.0f, 0.5f, 0.1f};
    }

    static MaterialProperties cotton() {
        return {5e9f, 1500.0f, 0.4f, 0.05f};
    }
};

float calculate_spring_constant(const MaterialProperties& material,
                               float cross_section_area, float length) {
    return (material.youngs_modulus * cross_section_area) / length;
}
```

## 23.2 高级弹簧模型

### 23.2.1 非线性弹簧

**指数弹簧模型**：

```cpp
class NonlinearSpring : public Spring {
private:
    float exponential_factor;

public:
    Vector2D calculate_force() override {
        Vector2D displacement = m2->position - m1->position;
        float current_length = displacement.norm();

        if (current_length < EPSILON) return Vector2D(0, 0);

        Vector2D direction = displacement / current_length;
        float strain = (current_length - rest_length) / rest_length;

        // 非线性力：$F = k \times strain \times \exp(\alpha \times |strain|)$
        float force_magnitude = k * strain * std::exp(exponential_factor * std::abs(strain));

        return force_magnitude * direction;
    }
};
```

**分段线性弹簧**：

```cpp
class PiecewiseLinearSpring : public Spring {
private:
    struct ForceSegment {
        float strain_start;
        float strain_end;
        float stiffness;
    };

    std::vector<ForceSegment> segments;

public:
    Vector2D calculate_force() override {
        Vector2D displacement = m2->position - m1->position;
        float current_length = displacement.norm();

        if (current_length < EPSILON) return Vector2D(0, 0);

        Vector2D direction = displacement / current_length;
        float strain = (current_length - rest_length) / rest_length;

        // 找到对应的刚度段
        float stiffness = k;  // 默认刚度
        for (const auto& segment : segments) {
            if (strain >= segment.strain_start && strain < segment.strain_end) {
                stiffness = segment.stiffness;
                break;
            }
        }

        float force_magnitude = stiffness * strain * rest_length;
        return force_magnitude * direction;
    }
};
```

### 23.2.2 弹塑性模型

**塑性变形**：

```cpp
class PlasticSpring : public Spring {
private:
    float yield_strain;      // 屈服应变
    float plastic_modulus;   // 塑性模量
    float accumulated_plastic_strain;

public:
    Vector2D calculate_force() override {
        Vector2D displacement = m2->position - m1->position;
        float current_length = displacement.norm();

        if (current_length < EPSILON) return Vector2D(0, 0);

        Vector2D direction = displacement / current_length;
        float total_strain = (current_length - rest_length) / rest_length;
        float elastic_strain = total_strain - accumulated_plastic_strain;

        // 检查是否超过屈服点
        if (std::abs(elastic_strain) > yield_strain) {
            float excess_strain = std::abs(elastic_strain) - yield_strain;
            float strain_sign = (elastic_strain > 0) ? 1.0f : -1.0f;

            // 更新塑性应变
            accumulated_plastic_strain += strain_sign * excess_strain;
            elastic_strain = strain_sign * yield_strain;
        }

        float force_magnitude = k * elastic_strain * rest_length;
        return force_magnitude * direction;
    }
};
```

## 23.3 碰撞检测与响应

### 23.3.1 质点-平面碰撞

**碰撞检测**：

```cpp
struct Plane {
    Vector2D point;
    Vector2D normal;

    float distance_to_point(const Vector2D& p) const {
        return (p - point).dot(normal);
    }
};

bool check_particle_plane_collision(const Mass& mass, const Plane& plane,
                                   float& penetration_depth) {
    float distance = plane.distance_to_point(mass.position);

    if (distance < 0) {
        penetration_depth = -distance;
        return true;
    }

    return false;
}
```

**碰撞响应**：

```cpp
void resolve_particle_plane_collision(Mass& mass, const Plane& plane,
                                     float restitution_coefficient) {
    float penetration;
    if (!check_particle_plane_collision(mass, plane, penetration)) return;

    // 位置修正
    mass.position += penetration * plane.normal;

    // 速度修正
    float velocity_normal = mass.velocity.dot(plane.normal);
    if (velocity_normal < 0) {  // 只处理朝向平面的速度
        Vector2D velocity_normal_component = velocity_normal * plane.normal;
        Vector2D velocity_tangential = mass.velocity - velocity_normal_component;

        // 法向速度反弹
        Vector2D new_velocity_normal = -restitution_coefficient * velocity_normal_component;

        // 切向摩擦
        float friction_coefficient = 0.3f;
        Vector2D friction_force = -friction_coefficient * velocity_tangential;

        mass.velocity = new_velocity_normal + velocity_tangential + friction_force;
    }
}
```

### 23.3.2 自碰撞检测

**空间哈希**：

```cpp
class SpatialHash {
private:
    float cell_size;
    std::unordered_map<int, std::vector<Mass*>> hash_table;

    int hash_position(const Vector2D& pos) {
        int x = static_cast<int>(pos.x / cell_size);
        int y = static_cast<int>(pos.y / cell_size);
        return x * 73856093 ^ y * 19349663;  // 大质数哈希
    }

public:
    void clear() {
        hash_table.clear();
    }

    void insert(Mass* mass) {
        int hash = hash_position(mass->position);
        hash_table[hash].push_back(mass);
    }

    std::vector<Mass*> query_nearby(const Vector2D& position, float radius) {
        std::vector<Mass*> nearby_masses;

        // 检查周围的9个格子
        for (int dx = -1; dx <= 1; ++dx) {
            for (int dy = -1; dy <= 1; ++dy) {
                Vector2D offset_pos = position + Vector2D(dx * cell_size, dy * cell_size);
                int hash = hash_position(offset_pos);

                auto it = hash_table.find(hash);
                if (it != hash_table.end()) {
                    for (Mass* mass : it->second) {
                        float distance = (mass->position - position).norm();
                        if (distance <= radius) {
                            nearby_masses.push_back(mass);
                        }
                    }
                }
            }
        }

        return nearby_masses;
    }
};
```

**连续碰撞检测**：

```cpp
bool continuous_collision_detection(const Mass& mass1, const Mass& mass2,
                                   float dt, float& collision_time) {
    Vector2D relative_position = mass2.position - mass1.position;
    Vector2D relative_velocity = mass2.velocity - mass1.velocity;
    float min_distance = 0.1f;  // 最小安全距离

    // 求解二次方程：$|p + v \cdot t|^2 = min\_distance^2$
    float a = relative_velocity.norm2();
    float b = 2.0f * relative_position.dot(relative_velocity);
    float c = relative_position.norm2() - min_distance * min_distance;

    float discriminant = b * b - 4 * a * c;

    if (discriminant >= 0 && a > EPSILON) {
        float t1 = (-b - std::sqrt(discriminant)) / (2 * a);
        float t2 = (-b + std::sqrt(discriminant)) / (2 * a);

        // 选择在时间步内的最早碰撞时间
        if (t1 >= 0 && t1 <= dt) {
            collision_time = t1;
            return true;
        } else if (t2 >= 0 && t2 <= dt) {
            collision_time = t2;
            return true;
        }
    }

    return false;
}
```

---

## 数值积分方法

## 24.1 稳定性分析

### 24.1.1 线性稳定性理论

#### 线性系统的稳定性分析

**线性常微分方程系统**：
考虑线性系统：
$$\frac{d\mathbf{x}}{dt} = \mathbf{A}\mathbf{x}$$

其中 $\mathbf{A} \in \mathbb{R}^{n \times n}$ 是系统矩阵。

**解析解的稳定性**：
解析解为 $\mathbf{x}(t) = e^{\mathbf{A}t}\mathbf{x}_0$，系统稳定当且仅当 $\mathbf{A}$ 的所有特征值 $\lambda_i$ 满足 $\text{Re}(\lambda_i) \leq 0$。

#### 数值方法的稳定性

**显式欧拉法的放大因子**：
显式欧拉法：$\mathbf{x}_{n+1} = \mathbf{x}_n + h\mathbf{A}\mathbf{x}_n = (\mathbf{I} + h\mathbf{A})\mathbf{x}_n$

放大因子为：$G = 1 + h\lambda$

**稳定性条件**：
数值解稳定当且仅当：
$$|1 + h\lambda| \leq 1$$

对于所有特征值 $\lambda$。

**稳定域分析**：

- **实特征值**：$\lambda \in \mathbb{R}$，稳定条件为 $-2 \leq h\lambda \leq 0$
- **复特征值**：$\lambda = \alpha + i\beta$，稳定域为复平面上以 $(-1, 0)$ 为圆心，半径为 1 的圆盘

#### 时间步长的选择

**最大稳定时间步长**：
$$h_{max} = \frac{2}{|\lambda_{max}|}$$

其中 $\lambda_{max}$ 是系统矩阵的最大特征值（按模长）。

**稳定性测试**：

```cpp
class StabilityAnalyzer {
public:
    static bool is_euler_stable(float eigenvalue_real, float eigenvalue_imag, float dt) {
        std::complex<float> lambda(eigenvalue_real, eigenvalue_imag);
        std::complex<float> amplification_factor = 1.0f + lambda * dt;
        return std::abs(amplification_factor) <= 1.0f;
    }

    static float max_stable_timestep_euler(float max_eigenvalue_magnitude) {
        // 对于实特征值：$dt < \frac{2}{|\lambda_{max}|}$
        return 2.0f / max_eigenvalue_magnitude;
    }

    static void analyze_spring_system_stability(float mass, float spring_constant) {
        float omega = std::sqrt(spring_constant / mass);
        float max_dt = 2.0f / omega;

        std::cout << "弹簧系统稳定性分析:\n";
        std::cout << "  固有频率: " << omega << " rad/s\n";
        std::cout << "  最大稳定时间步: " << max_dt << " s\n";
        std::cout << "  建议时间步: " << max_dt * 0.5f << " s\n";
    }
};
```

### 24.1.2 能量守恒性

**能量漂移监控**：

```cpp
class EnergyConservationMonitor {
private:
    float initial_energy;
    std::vector<float> energy_history;

public:
    void initialize(const std::vector<Mass*>& masses,
                   const std::vector<Spring*>& springs,
                   const Vector2D& gravity) {
        EnergyMonitor monitor;
        initial_energy = monitor.calculate_total_energy(masses, springs, gravity);
        energy_history.clear();
    }

    void record_energy(const std::vector<Mass*>& masses,
                      const std::vector<Spring*>& springs,
                      const Vector2D& gravity) {
        EnergyMonitor monitor;
        float current_energy = monitor.calculate_total_energy(masses, springs, gravity);
        energy_history.push_back(current_energy);
    }

    float calculate_energy_drift() const {
        if (energy_history.empty()) return 0.0f;

        float current_energy = energy_history.back();
        return std::abs(current_energy - initial_energy) / initial_energy;
    }

    void print_energy_statistics() const {
        if (energy_history.size() < 2) return;

        float min_energy = *std::min_element(energy_history.begin(), energy_history.end());
        float max_energy = *std::max_element(energy_history.begin(), energy_history.end());
        float energy_range = max_energy - min_energy;

        std::cout << "能量守恒统计:\n";
        std::cout << "  初始能量: " << initial_energy << "\n";
        std::cout << "  能量范围: [" << min_energy << ", " << max_energy << "]\n";
        std::cout << "  能量漂移: " << calculate_energy_drift() * 100 << "%\n";
        std::cout << "  能量振荡: " << energy_range / initial_energy * 100 << "%\n";
    }
};
```

## 24.2 自适应时间步长

### 24.2.1 误差估计

**Richardson外推法**：

```cpp
class AdaptiveTimestepper {
private:
    float tolerance;
    float min_dt;
    float max_dt;

public:
    float estimate_optimal_timestep(Rope& rope, float current_dt, const Vector2D& gravity) {
        // 保存当前状态
        auto saved_state = rope.save_state();

        // 用当前时间步积分一步
        rope.simulate_euler(current_dt, gravity);
        auto state_full_step = rope.save_state();

        // 恢复状态，用两个半步积分
        rope.restore_state(saved_state);
        rope.simulate_euler(current_dt * 0.5f, gravity);
        rope.simulate_euler(current_dt * 0.5f, gravity);
        auto state_half_steps = rope.save_state();

        // 计算误差
        float error = calculate_state_difference(state_full_step, state_half_steps);

        // 恢复原始状态
        rope.restore_state(saved_state);

        // 根据误差调整时间步
        float safety_factor = 0.8f;
        float new_dt = current_dt * safety_factor * std::pow(tolerance / error, 0.2f);

        return std::clamp(new_dt, min_dt, max_dt);
    }

private:
    float calculate_state_difference(const RopeState& state1, const RopeState& state2) {
        float max_position_diff = 0.0f;

        for (int i = 0; i < state1.positions.size(); ++i) {
            float diff = (state1.positions[i] - state2.positions[i]).norm();
            max_position_diff = std::max(max_position_diff, diff);
        }

        return max_position_diff;
    }
};
```

### 24.2.2 CFL条件

**Courant-Friedrichs-Lewy条件**：

```cpp
class CFLCondition {
public:
    static float calculate_cfl_timestep(const std::vector<Spring*>& springs,
                                       const std::vector<Mass*>& masses) {
        float min_dt = std::numeric_limits<float>::max();

        for (const auto& spring : springs) {
            // 计算弹簧的波速
            float reduced_mass = (spring->m1->mass * spring->m2->mass) /
                               (spring->m1->mass + spring->m2->mass);
            float wave_speed = std::sqrt(spring->k / reduced_mass);

            // CFL条件：dt < dx / c
            float element_length = spring->rest_length;
            float cfl_dt = element_length / wave_speed;

            min_dt = std::min(min_dt, cfl_dt);
        }

        return 0.5f * min_dt;  // 安全系数
    }

    static void print_cfl_analysis(const std::vector<Spring*>& springs,
                                  const std::vector<Mass*>& masses) {
        float cfl_dt = calculate_cfl_timestep(springs, masses);

        std::cout << "CFL稳定性分析:\n";
        std::cout << "  CFL时间步限制: " << cfl_dt << " s\n";
        std::cout << "  对应频率: " << 1.0f / cfl_dt << " Hz\n";
    }
};
```

## 24.3 高阶积分方法

### 24.3.1 多步法

**Adams-Bashforth方法**：

```cpp
class AdamsBashforthIntegrator {
private:
    std::deque<Vector2D> acceleration_history;
    int order;

public:
    AdamsBashforthIntegrator(int method_order) : order(method_order) {}

    void integrate_step(Mass& mass, float dt, const Vector2D& current_acceleration) {
        if (mass.pinned) return;

        acceleration_history.push_back(current_acceleration);

        if (acceleration_history.size() > order) {
            acceleration_history.pop_front();
        }

        Vector2D velocity_increment(0, 0);

        if (acceleration_history.size() == 1) {
            // 一阶（显式欧拉）
            velocity_increment = dt * acceleration_history[0];
        } else if (acceleration_history.size() == 2) {
            // 二阶Adams-Bashforth
            velocity_increment = dt * (1.5f * acceleration_history[1] -
                                     0.5f * acceleration_history[0]);
        } else if (acceleration_history.size() >= 3) {
            // 三阶Adams-Bashforth
            velocity_increment = dt * (23.0f/12.0f * acceleration_history[2] -
                                     16.0f/12.0f * acceleration_history[1] +
                                     5.0f/12.0f * acceleration_history[0]);
        }

        mass.velocity += velocity_increment;
        mass.position += dt * mass.velocity;
    }
};
```

### 24.3.2 预测-校正方法

**Adams-Bashforth-Moulton方法**：

```cpp
class PredictorCorrectorIntegrator {
public:
    void integrate_step(Mass& mass, float dt,
                       std::function<Vector2D(const Mass&)> force_function) {
        if (mass.pinned) return;

        // 预测步（Adams-Bashforth）
        Vector2D current_acceleration = force_function(mass) / mass.mass;
        Vector2D predicted_velocity = mass.velocity + dt * current_acceleration;
        Vector2D predicted_position = mass.position + dt * predicted_velocity;

        // 创建预测状态
        Mass predicted_mass = mass;
        predicted_mass.position = predicted_position;
        predicted_mass.velocity = predicted_velocity;

        // 校正步（Adams-Moulton）
        Vector2D predicted_acceleration = force_function(predicted_mass) / mass.mass;
        Vector2D corrected_velocity = mass.velocity +
            0.5f * dt * (current_acceleration + predicted_acceleration);
        Vector2D corrected_position = mass.position +
            0.5f * dt * (mass.velocity + corrected_velocity);

        mass.velocity = corrected_velocity;
        mass.position = corrected_position;
    }
};
```

## 24.4 专用物理积分器

### 24.4.1 辛积分器

**Störmer-Verlet方法**：

```cpp
class SymplecticIntegrator {
public:
    // 保持哈密顿系统的辛结构
    static void stormer_verlet_step(Mass& mass, float dt,
                                   std::function<Vector2D(const Vector2D&)> force_function) {
        if (mass.pinned) return;

        // 位置半步更新
        mass.position += 0.5f * dt * mass.velocity;

        // 计算新位置的力
        Vector2D force = force_function(mass.position);
        Vector2D acceleration = force / mass.mass;

        // 速度全步更新
        mass.velocity += dt * acceleration;

        // 位置半步更新
        mass.position += 0.5f * dt * mass.velocity;
    }

    // Leapfrog方法（等价于Störmer-Verlet）
    static void leapfrog_step(Mass& mass, float dt,
                             std::function<Vector2D(const Vector2D&)> force_function) {
        if (mass.pinned) return;

        // 速度在半时间步更新
        Vector2D force = force_function(mass.position);
        Vector2D acceleration = force / mass.mass;
        mass.velocity += 0.5f * dt * acceleration;

        // 位置全时间步更新
        mass.position += dt * mass.velocity;

        // 计算新位置的力并完成速度更新
        force = force_function(mass.position);
        acceleration = force / mass.mass;
        mass.velocity += 0.5f * dt * acceleration;
    }
};
```

### 24.4.2 约束保持积分器

**SHAKE算法**：

```cpp
class SHAKEIntegrator {
private:
    float tolerance;
    int max_iterations;

public:
    void integrate_with_constraints(std::vector<Mass*>& masses,
                                   std::vector<DistanceConstraint*>& constraints,
                                   float dt, const Vector2D& gravity) {
        // 1. 无约束的Verlet步
        for (auto& mass : masses) {
            if (!mass->pinned) {
                Vector2D acceleration = gravity;
                Vector2D new_position = 2.0f * mass->position - mass->last_position +
                                       acceleration * dt * dt;
                mass->last_position = mass->position;
                mass->position = new_position;
            }
        }

        // 2. 迭代满足约束
        for (int iter = 0; iter < max_iterations; ++iter) {
            bool converged = true;

            for (auto& constraint : constraints) {
                float constraint_error = constraint->evaluate(masses);

                if (std::abs(constraint_error) > tolerance) {
                    converged = false;
                    constraint->apply_correction(masses, dt);
                }
            }

            if (converged) break;
        }

        // 3. 更新速度
        for (auto& mass : masses) {
            if (!mass->pinned) {
                mass->velocity = (mass->position - mass->last_position) / dt;
            }
        }
    }
};

class DistanceConstraint {
private:
    int index1, index2;
    float target_distance;

public:
    float evaluate(const std::vector<Mass*>& masses) {
        Vector2D displacement = masses[index2]->position - masses[index1]->position;
        float current_distance = displacement.norm();
        return current_distance - target_distance;
    }

    void apply_correction(std::vector<Mass*>& masses, float dt) {
        Mass* m1 = masses[index1];
        Mass* m2 = masses[index2];

        Vector2D displacement = m2->position - m1->position;
        float current_distance = displacement.norm();

        if (current_distance < EPSILON) return;

        Vector2D direction = displacement / current_distance;
        float constraint_error = current_distance - target_distance;

        // 计算拉格朗日乘数
        float w1 = m1->pinned ? 0.0f : 1.0f / m1->mass;
        float w2 = m2->pinned ? 0.0f : 1.0f / m2->mass;
        float lambda = -constraint_error / (w1 + w2);

        // 应用位置修正
        Vector2D correction1 = lambda * w1 * direction;
        Vector2D correction2 = -lambda * w2 * direction;

        if (!m1->pinned) m1->position += correction1;
        if (!m2->pinned) m2->position += correction2;
    }
};
```

这个完整的数值积分框架为物理仿真提供了坚实的数学基础，确保了仿真的稳定性和精度。

---

## 实时渲染优化技术

## 25.1 层次细节(LOD)技术

### 25.1.1 LOD的数学基础

**距离基础LOD**：
$$LOD_{level} = \left\lfloor \log_2\left(\frac{distance}{base\_distance}\right) \right\rfloor$$

其中：

- $distance$ 是物体到相机的距离
- $base\_distance$ 是基准距离
- $LOD_{level}$ 是细节层次等级

**屏幕空间误差度量**：
$$error_{screen} = \frac{error_{world} \times focal\_length}{distance \times pixel\_size}$$

### 25.1.2 几何LOD实现

```cpp
class GeometricLOD {
private:
    struct LODLevel {
        Mesh mesh;
        float distance_threshold;
        int triangle_count;
        float geometric_error;
    };

    std::vector<LODLevel> lod_levels;

public:
    void generate_lod_chain(const Mesh& original_mesh, int num_levels) {
        lod_levels.clear();
        lod_levels.resize(num_levels);

        // 原始网格作为LOD 0
        lod_levels[0] = {original_mesh, 0.0f,
                        original_mesh.triangle_count(), 0.0f};

        // 生成简化版本
        for (int i = 1; i < num_levels; ++i) {
            float reduction_ratio = std::pow(0.5f, i);
            lod_levels[i].mesh = simplify_mesh(original_mesh, reduction_ratio);
            lod_levels[i].distance_threshold = calculate_distance_threshold(i);
            lod_levels[i].triangle_count = lod_levels[i].mesh.triangle_count();
            lod_levels[i].geometric_error = calculate_geometric_error(
                original_mesh, lod_levels[i].mesh);
        }
    }

    const Mesh& select_lod(const Vector3f& camera_pos, const Vector3f& object_pos) {
        float distance = (camera_pos - object_pos).norm();

        for (int i = lod_levels.size() - 1; i >= 0; --i) {
            if (distance >= lod_levels[i].distance_threshold) {
                return lod_levels[i].mesh;
            }
        }

        return lod_levels[0].mesh;  // 最高细节
    }

private:
    Mesh simplify_mesh(const Mesh& mesh, float reduction_ratio) {
        // 使用二次误差度量进行网格简化
        QuadricErrorMetrics qem(mesh);
        return qem.simplify(reduction_ratio);
    }

    float calculate_distance_threshold(int lod_level) {
        // 基于屏幕空间误差的距离阈值
        float base_distance = 10.0f;
        return base_distance * std::pow(2.0f, lod_level);
    }

    float calculate_geometric_error(const Mesh& original, const Mesh& simplified) {
        // 计算Hausdorff距离作为几何误差
        float max_error = 0.0f;

        for (const auto& vertex : simplified.vertices) {
            float min_distance = std::numeric_limits<float>::max();

            for (const auto& orig_vertex : original.vertices) {
                float distance = (vertex.position - orig_vertex.position).norm();
                min_distance = std::min(min_distance, distance);
            }

            max_error = std::max(max_error, min_distance);
        }

        return max_error;
    }
};
```

## 25.2 遮挡剔除技术

### 25.2.1 视锥体剔除

**平面方程**：
$$ax + by + cz + d = 0$$

**点到平面距离**：
$$distance = \frac{|ax_0 + by_0 + cz_0 + d|}{\sqrt{a^2 + b^2 + c^2}}$$

```cpp
class FrustumCuller {
private:
    struct Plane {
        Vector3f normal;
        float distance;

        float distance_to_point(const Vector3f& point) const {
            return normal.dot(point) + distance;
        }

        bool is_point_inside(const Vector3f& point) const {
            return distance_to_point(point) >= 0;
        }
    };

    std::array<Plane, 6> frustum_planes;  // 左右上下远近

public:
    void extract_frustum_planes(const Matrix4f& view_projection_matrix) {
        // 从MVP矩阵提取视锥体平面
        Matrix4f mvp = view_projection_matrix.transpose();

        // 左平面: mvp.row(3) + mvp.row(0)
        frustum_planes[0] = extract_plane(mvp.row(3) + mvp.row(0));

        // 右平面: mvp.row(3) - mvp.row(0)
        frustum_planes[1] = extract_plane(mvp.row(3) - mvp.row(0));

        // 下平面: mvp.row(3) + mvp.row(1)
        frustum_planes[2] = extract_plane(mvp.row(3) + mvp.row(1));

        // 上平面: mvp.row(3) - mvp.row(1)
        frustum_planes[3] = extract_plane(mvp.row(3) - mvp.row(1));

        // 近平面: mvp.row(3) + mvp.row(2)
        frustum_planes[4] = extract_plane(mvp.row(3) + mvp.row(2));

        // 远平面: mvp.row(3) - mvp.row(2)
        frustum_planes[5] = extract_plane(mvp.row(3) - mvp.row(2));
    }

    bool is_aabb_visible(const AABB& aabb) const {
        for (const auto& plane : frustum_planes) {
            // 计算AABB的正顶点（最远点）
            Vector3f positive_vertex = aabb.min;

            if (plane.normal.x() >= 0) positive_vertex.x() = aabb.max.x();
            if (plane.normal.y() >= 0) positive_vertex.y() = aabb.max.y();
            if (plane.normal.z() >= 0) positive_vertex.z() = aabb.max.z();

            // 如果正顶点在平面外侧，则AABB完全在视锥体外
            if (plane.distance_to_point(positive_vertex) < 0) {
                return false;
            }
        }

        return true;
    }

    bool is_sphere_visible(const Vector3f& center, float radius) const {
        for (const auto& plane : frustum_planes) {
            if (plane.distance_to_point(center) < -radius) {
                return false;
            }
        }

        return true;
    }

private:
    Plane extract_plane(const Vector4f& plane_coeffs) {
        Vector3f normal = plane_coeffs.head<3>();
        float length = normal.norm();

        return {normal / length, plane_coeffs.w() / length};
    }
};
```

### 25.2.2 遮挡查询

```cpp
class OcclusionCuller {
private:
    struct OcclusionQuery {
        GLuint query_id;
        bool result_available;
        GLuint sample_count;

        OcclusionQuery() {
            glGenQueries(1, &query_id);
            result_available = false;
            sample_count = 0;
        }

        ~OcclusionQuery() {
            glDeleteQueries(1, &query_id);
        }
    };

    std::unordered_map<uint32_t, std::unique_ptr<OcclusionQuery>> queries;

public:
    void begin_occlusion_test(uint32_t object_id) {
        auto& query = get_or_create_query(object_id);

        // 开始遮挡查询
        glBeginQuery(GL_SAMPLES_PASSED, query->query_id);

        // 禁用颜色和深度写入，只测试遮挡
        glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
        glDepthMask(GL_FALSE);
    }

    void end_occlusion_test(uint32_t object_id) {
        glEndQuery(GL_SAMPLES_PASSED);

        // 恢复渲染状态
        glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
        glDepthMask(GL_TRUE);

        auto& query = queries[object_id];
        query->result_available = false;
    }

    bool is_object_visible(uint32_t object_id, float visibility_threshold = 0.0f) {
        auto it = queries.find(object_id);
        if (it == queries.end()) {
            return true;  // 默认可见
        }

        auto& query = it->second;

        if (!query->result_available) {
            GLint available;
            glGetQueryObjectiv(query->query_id, GL_QUERY_RESULT_AVAILABLE, &available);

            if (available) {
                glGetQueryObjectuiv(query->query_id, GL_QUERY_RESULT, &query->sample_count);
                query->result_available = true;
            } else {
                return true;  // 结果未准备好，假设可见
            }
        }

        return query->sample_count > visibility_threshold;
    }

private:
    std::unique_ptr<OcclusionQuery>& get_or_create_query(uint32_t object_id) {
        auto it = queries.find(object_id);
        if (it == queries.end()) {
            queries[object_id] = std::make_unique<OcclusionQuery>();
        }
        return queries[object_id];
    }
};
```

## 25.3 GPU性能优化

### 25.3.1 批处理优化

```cpp
class BatchRenderer {
private:
    struct BatchData {
        std::vector<Matrix4f> model_matrices;
        std::vector<Vector4f> colors;
        std::vector<Vector2f> texture_coords;
        GLuint vao, vbo, instance_vbo;
        int instance_count;

        BatchData() : instance_count(0) {
            glGenVertexArrays(1, &vao);
            glGenBuffers(1, &vbo);
            glGenBuffers(1, &instance_vbo);
        }

        ~BatchData() {
            glDeleteVertexArrays(1, &vao);
            glDeleteBuffers(1, &vbo);
            glDeleteBuffers(1, &instance_vbo);
        }
    };

    std::unordered_map<uint32_t, std::unique_ptr<BatchData>> batches;

public:
    void add_instance(uint32_t batch_id, const Matrix4f& model_matrix,
                     const Vector4f& color, const Vector2f& tex_coord) {
        auto& batch = get_or_create_batch(batch_id);

        batch->model_matrices.push_back(model_matrix);
        batch->colors.push_back(color);
        batch->texture_coords.push_back(tex_coord);
        batch->instance_count++;
    }

    void render_batch(uint32_t batch_id, const Mesh& mesh, const Shader& shader) {
        auto it = batches.find(batch_id);
        if (it == batches.end() || it->second->instance_count == 0) {
            return;
        }

        auto& batch = it->second;

        // 更新实例数据
        update_instance_buffer(*batch);

        // 绑定VAO和设置顶点属性
        glBindVertexArray(batch->vao);
        setup_vertex_attributes(mesh, *batch);

        // 使用着色器
        shader.use();

        // 实例化渲染
        glDrawElementsInstanced(GL_TRIANGLES, mesh.index_count(),
                               GL_UNSIGNED_INT, 0, batch->instance_count);

        // 清空批次数据
        clear_batch(*batch);
    }

private:
    std::unique_ptr<BatchData>& get_or_create_batch(uint32_t batch_id) {
        auto it = batches.find(batch_id);
        if (it == batches.end()) {
            batches[batch_id] = std::make_unique<BatchData>();
        }
        return batches[batch_id];
    }

    void update_instance_buffer(BatchData& batch) {
        glBindBuffer(GL_ARRAY_BUFFER, batch.instance_vbo);

        // 计算总数据大小
        size_t matrix_size = batch.model_matrices.size() * sizeof(Matrix4f);
        size_t color_size = batch.colors.size() * sizeof(Vector4f);
        size_t texcoord_size = batch.texture_coords.size() * sizeof(Vector2f);
        size_t total_size = matrix_size + color_size + texcoord_size;

        // 分配缓冲区
        glBufferData(GL_ARRAY_BUFFER, total_size, nullptr, GL_DYNAMIC_DRAW);

        // 上传数据
        glBufferSubData(GL_ARRAY_BUFFER, 0, matrix_size, batch.model_matrices.data());
        glBufferSubData(GL_ARRAY_BUFFER, matrix_size, color_size, batch.colors.data());
        glBufferSubData(GL_ARRAY_BUFFER, matrix_size + color_size, texcoord_size,
                       batch.texture_coords.data());
    }

    void setup_vertex_attributes(const Mesh& mesh, const BatchData& batch) {
        // 设置网格顶点属性
        mesh.bind_vertex_attributes();

        // 设置实例属性
        size_t matrix_size = batch.model_matrices.size() * sizeof(Matrix4f);
        size_t color_size = batch.colors.size() * sizeof(Vector4f);

        glBindBuffer(GL_ARRAY_BUFFER, batch.instance_vbo);

        // 模型矩阵（4个vec4）
        for (int i = 0; i < 4; ++i) {
            glEnableVertexAttribArray(3 + i);
            glVertexAttribPointer(3 + i, 4, GL_FLOAT, GL_FALSE, sizeof(Matrix4f),
                                 (void*)(i * sizeof(Vector4f)));
            glVertexAttribDivisor(3 + i, 1);
        }

        // 颜色
        glEnableVertexAttribArray(7);
        glVertexAttribPointer(7, 4, GL_FLOAT, GL_FALSE, sizeof(Vector4f),
                             (void*)matrix_size);
        glVertexAttribDivisor(7, 1);

        // 纹理坐标
        glEnableVertexAttribArray(8);
        glVertexAttribPointer(8, 2, GL_FLOAT, GL_FALSE, sizeof(Vector2f),
                             (void*)(matrix_size + color_size));
        glVertexAttribDivisor(8, 1);
    }

    void clear_batch(BatchData& batch) {
        batch.model_matrices.clear();
        batch.colors.clear();
        batch.texture_coords.clear();
        batch.instance_count = 0;
    }
};
```

---

## 基于物理的渲染(PBR)

## 26.1 PBR理论基础

### 26.1.1 渲染方程

**完整渲染方程**：
$$L_o(p, \omega_o) = L_e(p, \omega_o) + \int_{\Omega} f_r(p, \omega_i, \omega_o) L_i(p, \omega_i) (\omega_i \cdot n) d\omega_i$$

其中：

- $L_o(p, \omega_o)$ 是从点p向方向$\omega_o$的出射辐射度
- $L_e(p, \omega_o)$ 是自发光
- $f_r(p, \omega_i, \omega_o)$ 是双向反射分布函数(BRDF)
- $L_i(p, \omega_i)$ 是入射辐射度
- $(\omega_i \cdot n)$ 是Lambert余弦定律

### 26.1.2 BRDF模型

**Cook-Torrance BRDF**：
$$f_r = k_d f_{lambert} + k_s f_{cook-torrance}$$

其中：
$$f_{lambert} = \frac{c}{\pi}$$
$$f_{cook-torrance} = \frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)}$$

**法线分布函数(D)**：
$$D_{GGX}(n, h, \alpha) = \frac{\alpha^2}{\pi((n \cdot h)^2(\alpha^2 - 1) + 1)^2}$$

**几何函数(G)**：
$$G(n, v, l, k) = G_1(n, v, k) G_1(n, l, k)$$
$$G_1(n, v, k) = \frac{n \cdot v}{(n \cdot v)(1 - k) + k}$$

**菲涅尔项(F)**：
$$F_{Schlick}(h, v, F_0) = F_0 + (1 - F_0)(1 - (h \cdot v))^5$$

```cpp
class PBRMaterial {
private:
    Vector3f albedo;
    float metallic;
    float roughness;
    float ao;  // 环境遮挡
    Vector3f F0;  // 基础反射率

public:
    PBRMaterial(const Vector3f& albedo, float metallic, float roughness, float ao = 1.0f)
        : albedo(albedo), metallic(metallic), roughness(roughness), ao(ao) {
        // 计算基础反射率
        F0 = Vector3f(0.04f, 0.04f, 0.04f);  // 非金属默认值
        F0 = F0 * (1.0f - metallic) + albedo * metallic;
    }

    Vector3f evaluate_brdf(const Vector3f& light_dir, const Vector3f& view_dir,
                          const Vector3f& normal) const {
        Vector3f h = (light_dir + view_dir).normalized();

        float NdotV = std::max(normal.dot(view_dir), 0.0f);
        float NdotL = std::max(normal.dot(light_dir), 0.0f);
        float HdotV = std::max(h.dot(view_dir), 0.0f);
        float NdotH = std::max(normal.dot(h), 0.0f);

        // 法线分布函数 (GGX/Trowbridge-Reitz)
        float D = distribution_ggx(NdotH, roughness);

        // 几何函数
        float G = geometry_smith(normal, view_dir, light_dir, roughness);

        // 菲涅尔项
        Vector3f F = fresnel_schlick(HdotV, F0);

        // Cook-Torrance BRDF
        Vector3f numerator = D * G * F;
        float denominator = 4.0f * NdotV * NdotL + 0.0001f;  // 防止除零
        Vector3f specular = numerator / denominator;

        // 漫反射部分
        Vector3f kS = F;
        Vector3f kD = Vector3f(1.0f, 1.0f, 1.0f) - kS;
        kD *= 1.0f - metallic;  // 金属没有漫反射

        Vector3f diffuse = kD * albedo / M_PI;

        return (diffuse + specular) * NdotL;
    }

private:
    float distribution_ggx(float NdotH, float roughness) const {
        float a = roughness * roughness;
        float a2 = a * a;
        float NdotH2 = NdotH * NdotH;

        float num = a2;
        float denom = (NdotH2 * (a2 - 1.0f) + 1.0f);
        denom = M_PI * denom * denom;

        return num / denom;
    }

    float geometry_schlick_ggx(float NdotV, float roughness) const {
        float r = (roughness + 1.0f);
        float k = (r * r) / 8.0f;

        float num = NdotV;
        float denom = NdotV * (1.0f - k) + k;

        return num / denom;
    }

    float geometry_smith(const Vector3f& N, const Vector3f& V,
                        const Vector3f& L, float roughness) const {
        float NdotV = std::max(N.dot(V), 0.0f);
        float NdotL = std::max(N.dot(L), 0.0f);
        float ggx2 = geometry_schlick_ggx(NdotV, roughness);
        float ggx1 = geometry_schlick_ggx(NdotL, roughness);

        return ggx1 * ggx2;
    }

    Vector3f fresnel_schlick(float cosTheta, const Vector3f& F0) const {
        return F0 + (Vector3f(1.0f, 1.0f, 1.0f) - F0) *
               std::pow(std::clamp(1.0f - cosTheta, 0.0f, 1.0f), 5.0f);
    }
};
```

## 26.2 基于图像的光照(IBL)

### 26.2.1 环境贴图

```cpp
class IBLRenderer {
private:
    GLuint environment_map;
    GLuint irradiance_map;
    GLuint prefilter_map;
    GLuint brdf_lut;

public:
    void setup_ibl(const std::string& hdr_path) {
        // 加载HDR环境贴图
        load_hdr_environment(hdr_path);

        // 生成辐照度贴图
        generate_irradiance_map();

        // 生成预过滤环境贴图
        generate_prefilter_map();

        // 生成BRDF查找表
        generate_brdf_lut();
    }

    Vector3f sample_environment_lighting(const Vector3f& normal, const Vector3f& view_dir,
                                        const PBRMaterial& material) const {
        Vector3f reflection = reflect(-view_dir, normal);

        // 漫反射部分：从辐照度贴图采样
        Vector3f irradiance = sample_irradiance_map(normal);
        Vector3f diffuse = irradiance * material.get_albedo();

        // 镜面反射部分：从预过滤贴图采样
        float roughness = material.get_roughness();
        Vector3f prefiltered_color = sample_prefilter_map(reflection, roughness);

        // BRDF积分
        float NdotV = std::max(normal.dot(view_dir), 0.0f);
        Vector2f brdf_sample = sample_brdf_lut(NdotV, roughness);
        Vector3f F0 = material.get_F0();
        Vector3f specular = prefiltered_color * (F0 * brdf_sample.x() + brdf_sample.y());

        // 组合结果
        Vector3f kS = fresnel_schlick_roughness(NdotV, F0, roughness);
        Vector3f kD = Vector3f(1.0f, 1.0f, 1.0f) - kS;
        kD *= 1.0f - material.get_metallic();

        return kD * diffuse + specular;
    }

private:
    void load_hdr_environment(const std::string& path) {
        // 加载HDR图像
        int width, height, channels;
        float* data = stbi_loadf(path.c_str(), &width, &height, &channels, 0);

        if (data) {
            glGenTextures(1, &environment_map);
            glBindTexture(GL_TEXTURE_2D, environment_map);
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, width, height, 0, GL_RGB, GL_FLOAT, data);

            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

            stbi_image_free(data);
        }
    }

    void generate_irradiance_map() {
        // 创建立方体贴图
        glGenTextures(1, &irradiance_map);
        glBindTexture(GL_TEXTURE_CUBE_MAP, irradiance_map);

        for (unsigned int i = 0; i < 6; ++i) {
            glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB16F,
                        32, 32, 0, GL_RGB, GL_FLOAT, nullptr);
        }

        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

        // 使用计算着色器或渲染到立方体贴图的方式生成辐照度贴图
        render_irradiance_convolution();
    }

    void generate_prefilter_map() {
        glGenTextures(1, &prefilter_map);
        glBindTexture(GL_TEXTURE_CUBE_MAP, prefilter_map);

        for (unsigned int i = 0; i < 6; ++i) {
            glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB16F,
                        128, 128, 0, GL_RGB, GL_FLOAT, nullptr);
        }

        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

        glGenerateMipmap(GL_TEXTURE_CUBE_MAP);

        // 为每个mip级别渲染不同粗糙度的预过滤贴图
        render_prefilter_convolution();
    }

    void generate_brdf_lut() {
        glGenTextures(1, &brdf_lut);
        glBindTexture(GL_TEXTURE_2D, brdf_lut);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RG16F, 512, 512, 0, GL_RG, GL_FLOAT, 0);

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

        // 渲染BRDF积分查找表
        render_brdf_integration();
    }

    Vector3f fresnel_schlick_roughness(float cosTheta, const Vector3f& F0, float roughness) const {
        return F0 + (std::max(Vector3f(1.0f - roughness, 1.0f - roughness, 1.0f - roughness), F0) - F0) *
               std::pow(std::clamp(1.0f - cosTheta, 0.0f, 1.0f), 5.0f);
    }
};
```

---

## 体积渲染与参与介质

## 27.1 体积渲染理论

### 27.1.1 体积渲染方程

**体积渲染积分方程**：
$$L(x, \omega) = \int_0^d T(x, x + t\omega) \sigma_s(x + t\omega) \int_{4\pi} p(x + t\omega, \omega', \omega) L(x + t\omega, \omega') d\omega' dt + T(x, x + d\omega) L(x + d\omega, \omega)$$

其中：

- $T(x, y)$ 是透射率函数
- $\sigma_s$ 是散射系数
- $p(\omega', \omega)$ 是相位函数
- $d$ 是光线传播距离

**透射率函数**：
$$T(x, y) = \exp\left(-\int_0^{||y-x||} \sigma_t(x + s \cdot \frac{y-x}{||y-x||}) ds\right)$$

**相位函数(Henyey-Greenstein)**：
$$p(\cos\theta) = \frac{1 - g^2}{4\pi(1 + g^2 - 2g\cos\theta)^{3/2}}$$

其中$g \in [-1, 1]$是各向异性参数。

```cpp
class VolumeRenderer {
private:
    struct VolumeProperties {
        float density;           // 密度
        float absorption;        // 吸收系数
        float scattering;        // 散射系数
        float anisotropy;        // 各向异性参数g
        Vector3f albedo;         // 散射反照率

        float extinction() const { return absorption + scattering; }
    };

    struct VolumeData {
        std::vector<float> density_grid;
        int width, height, depth;
        Vector3f bounds_min, bounds_max;

        float sample_density(const Vector3f& pos) const {
            // 三线性插值采样密度
            Vector3f normalized_pos = (pos - bounds_min).cwiseQuotient(bounds_max - bounds_min);

            if (normalized_pos.x() < 0 || normalized_pos.x() > 1 ||
                normalized_pos.y() < 0 || normalized_pos.y() > 1 ||
                normalized_pos.z() < 0 || normalized_pos.z() > 1) {
                return 0.0f;
            }

            return trilinear_interpolate(normalized_pos);
        }

    private:
        float trilinear_interpolate(const Vector3f& pos) const {
            float x = pos.x() * (width - 1);
            float y = pos.y() * (height - 1);
            float z = pos.z() * (depth - 1);

            int x0 = static_cast<int>(x), x1 = std::min(x0 + 1, width - 1);
            int y0 = static_cast<int>(y), y1 = std::min(y0 + 1, height - 1);
            int z0 = static_cast<int>(z), z1 = std::min(z0 + 1, depth - 1);

            float fx = x - x0, fy = y - y0, fz = z - z0;

            auto get_density = [this](int x, int y, int z) {
                return density_grid[z * width * height + y * width + x];
            };

            // 三线性插值
            float c000 = get_density(x0, y0, z0);
            float c001 = get_density(x0, y0, z1);
            float c010 = get_density(x0, y1, z0);
            float c011 = get_density(x0, y1, z1);
            float c100 = get_density(x1, y0, z0);
            float c101 = get_density(x1, y0, z1);
            float c110 = get_density(x1, y1, z0);
            float c111 = get_density(x1, y1, z1);

            float c00 = c000 * (1 - fx) + c100 * fx;
            float c01 = c001 * (1 - fx) + c101 * fx;
            float c10 = c010 * (1 - fx) + c110 * fx;
            float c11 = c011 * (1 - fx) + c111 * fx;

            float c0 = c00 * (1 - fy) + c10 * fy;
            float c1 = c01 * (1 - fy) + c11 * fy;

            return c0 * (1 - fz) + c1 * fz;
        }
    };

    VolumeData volume_data;
    VolumeProperties volume_props;

public:
    Vector3f render_volume_ray(const Ray& ray, float t_min, float t_max,
                              const std::vector<Light>& lights) const {
        Vector3f color(0, 0, 0);
        float transmittance = 1.0f;

        // 光线步进参数
        float step_size = 0.1f;
        int num_steps = static_cast<int>((t_max - t_min) / step_size);

        for (int i = 0; i < num_steps; ++i) {
            float t = t_min + i * step_size;
            Vector3f pos = ray.origin + t * ray.direction;

            // 采样体积密度
            float density = volume_data.sample_density(pos);
            if (density <= 0.0f) continue;

            // 计算体积属性
            float extinction = volume_props.extinction() * density;
            float scattering = volume_props.scattering * density;

            // 计算透射率衰减
            float step_transmittance = std::exp(-extinction * step_size);

            // 计算散射光照
            Vector3f scattered_light = calculate_in_scattering(pos, -ray.direction, lights, density);

            // 累积颜色
            color += transmittance * (1.0f - step_transmittance) * scattered_light;

            // 更新透射率
            transmittance *= step_transmittance;

            // 早期终止优化
            if (transmittance < 0.01f) break;
        }

        return color;
    }

private:
    Vector3f calculate_in_scattering(const Vector3f& pos, const Vector3f& view_dir,
                                   const std::vector<Light>& lights, float density) const {
        Vector3f scattered_light(0, 0, 0);

        for (const auto& light : lights) {
            Vector3f light_dir = (light.position - pos).normalized();
            float light_distance = (light.position - pos).norm();

            // 计算到光源的透射率
            float light_transmittance = calculate_transmittance(pos, light.position);

            // 相位函数
            float cos_theta = view_dir.dot(light_dir);
            float phase = henyey_greenberg_phase(cos_theta, volume_props.anisotropy);

            // 光照衰减
            float attenuation = 1.0f / (light_distance * light_distance);

            // 散射贡献
            Vector3f light_contribution = light.color * light.intensity * attenuation *
                                        light_transmittance * phase * volume_props.scattering * density;

            scattered_light += light_contribution * volume_props.albedo;
        }

        return scattered_light;
    }

    float calculate_transmittance(const Vector3f& start, const Vector3f& end) const {
        Vector3f direction = (end - start).normalized();
        float distance = (end - start).norm();

        float transmittance = 1.0f;
        float step_size = 0.1f;
        int num_steps = static_cast<int>(distance / step_size);

        for (int i = 0; i < num_steps; ++i) {
            float t = i * step_size;
            Vector3f pos = start + t * direction;

            float density = volume_data.sample_density(pos);
            float extinction = volume_props.extinction() * density;

            transmittance *= std::exp(-extinction * step_size);

            if (transmittance < 0.01f) break;
        }

        return transmittance;
    }

    float henyey_greenberg_phase(float cos_theta, float g) const {
        float g2 = g * g;
        float denom = 1.0f + g2 - 2.0f * g * cos_theta;
        return (1.0f - g2) / (4.0f * M_PI * std::pow(denom, 1.5f));
    }
};
```

## 27.2 云渲染

```cpp
class CloudRenderer {
private:
    struct CloudLayer {
        float altitude_min, altitude_max;
        float density_multiplier;
        float coverage;
        Vector2f wind_direction;
        float wind_speed;

        // 噪声参数
        float noise_scale;
        float detail_scale;
        int octaves;
    };

    std::vector<CloudLayer> cloud_layers;
    GLuint noise_texture_3d;
    GLuint weather_texture;

public:
    void setup_cloud_system() {
        // 生成3D噪声纹理
        generate_3d_noise_texture();

        // 生成天气贴图
        generate_weather_texture();

        // 设置云层
        setup_cloud_layers();
    }

    Vector4f render_clouds(const Ray& ray, float t_min, float t_max,
                          const Vector3f& sun_direction) const {
        Vector3f color(0, 0, 0);
        float alpha = 0.0f;

        // 光线步进
        float step_size = 100.0f;  // 云渲染使用较大步长
        int num_steps = static_cast<int>((t_max - t_min) / step_size);

        for (int i = 0; i < num_steps; ++i) {
            float t = t_min + i * step_size;
            Vector3f pos = ray.origin + t * ray.direction;

            // 采样云密度
            float cloud_density = sample_cloud_density(pos);
            if (cloud_density <= 0.0f) continue;

            // 计算光照
            Vector3f light_color = calculate_cloud_lighting(pos, sun_direction, cloud_density);

            // 透明度混合
            float step_alpha = 1.0f - std::exp(-cloud_density * step_size * 0.01f);
            color += (1.0f - alpha) * step_alpha * light_color;
            alpha += (1.0f - alpha) * step_alpha;

            // 早期终止
            if (alpha > 0.99f) break;
        }

        return Vector4f(color.x(), color.y(), color.z(), alpha);
    }

private:
    float sample_cloud_density(const Vector3f& pos) const {
        float total_density = 0.0f;

        for (const auto& layer : cloud_layers) {
            if (pos.y() < layer.altitude_min || pos.y() > layer.altitude_max) {
                continue;
            }

            // 高度衰减
            float height_fraction = (pos.y() - layer.altitude_min) /
                                  (layer.altitude_max - layer.altitude_min);
            float height_gradient = 4.0f * height_fraction * (1.0f - height_fraction);

            // 基础噪声
            Vector3f noise_coord = pos * layer.noise_scale;
            float base_noise = sample_3d_noise(noise_coord);

            // 细节噪声
            Vector3f detail_coord = pos * layer.detail_scale;
            float detail_noise = sample_3d_noise(detail_coord);

            // 组合噪声
            float combined_noise = base_noise * 0.7f + detail_noise * 0.3f;

            // 应用覆盖率和高度梯度
            float density = std::max(0.0f, combined_noise - (1.0f - layer.coverage));
            density *= height_gradient * layer.density_multiplier;

            total_density += density;
        }

        return std::min(total_density, 1.0f);
    }

    Vector3f calculate_cloud_lighting(const Vector3f& pos, const Vector3f& sun_dir,
                                    float density) const {
        // 基础环境光
        Vector3f ambient = Vector3f(0.6f, 0.7f, 0.8f) * 0.3f;

        // 太阳光散射
        float sun_transmittance = calculate_sun_transmittance(pos, sun_dir);
        Vector3f sun_color = Vector3f(1.0f, 0.9f, 0.7f) * sun_transmittance;

        // Henyey-Greenberg相位函数（云的前向散射）
        float cos_theta = -sun_dir.dot(Vector3f(0, -1, 0));  // 假设视线向下
        float phase = henyey_greenberg_phase(cos_theta, 0.3f);  // 轻微前向散射

        // 组合光照
        Vector3f total_light = ambient + sun_color * phase;

        // 应用密度
        return total_light * density;
    }

    float calculate_sun_transmittance(const Vector3f& pos, const Vector3f& sun_dir) const {
        // 简化的太阳光透射率计算
        float transmittance = 1.0f;
        float step_size = 50.0f;

        for (int i = 0; i < 10; ++i) {  // 有限步数的光线行进
            Vector3f sample_pos = pos + i * step_size * sun_dir;
            float density = sample_cloud_density(sample_pos);
            transmittance *= std::exp(-density * step_size * 0.005f);

            if (transmittance < 0.1f) break;
        }

        return transmittance;
    }

    float sample_3d_noise(const Vector3f& coord) const {
        // 这里应该从3D噪声纹理采样
        // 简化实现：使用程序化噪声
        return (std::sin(coord.x()) * std::cos(coord.y()) * std::sin(coord.z()) + 1.0f) * 0.5f;
    }

    void generate_3d_noise_texture() {
        // 生成3D Perlin噪声纹理
        const int size = 128;
        std::vector<float> noise_data(size * size * size);

        for (int z = 0; z < size; ++z) {
            for (int y = 0; y < size; ++y) {
                for (int x = 0; x < size; ++x) {
                    Vector3f coord(x / float(size), y / float(size), z / float(size));
                    int index = z * size * size + y * size + x;
                    noise_data[index] = generate_perlin_noise(coord * 8.0f);
                }
            }
        }

        glGenTextures(1, &noise_texture_3d);
        glBindTexture(GL_TEXTURE_3D, noise_texture_3d);
        glTexImage3D(GL_TEXTURE_3D, 0, GL_R16F, size, size, size, 0, GL_RED, GL_FLOAT, noise_data.data());

        glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_REPEAT);
    }

    float generate_perlin_noise(const Vector3f& coord) const {
        // 简化的Perlin噪声实现
        return (std::sin(coord.x()) * std::cos(coord.y()) * std::sin(coord.z()) + 1.0f) * 0.5f;
    }

    float henyey_greenberg_phase(float cos_theta, float g) const {
        float g2 = g * g;
        float denom = 1.0f + g2 - 2.0f * g * cos_theta;
        return (1.0f - g2) / (4.0f * M_PI * std::pow(denom, 1.5f));
    }
};
```

---

## 计算着色器与GPGPU

## 28.1 计算着色器基础

### 28.1.1 工作组和线程模型

**工作组大小**：

- 本地工作组大小：$(local\_size\_x, local\_size\_y, local\_size\_z)$
- 全局工作组数量：$(num\_groups\_x, num\_groups\_y, num\_groups\_z)$
- 总线程数：$total\_threads = local\_size \times num\_groups$

**线程索引计算**：
$$global\_id = local\_id + group\_id \times local\_size$$

```cpp
class ComputeShaderManager {
private:
    struct ComputeProgram {
        GLuint program_id;
        GLuint shader_id;
        std::unordered_map<std::string, GLint> uniform_locations;

        ComputeProgram() : program_id(0), shader_id(0) {}

        ~ComputeProgram() {
            if (shader_id) glDeleteShader(shader_id);
            if (program_id) glDeleteProgram(program_id);
        }
    };

    std::unordered_map<std::string, std::unique_ptr<ComputeProgram>> programs;

public:
    bool create_compute_program(const std::string& name, const std::string& source) {
        auto program = std::make_unique<ComputeProgram>();

        // 创建计算着色器
        program->shader_id = glCreateShader(GL_COMPUTE_SHADER);
        const char* source_ptr = source.c_str();
        glShaderSource(program->shader_id, 1, &source_ptr, nullptr);
        glCompileShader(program->shader_id);

        // 检查编译错误
        GLint success;
        glGetShaderiv(program->shader_id, GL_COMPILE_STATUS, &success);
        if (!success) {
            char info_log[512];
            glGetShaderInfoLog(program->shader_id, 512, nullptr, info_log);
            std::cerr << "计算着色器编译失败: " << info_log << std::endl;
            return false;
        }

        // 创建程序
        program->program_id = glCreateProgram();
        glAttachShader(program->program_id, program->shader_id);
        glLinkProgram(program->program_id);

        // 检查链接错误
        glGetProgramiv(program->program_id, GL_LINK_STATUS, &success);
        if (!success) {
            char info_log[512];
            glGetProgramInfoLog(program->program_id, 512, nullptr, info_log);
            std::cerr << "计算着色器程序链接失败: " << info_log << std::endl;
            return false;
        }

        programs[name] = std::move(program);
        return true;
    }

    void dispatch_compute(const std::string& program_name,
                         GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z) {
        auto it = programs.find(program_name);
        if (it == programs.end()) {
            std::cerr << "计算着色器程序未找到: " << program_name << std::endl;
            return;
        }

        glUseProgram(it->second->program_id);
        glDispatchCompute(num_groups_x, num_groups_y, num_groups_z);
        glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);
    }

    void set_uniform(const std::string& program_name, const std::string& uniform_name,
                    float value) {
        auto it = programs.find(program_name);
        if (it == programs.end()) return;

        auto& program = it->second;
        auto uniform_it = program->uniform_locations.find(uniform_name);

        GLint location;
        if (uniform_it == program->uniform_locations.end()) {
            location = glGetUniformLocation(program->program_id, uniform_name.c_str());
            program->uniform_locations[uniform_name] = location;
        } else {
            location = uniform_it->second;
        }

        if (location != -1) {
            glUseProgram(program->program_id);
            glUniform1f(location, value);
        }
    }
};
```

## 28.2 并行算法实现

### 28.2.1 并行前缀和(Prefix Sum)

```cpp
class ParallelPrefixSum {
private:
    ComputeShaderManager compute_manager;
    GLuint input_buffer, output_buffer, temp_buffer;

    const std::string upsweep_shader = R"(
        #version 430
        layout(local_size_x = 256) in;

        layout(std430, binding = 0) restrict buffer InputBuffer {
            float input_data[];
        };

        layout(std430, binding = 1) restrict buffer TempBuffer {
            float temp_data[];
        };

        uniform int step;
        uniform int n;

        void main() {
            uint index = gl_GlobalInvocationID.x;
            uint stride = 1u << step;
            uint read_index = (index + 1u) * stride * 2u - 1u;

            if (read_index < n) {
                uint write_index = read_index + stride;
                if (write_index < n) {
                    temp_data[write_index] += temp_data[read_index];
                }
            }
        }
    )";

    const std::string downsweep_shader = R"(
        #version 430
        layout(local_size_x = 256) in;

        layout(std430, binding = 1) restrict buffer TempBuffer {
            float temp_data[];
        };

        layout(std430, binding = 2) restrict buffer OutputBuffer {
            float output_data[];
        };

        uniform int step;
        uniform int n;

        void main() {
            uint index = gl_GlobalInvocationID.x;
            uint stride = 1u << (step + 1);
            uint read_index = (index + 1u) * stride - 1u;

            if (read_index < n) {
                uint write_index = read_index + (stride >> 1);
                if (write_index < n) {
                    float temp = temp_data[read_index];
                    temp_data[read_index] = temp_data[write_index];
                    temp_data[write_index] += temp;
                }
            }
        }
    )";

public:
    void setup(int max_size) {
        // 创建缓冲区
        glGenBuffers(1, &input_buffer);
        glGenBuffers(1, &output_buffer);
        glGenBuffers(1, &temp_buffer);

        glBindBuffer(GL_SHADER_STORAGE_BUFFER, input_buffer);
        glBufferData(GL_SHADER_STORAGE_BUFFER, max_size * sizeof(float), nullptr, GL_DYNAMIC_DRAW);

        glBindBuffer(GL_SHADER_STORAGE_BUFFER, output_buffer);
        glBufferData(GL_SHADER_STORAGE_BUFFER, max_size * sizeof(float), nullptr, GL_DYNAMIC_DRAW);

        glBindBuffer(GL_SHADER_STORAGE_BUFFER, temp_buffer);
        glBufferData(GL_SHADER_STORAGE_BUFFER, max_size * sizeof(float), nullptr, GL_DYNAMIC_DRAW);

        // 编译着色器
        compute_manager.create_compute_program("upsweep", upsweep_shader);
        compute_manager.create_compute_program("downsweep", downsweep_shader);
    }

    void compute_prefix_sum(const std::vector<float>& input, std::vector<float>& output) {
        int n = input.size();
        output.resize(n);

        // 上传输入数据
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, input_buffer);
        glBufferSubData(GL_SHADER_STORAGE_BUFFER, 0, n * sizeof(float), input.data());

        // 复制到临时缓冲区
        glBindBuffer(GL_COPY_READ_BUFFER, input_buffer);
        glBindBuffer(GL_COPY_WRITE_BUFFER, temp_buffer);
        glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, n * sizeof(float));

        // 绑定缓冲区
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, input_buffer);
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, temp_buffer);
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, output_buffer);

        // Up-sweep阶段
        int steps = static_cast<int>(std::ceil(std::log2(n)));
        for (int step = 0; step < steps; ++step) {
            compute_manager.set_uniform("upsweep", "step", static_cast<float>(step));
            compute_manager.set_uniform("upsweep", "n", static_cast<float>(n));

            int num_groups = (n + 255) / 256;
            compute_manager.dispatch_compute("upsweep", num_groups, 1, 1);
        }

        // 清零最后一个元素
        float zero = 0.0f;
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, temp_buffer);
        glBufferSubData(GL_SHADER_STORAGE_BUFFER, (n - 1) * sizeof(float), sizeof(float), &zero);

        // Down-sweep阶段
        for (int step = steps - 1; step >= 0; --step) {
            compute_manager.set_uniform("downsweep", "step", static_cast<float>(step));
            compute_manager.set_uniform("downsweep", "n", static_cast<float>(n));

            int num_groups = (n + 255) / 256;
            compute_manager.dispatch_compute("downsweep", num_groups, 1, 1);
        }

        // 复制结果
        glBindBuffer(GL_COPY_READ_BUFFER, temp_buffer);
        glBindBuffer(GL_COPY_WRITE_BUFFER, output_buffer);
        glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, n * sizeof(float));

        // 下载结果
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, output_buffer);
        float* result = static_cast<float*>(glMapBuffer(GL_SHADER_STORAGE_BUFFER, GL_READ_ONLY));
        std::copy(result, result + n, output.begin());
        glUnmapBuffer(GL_SHADER_STORAGE_BUFFER);
    }
};
```

### 28.2.2 GPU粒子系统

```cpp
class GPUParticleSystem {
private:
    struct Particle {
        Vector3f position;
        float life;
        Vector3f velocity;
        float size;
        Vector4f color;
        Vector3f acceleration;
        float padding;
    };

    GLuint particle_buffer;
    GLuint counter_buffer;
    GLuint indirect_buffer;
    ComputeShaderManager compute_manager;

    const std::string update_shader = R"(
        #version 430
        layout(local_size_x = 256) in;

        struct Particle {
            vec3 position;
            float life;
            vec3 velocity;
            float size;
            vec4 color;
            vec3 acceleration;
            float padding;
        };

        layout(std430, binding = 0) restrict buffer ParticleBuffer {
            Particle particles[];
        };

        layout(std430, binding = 1) restrict buffer CounterBuffer {
            uint alive_count;
            uint dead_count;
            uint alive_list[];
        };

        uniform float delta_time;
        uniform vec3 gravity;
        uniform float damping;

        void main() {
            uint index = gl_GlobalInvocationID.x;
            if (index >= particles.length()) return;

            Particle p = particles[index];

            // 更新生命周期
            p.life -= delta_time;

            if (p.life > 0.0) {
                // 更新物理
                p.acceleration += gravity;
                p.velocity += p.acceleration * delta_time;
                p.velocity *= damping;
                p.position += p.velocity * delta_time;

                // 更新颜色（基于生命周期）
                float life_ratio = p.life / 5.0; // 假设最大生命周期为5秒
                p.color.a = life_ratio;

                // 重置加速度
                p.acceleration = vec3(0.0);

                particles[index] = p;

                // 添加到活跃列表
                uint alive_index = atomicAdd(alive_count, 1);
                alive_list[alive_index] = index;
            } else {
                // 粒子死亡
                atomicAdd(dead_count, 1);
            }
        }
    )";

    const std::string emit_shader = R"(
        #version 430
        layout(local_size_x = 64) in;

        struct Particle {
            vec3 position;
            float life;
            vec3 velocity;
            float size;
            vec4 color;
            vec3 acceleration;
            float padding;
        };

        layout(std430, binding = 0) restrict buffer ParticleBuffer {
            Particle particles[];
        };

        layout(std430, binding = 1) restrict buffer CounterBuffer {
            uint alive_count;
            uint dead_count;
            uint alive_list[];
        };

        uniform vec3 emitter_position;
        uniform vec3 emitter_direction;
        uniform float emit_rate;
        uniform float delta_time;
        uniform uint random_seed;

        // 简单的随机数生成器
        uint hash(uint x) {
            x += (x << 10u);
            x ^= (x >> 6u);
            x += (x << 3u);
            x ^= (x >> 11u);
            x += (x << 15u);
            return x;
        }

        float random(uint seed) {
            return float(hash(seed)) / 4294967295.0;
        }

        void main() {
            uint index = gl_GlobalInvocationID.x;

            // 计算需要发射的粒子数量
            uint emit_count = uint(emit_rate * delta_time);
            if (index >= emit_count) return;

            // 查找死亡的粒子进行重用
            if (dead_count > 0) {
                uint dead_index = atomicAdd(dead_count, -1) - 1;
                if (dead_index < particles.length()) {
                    uint particle_index = dead_index; // 简化：直接使用索引

                    // 初始化新粒子
                    uint seed = random_seed + index * 1000u;

                    particles[particle_index].position = emitter_position +
                        vec3(random(seed) - 0.5, random(seed + 1u) - 0.5, random(seed + 2u) - 0.5) * 2.0;

                    particles[particle_index].life = 3.0 + random(seed + 3u) * 2.0; // 3-5秒生命周期

                    vec3 random_dir = normalize(vec3(
                        random(seed + 4u) - 0.5,
                        random(seed + 5u) - 0.5,
                        random(seed + 6u) - 0.5
                    ));
                    particles[particle_index].velocity = emitter_direction + random_dir * 0.5;

                    particles[particle_index].size = 0.1 + random(seed + 7u) * 0.1;
                    particles[particle_index].color = vec4(1.0, 0.8, 0.2, 1.0);
                    particles[particle_index].acceleration = vec3(0.0);
                }
            }
        }
    )";

public:
    void setup(int max_particles) {
        // 创建粒子缓冲区
        glGenBuffers(1, &particle_buffer);
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, particle_buffer);
        glBufferData(GL_SHADER_STORAGE_BUFFER, max_particles * sizeof(Particle), nullptr, GL_DYNAMIC_DRAW);

        // 创建计数器缓冲区
        glGenBuffers(1, &counter_buffer);
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, counter_buffer);
        glBufferData(GL_SHADER_STORAGE_BUFFER, (2 + max_particles) * sizeof(GLuint), nullptr, GL_DYNAMIC_DRAW);

        // 初始化计数器
        GLuint initial_counts[2] = {0, static_cast<GLuint>(max_particles)};
        glBufferSubData(GL_SHADER_STORAGE_BUFFER, 0, 2 * sizeof(GLuint), initial_counts);

        // 编译着色器
        compute_manager.create_compute_program("update_particles", update_shader);
        compute_manager.create_compute_program("emit_particles", emit_shader);
    }

    void update(float delta_time, const Vector3f& emitter_pos, const Vector3f& emitter_dir,
               float emit_rate) {
        // 绑定缓冲区
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, particle_buffer);
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, counter_buffer);

        // 重置活跃计数
        GLuint zero = 0;
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, counter_buffer);
        glBufferSubData(GL_SHADER_STORAGE_BUFFER, 0, sizeof(GLuint), &zero);

        // 更新粒子
        compute_manager.set_uniform("update_particles", "delta_time", delta_time);
        compute_manager.set_uniform("update_particles", "damping", 0.98f);
        compute_manager.dispatch_compute("update_particles", (10000 + 255) / 256, 1, 1);

        // 发射新粒子
        compute_manager.set_uniform("emit_particles", "delta_time", delta_time);
        compute_manager.set_uniform("emit_particles", "emit_rate", emit_rate);
        compute_manager.set_uniform("emit_particles", "random_seed",
                                  static_cast<float>(std::rand()));
        compute_manager.dispatch_compute("emit_particles", (64 + 63) / 64, 1, 1);
    }

    GLuint get_particle_buffer() const { return particle_buffer; }
    GLuint get_counter_buffer() const { return counter_buffer; }
};
```

这个完整的计算机图形学笔记涵盖了从基础数学到高级渲染技术的所有重要主题，为深度学习和计算机视觉提供了坚实的理论基础和实践指导。
