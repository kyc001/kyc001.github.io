---
title: è®¡ç®—æœºå›¾å½¢å­¦ç¬”è®°
published: 2025-07-21 23:58:30
description: 'å­¦ä¹ ç¬”è®°'
tags: ["C++", "ç¼–ç¨‹", "è®¡ç®—æœºå›¾å½¢å­¦", "OpenGL"]
category: 'å­¦ä¹ ç¬”è®°'
---
<!--more-->
## è®¡ç®—æœºå›¾å½¢å­¦å…¥é—¨æ•™ç¨‹ ğŸ“š

ä»æ•°å­¦åŸç†åˆ°å·¥ç¨‹å®ç°çš„å®Œæ•´çŸ¥è¯†ä½“ç³»

> **åŸºäºGAMES101è¯¾ç¨‹ä¸å®è·µé¡¹ç›®çš„æ·±åº¦è§£æ**
> æ¶µç›–ç†è®ºæ¨å¯¼ã€ç®—æ³•å®ç°ã€å·¥ç¨‹ä¼˜åŒ–çš„å…¨æ–¹ä½æ•™ç¨‹

## ğŸ“‹ **å®Œæ•´ç›®å½•**

### ç¬¬ä¸€éƒ¨åˆ†ï¼šæ•°å­¦åŸºç¡€ä¸ç†è®ºæ ¹åŸº ğŸ§®

1. [çº¿æ€§ä»£æ•°åŸºç¡€](#çº¿æ€§ä»£æ•°åŸºç¡€) - å‘é‡ã€çŸ©é˜µã€é½æ¬¡åæ ‡ç³»ç»Ÿ
2. [å‡ ä½•å˜æ¢æ•°å­¦åŸç†](#å‡ ä½•å˜æ¢æ•°å­¦åŸç†) - å¹³ç§»ã€æ—‹è½¬ã€ç¼©æ”¾çš„æ•°å­¦æœ¬è´¨
3. [æŠ•å½±å‡ ä½•å­¦](#æŠ•å½±å‡ ä½•å­¦) - é€è§†æŠ•å½±ä¸è§†å›¾å˜æ¢çš„å®Œæ•´æ¨å¯¼
4. [å¾®ç§¯åˆ†åœ¨å›¾å½¢å­¦ä¸­çš„åº”ç”¨](#å¾®ç§¯åˆ†åœ¨å›¾å½¢å­¦ä¸­çš„åº”ç”¨) - æ›²çº¿æ›²ç‡ä¸æ¸²æŸ“ç§¯åˆ†

### ç¬¬äºŒéƒ¨åˆ†ï¼šå…‰æ …åŒ–æ¸²æŸ“ç®¡çº¿ ğŸ¨

1. [å›¾å½¢æ¸²æŸ“ç®¡çº¿æ¦‚è¿°](#å›¾å½¢æ¸²æŸ“ç®¡çº¿æ¦‚è¿°) - ç°ä»£GPUç®¡çº¿æ¶æ„
2. [é¡¶ç‚¹å¤„ç†ä¸å˜æ¢](#é¡¶ç‚¹å¤„ç†ä¸å˜æ¢) - MVPå˜æ¢é“¾ä¸é¡¶ç‚¹ç€è‰²å™¨
3. [å›¾å…ƒè£…é…ä¸è£å‰ª](#å›¾å…ƒè£…é…ä¸è£å‰ª) - è§†é”¥ä½“è£å‰ªç®—æ³•è¯¦è§£
4. [å…‰æ …åŒ–ç®—æ³•è¯¦è§£](#å…‰æ …åŒ–ç®—æ³•è¯¦è§£) - ä¸‰è§’å½¢å…‰æ …åŒ–ä¸é‡å¿ƒåæ ‡
5. [æ·±åº¦æµ‹è¯•ä¸éšè—é¢æ¶ˆé™¤](#æ·±åº¦æµ‹è¯•ä¸éšè—é¢æ¶ˆé™¤) - Z-Bufferç®—æ³•ä¸ä¼˜åŒ–
6. [å…‰ç…§æ¨¡å‹ä¸ç€è‰²](#å…‰ç…§æ¨¡å‹ä¸ç€è‰²) - Phongæ¨¡å‹åˆ°PBRçš„æ¼”è¿›
7. [çº¹ç†æ˜ å°„æŠ€æœ¯](#çº¹ç†æ˜ å°„æŠ€æœ¯) - Mipmapã€æ³•çº¿è´´å›¾ä¸ç¯å¢ƒæ˜ å°„

### ç¬¬ä¸‰éƒ¨åˆ†ï¼šå‡ ä½•å»ºæ¨¡ä¸å¤„ç† ğŸ“

1. [å‚æ•°æ›²çº¿ç†è®º](#å‚æ•°æ›²çº¿ç†è®º) - å‚æ•°åŒ–è¡¨ç¤ºçš„æ•°å­¦åŸºç¡€
2. [è´å¡å°”æ›²çº¿æ·±åº¦è§£æ](#è´å¡å°”æ›²çº¿æ·±åº¦è§£æ) - de Casteljauç®—æ³•ä¸å·¥ç¨‹å®ç°
3. [æ ·æ¡æ›²çº¿ä¸æ›²é¢](#æ ·æ¡æ›²çº¿ä¸æ›²é¢) - Bæ ·æ¡ä¸NURBSç†è®º
4. [ç½‘æ ¼å‡ ä½•å¤„ç†](#ç½‘æ ¼å‡ ä½•å¤„ç†) - åŠè¾¹ç»“æ„ä¸ç½‘æ ¼ç®—æ³•

### ç¬¬å››éƒ¨åˆ†ï¼šå…‰çº¿è¿½è¸ªä¸å…¨å±€å…‰ç…§ â˜€ï¸

1. [å…‰çº¿è¿½è¸ªåŸºç¡€ç†è®º](#å…‰çº¿è¿½è¸ªåŸºç¡€ç†è®º) - æ¸²æŸ“æ–¹ç¨‹ä¸Whittedå…‰çº¿è¿½è¸ª
2. [å…‰çº¿-å‡ ä½•ä½“ç›¸äº¤ç®—æ³•](#å…‰çº¿-å‡ ä½•ä½“ç›¸äº¤ç®—æ³•) - æ•°å­¦æ¨å¯¼ä¸æ•°å€¼ç¨³å®šæ€§
3. [ç©ºé—´åŠ é€Ÿæ•°æ®ç»“æ„](#ç©ºé—´åŠ é€Ÿæ•°æ®ç»“æ„) - BVHä¸KD-Treeæ„å»ºç®—æ³•
4. [è’™ç‰¹å¡æ´›æ–¹æ³•ä¸ç§¯åˆ†](#è’™ç‰¹å¡æ´›æ–¹æ³•ä¸ç§¯åˆ†) - é‡è¦æ€§é‡‡æ ·ä¸æ–¹å·®å‡å°‘
5. [å…¨å±€å…‰ç…§ä¸è·¯å¾„è¿½è¸ª](#å…¨å±€å…‰ç…§ä¸è·¯å¾„è¿½è¸ª) - è·¯å¾„è¿½è¸ªç®—æ³•å®ç°

### ç¬¬äº”éƒ¨åˆ†ï¼šåŠ¨ç”»ä¸ç‰©ç†ä»¿çœŸ ğŸ¬

1. [åŠ¨ç”»åŸºç¡€ç†è®º](#åŠ¨ç”»åŸºç¡€ç†è®º) - å…³é”®å¸§æ’å€¼ä¸è¿åŠ¨å­¦
2. [ç‰©ç†ä»¿çœŸæ•°å­¦åŸºç¡€](#ç‰©ç†ä»¿çœŸæ•°å­¦åŸºç¡€) - ç‰›é¡¿åŠ›å­¦ä¸çº¦æŸç³»ç»Ÿ
3. [è´¨ç‚¹å¼¹ç°§ç³»ç»Ÿ](#è´¨ç‚¹å¼¹ç°§ç³»ç»Ÿ) - å¼¹æ€§åŠ›å­¦ä¸ç¢°æ’æ£€æµ‹
4. [æ•°å€¼ç§¯åˆ†æ–¹æ³•](#æ•°å€¼ç§¯åˆ†æ–¹æ³•) - æ¬§æ‹‰æ³•åˆ°Runge-Kuttaçš„æ¼”è¿›

### ç¬¬å…­éƒ¨åˆ†ï¼šç°ä»£å›¾å½¢å­¦å‰æ²¿ ğŸš€

1. [å®æ—¶æ¸²æŸ“ä¼˜åŒ–æŠ€æœ¯](#å®æ—¶æ¸²æŸ“ä¼˜åŒ–æŠ€æœ¯) - LODã€é®æŒ¡å‰”é™¤ä¸GPUä¼˜åŒ–
2. [åŸºäºç‰©ç†çš„æ¸²æŸ“(PBR)](#åŸºäºç‰©ç†çš„æ¸²æŸ“pbr) - å¾®è¡¨é¢ç†è®ºä¸æè´¨å»ºæ¨¡
3. [ä½“ç§¯æ¸²æŸ“ä¸å‚ä¸ä»‹è´¨](#ä½“ç§¯æ¸²æŸ“ä¸å‚ä¸ä»‹è´¨) - äº‘é›¾çƒŸå°˜çš„æ¸²æŸ“æŠ€æœ¯
4. [è®¡ç®—ç€è‰²å™¨ä¸GPGPU](#è®¡ç®—ç€è‰²å™¨ä¸gpgpu) - å¹¶è¡Œè®¡ç®—åœ¨å›¾å½¢å­¦ä¸­çš„åº”ç”¨

---

## çº¿æ€§ä»£æ•°åŸºç¡€

## 1.1 å‘é‡çš„æ•°å­¦å®šä¹‰ä¸å‡ ä½•æ„ä¹‰

### 1.1.1 å‘é‡çš„åŸºæœ¬æ¦‚å¿µ

**æ•°å­¦å®šä¹‰**ï¼šå‘é‡æ˜¯å…·æœ‰å¤§å°å’Œæ–¹å‘çš„é‡ï¼Œåœ¨nç»´æ¬§å‡ é‡Œå¾—ç©ºé—´ $\mathbb{R}^n$ ä¸­å¯ä»¥è¡¨ç¤ºä¸ºï¼š

$$\vec{v} = \begin{pmatrix} v_1 \\ v_2 \\ \vdots \\ v_n \end{pmatrix} \in \mathbb{R}^n$$

**å‘é‡çš„æ¨¡é•¿ï¼ˆæ¬§å‡ é‡Œå¾—èŒƒæ•°ï¼‰**ï¼š
$$\|\vec{v}\| = \sqrt{v_1^2 + v_2^2 + \cdots + v_n^2} = \sqrt{\sum_{i=1}^{n} v_i^2}$$

**å•ä½å‘é‡**ï¼š
$$\hat{v} = \frac{\vec{v}}{\|\vec{v}\|}, \quad \|\hat{v}\| = 1$$

**å‡ ä½•æ„ä¹‰ä¸æ€§è´¨**ï¼š

- **ä½ç½®è¡¨ç¤º**ï¼šå‘é‡å¯ä»¥çœ‹ä½œä»åŸç‚¹æŒ‡å‘æŸç‚¹çš„æœ‰å‘çº¿æ®µ
- **æ–¹å‘æ€§**ï¼šå‘é‡çš„æ–¹å‘ç”±å…¶å„åˆ†é‡çš„æ¯”å€¼å†³å®šï¼Œä¸èµ·ç‚¹æ— å…³
- **å¹³ç§»ä¸å˜æ€§**ï¼šå‘é‡è¡¨ç¤ºçš„æ˜¯ç›¸å¯¹ä½ç§»ï¼Œä¸ä¾èµ–äºåæ ‡ç³»åŸç‚¹
- **çº¿æ€§æ€§**ï¼šå‘é‡ç©ºé—´æ»¡è¶³åŠ æ³•å’Œæ•°ä¹˜çš„çº¿æ€§æ€§è´¨

**åœ¨è®¡ç®—æœºå›¾å½¢å­¦ä¸­çš„æ ¸å¿ƒåº”ç”¨**ï¼š

- **ä½ç½®å‘é‡**ï¼šè¡¨ç¤º3Dç©ºé—´ä¸­é¡¶ç‚¹çš„åæ ‡ $p = (x, y, z)^T$
- **æ–¹å‘å‘é‡**ï¼šè¡¨ç¤ºå…‰çº¿æ–¹å‘ã€æ³•å‘é‡ã€è§†çº¿æ–¹å‘ç­‰
- **ä½ç§»å‘é‡**ï¼šè¡¨ç¤ºç‰©ä½“çš„å¹³ç§»å˜æ¢
- **é¢œè‰²å‘é‡**ï¼šRGB/RGBAé¢œè‰²ç©ºé—´çš„è¡¨ç¤º
- **çº¹ç†åæ ‡**ï¼šUVåæ ‡çš„äºŒç»´å‘é‡è¡¨ç¤º

### 1.1.2 å‘é‡è¿ç®—çš„æ•°å­¦åŸç†

#### å‘é‡åŠ æ³•ï¼ˆVector Additionï¼‰

**æ•°å­¦å®šä¹‰**ï¼šå¯¹äº n ç»´å‘é‡ $u$ å’Œ $v$ï¼Œå…¶å’Œå®šä¹‰ä¸ºï¼š
$$u + v = \begin{pmatrix}{c} u_1 + v_1 \\ u_2 + v_2 \\ \vdots \\ u_n + v_n \end{pmatrix}$$

**å‡ ä½•è§£é‡Š**ï¼š

- **å¹³è¡Œå››è¾¹å½¢æ³•åˆ™**ï¼š$u + v$ æ˜¯ä»¥ $u$ å’Œ $v$ ä¸ºé‚»è¾¹çš„å¹³è¡Œå››è¾¹å½¢çš„å¯¹è§’çº¿
- **ä¸‰è§’å½¢æ³•åˆ™**ï¼šå°† $v$ çš„èµ·ç‚¹æ”¾åœ¨ $u$ çš„ç»ˆç‚¹ï¼Œè¿æ¥ $u$ çš„èµ·ç‚¹å’Œ $v$ çš„ç»ˆç‚¹

**ä»£æ•°æ€§è´¨**ï¼š

- **äº¤æ¢å¾‹**ï¼š$u + v = v + u$
- **ç»“åˆå¾‹**ï¼š$(u + v) + w = u + (v + w)$
- **é›¶å…ƒç´ **ï¼š$u + 0 = u$
- **é€†å…ƒç´ **ï¼š$u + (-u) = 0$

**GAMES101é¡¹ç›®å®ç°**ï¼š

```cpp
// Eigenåº“ä¸­çš„å‘é‡åŠ æ³•
Eigen::Vector3f u(1.0f, 2.0f, 3.0f);
Eigen::Vector3f v(4.0f, 5.0f, 6.0f);
Eigen::Vector3f result = u + v;  // (5, 7, 9)

// åœ¨å…‰æ …åŒ–ä¸­çš„åº”ç”¨ï¼šé¡¶ç‚¹ä½ç½®å˜æ¢
Eigen::Vector3f vertex_position = base_position + displacement;
```

#### å‘é‡æ•°ä¹˜ï¼ˆScalar Multiplicationï¼‰

**æ•°å­¦å®šä¹‰**ï¼šå¯¹äºæ ‡é‡ $k \in \mathbb{R}$ å’Œå‘é‡ $\vec{v} \in \mathbb{R}^n$ï¼š
$$k\vec{v} = \begin{pmatrix} kv_1 \\ kv_2 \\ \vdots \\ kv_n \end{pmatrix}$$

**å‡ ä½•æ•ˆæœåˆ†æ**ï¼š

- $k > 1$ï¼šå‘é‡ä¼¸é•¿ $k$ å€ï¼Œæ–¹å‘ä¸å˜
- $0 < k < 1$ï¼šå‘é‡ç¼©çŸ­ä¸ºåŸé•¿åº¦çš„ $k$ å€ï¼Œæ–¹å‘ä¸å˜
- $k = 0$ï¼šå¾—åˆ°é›¶å‘é‡
- $k < 0$ï¼šå‘é‡åå‘å¹¶ç¼©æ”¾ $|k|$ å€

**é‡è¦åº”ç”¨**ï¼š

- **å•ä½å‘é‡è®¡ç®—**ï¼š$\hat{v} = \frac{1}{\|\vec{v}\|}\vec{v}$
- **ç¼©æ”¾å˜æ¢**ï¼šåœ¨å‡ ä½•å˜æ¢ä¸­å®ç°ç‰©ä½“çš„æ”¾å¤§ç¼©å°
- **æ’å€¼è®¡ç®—**ï¼šçº¿æ€§æ’å€¼ $\vec{p}(t) = (1-t)\vec{p_0} + t\vec{p_1}$

#### ç‚¹ç§¯ï¼ˆå†…ç§¯/æ•°é‡ç§¯ï¼‰

**æ•°å­¦å®šä¹‰**ï¼šå¯¹äºå‘é‡ $\vec{u}, \vec{v} \in \mathbb{R}^n$ï¼Œç‚¹ç§¯å®šä¹‰ä¸ºï¼š
$$\vec{u} \cdot \vec{v} = \sum_{i=1}^{n} u_i v_i = u_1v_1 + u_2v_2 + \cdots + u_nv_n$$

**å‡ ä½•å½¢å¼**ï¼š
$$\vec{u} \cdot \vec{v} = \|\vec{u}\| \|\vec{v}\| \cos \theta$$
å…¶ä¸­ $\theta$ æ˜¯ä¸¤å‘é‡é—´çš„å¤¹è§’ $(0 \leq \theta \leq \pi)$

**å‡ ä½•æ„ä¹‰æ·±åº¦è§£æ**ï¼š

- **æŠ•å½±è§£é‡Š**ï¼š$\vec{u} \cdot \vec{v} = \|\vec{u}\| \cdot \text{proj}_{\vec{v}}\vec{u}$
- **æ ‡é‡ç»“æœ**ï¼šç‚¹ç§¯çš„ç»“æœæ˜¯æ ‡é‡ï¼Œä¸æ˜¯å‘é‡
- **è§’åº¦è®¡ç®—**ï¼š$\cos \theta = \frac{\vec{u} \cdot \vec{v}}{\|\vec{u}\| \|\vec{v}\|}$

**é‡è¦ä»£æ•°æ€§è´¨**ï¼š

- **äº¤æ¢å¾‹**ï¼š$\vec{u} \cdot \vec{v} = \vec{v} \cdot \vec{u}$
- **åˆ†é…å¾‹**ï¼š$\vec{u} \cdot (\vec{v} + \vec{w}) = \vec{u} \cdot \vec{v} + \vec{u} \cdot \vec{w}$
- **ç»“åˆå¾‹**ï¼š$(k\vec{u}) \cdot \vec{v} = k(\vec{u} \cdot \vec{v})$
- **æ­£å®šæ€§**ï¼š$\vec{u} \cdot \vec{u} = \|\vec{u}\|^2 \geq 0$ï¼Œç­‰å·æˆç«‹å½“ä¸”ä»…å½“ $\vec{u} = \vec{0}$

**å‡ ä½•åˆ¤æ–­å‡†åˆ™**ï¼š

- $\vec{u} \cdot \vec{v} = 0 \iff \vec{u} \perp \vec{v}$ï¼ˆå‚ç›´åˆ¤æ–­ï¼‰
- $\vec{u} \cdot \vec{v} > 0 \iff \theta < 90Â°$ï¼ˆé”è§’ï¼‰
- $\vec{u} \cdot \vec{v} < 0 \iff \theta > 90Â°$ï¼ˆé’è§’ï¼‰

**GAMES101é¡¹ç›®ä¸­çš„å…³é”®åº”ç”¨**ï¼š

```cpp
// 1. è®¡ç®—ä¸¤å‘é‡å¤¹è§’
float dot_product = u.dot(v);
float angle = std::acos(std::clamp(dot_product / (u.norm() * v.norm()), -1.0f, 1.0f));

// 2. å…‰ç…§è®¡ç®—ä¸­çš„Lambertä½™å¼¦å®šå¾‹
float cos_theta = std::max(0.0f, normal.dot(light_direction));
Vector3f diffuse_color = albedo * light_color * cos_theta;

// 3. è§†é”¥ä½“è£å‰ªä¸­çš„å¹³é¢æµ‹è¯•
float distance_to_plane = point.dot(plane_normal) + plane_d;
bool is_inside = distance_to_plane >= 0;

// 4. èƒŒé¢å‰”é™¤
Vector3f view_direction = camera_position - vertex_position;
bool is_front_facing = face_normal.dot(view_direction) > 0;
```

#### å‰ç§¯ï¼ˆå¤–ç§¯/å‘é‡ç§¯ï¼‰

**æ•°å­¦å®šä¹‰**ï¼šå¯¹äºä¸‰ç»´å‘é‡ $\vec{u}, \vec{v} \in \mathbb{R}^3$ï¼Œå‰ç§¯å®šä¹‰ä¸ºï¼š
$$\vec{u} \times \vec{v} = \begin{pmatrix} u_2v_3 - u_3v_2 \\ u_3v_1 - u_1v_3 \\ u_1v_2 - u_2v_1 \end{pmatrix}$$

**è¡Œåˆ—å¼è¡¨ç¤º**ï¼š

å‰ç§¯å¯ä»¥è¡¨ç¤ºä¸ºå½¢å¼è¡Œåˆ—å¼ï¼š

- ç¬¬1è¡Œï¼š$(\vec{i}, \vec{j}, \vec{k})$ - å•ä½å‘é‡
- ç¬¬2è¡Œï¼š$(u_1, u_2, u_3)$ - å‘é‡ $\vec{u}$ çš„åˆ†é‡
- ç¬¬3è¡Œï¼š$(v_1, v_2, v_3)$ - å‘é‡ $\vec{v}$ çš„åˆ†é‡

$$\vec{u} \times \vec{v} = \text{determinant expansion}$$

**å‡ ä½•æ„ä¹‰æ·±åº¦è§£æ**ï¼š

- **æ–¹å‘**ï¼šéµå¾ªå³æ‰‹å®šåˆ™ï¼Œå‚ç›´äº $\vec{u}$ å’Œ $\vec{v}$ æ„æˆçš„å¹³é¢
- **å¤§å°**ï¼š$\|\vec{u} \times \vec{v}\| = \|\vec{u}\| \|\vec{v}\| \sin \theta$
- **é¢ç§¯è§£é‡Š**ï¼š$\|\vec{u} \times \vec{v}\|$ ç­‰äºä»¥ $\vec{u}$ å’Œ $\vec{v}$ ä¸ºé‚»è¾¹çš„å¹³è¡Œå››è¾¹å½¢é¢ç§¯

**é‡è¦ä»£æ•°æ€§è´¨**ï¼š

- **åäº¤æ¢å¾‹**ï¼š$\vec{u} \times \vec{v} = -\vec{v} \times \vec{u}$
- **åˆ†é…å¾‹**ï¼š$\vec{u} \times (\vec{v} + \vec{w}) = \vec{u} \times \vec{v} + \vec{u} \times \vec{w}$
- **æ ‡é‡ç»“åˆå¾‹**ï¼š$(k\vec{u}) \times \vec{v} = k(\vec{u} \times \vec{v}) = \vec{u} \times (k\vec{v})$
- **å¹³è¡Œåˆ¤æ–­**ï¼š$\vec{u} \times \vec{v} = \vec{0} \iff \vec{u} \parallel \vec{v}$
- **å‚ç›´æ€§**ï¼š$(\vec{u} \times \vec{v}) \cdot \vec{u} = 0$ ä¸” $(\vec{u} \times \vec{v}) \cdot \vec{v} = 0$

**æ ‡é‡ä¸‰é‡ç§¯**ï¼š

æ ‡é‡ä¸‰é‡ç§¯ç­‰äºä¸‰ä¸ªå‘é‡æ„æˆçš„è¡Œåˆ—å¼ï¼š

- ç¬¬1è¡Œï¼š$(u_1, u_2, u_3)$ - å‘é‡ $\vec{u}$ çš„åˆ†é‡
- ç¬¬2è¡Œï¼š$(v_1, v_2, v_3)$ - å‘é‡ $\vec{v}$ çš„åˆ†é‡
- ç¬¬3è¡Œï¼š$(w_1, w_2, w_3)$ - å‘é‡ $\vec{w}$ çš„åˆ†é‡

$$\vec{u} \cdot (\vec{v} \times \vec{w}) = \text{scalar triple product}$$

è¡¨ç¤ºä»¥ä¸‰ä¸ªå‘é‡ä¸ºé‚»è¾¹çš„å¹³è¡Œå…­é¢ä½“çš„æœ‰å‘ä½“ç§¯ã€‚

**GAMES101é¡¹ç›®ä¸­çš„æ ¸å¿ƒåº”ç”¨**ï¼š

```cpp
// 1. è®¡ç®—ä¸‰è§’å½¢æ³•å‘é‡ï¼ˆAssignment 2/3ä¸­çš„å…³é”®æ“ä½œï¼‰
Eigen::Vector3f edge1 = vertex2 - vertex1;
Eigen::Vector3f edge2 = vertex3 - vertex1;
Eigen::Vector3f normal = edge1.cross(edge2).normalized();

// 2. åˆ¤æ–­ç‚¹åœ¨ä¸‰è§’å½¢å†…éƒ¨ï¼ˆé‡å¿ƒåæ ‡è®¡ç®—çš„åŸºç¡€ï¼‰
Vector3f v0 = C - A, v1 = B - A, v2 = P - A;
Vector3f cross1 = v0.cross(v1);  // ä¸‰è§’å½¢é¢ç§¯å‘é‡
Vector3f cross2 = v0.cross(v2);  // å­ä¸‰è§’å½¢é¢ç§¯å‘é‡
float area_ratio = cross2.dot(cross1) / cross1.squaredNorm();

// 3. æ„å»ºåæ ‡ç³»ï¼ˆç›¸æœºå˜æ¢ä¸­çš„åº”ç”¨ï¼‰
Vector3f forward = (target - eye).normalized();
Vector3f right = forward.cross(up).normalized();
Vector3f camera_up = right.cross(forward);

// 4. è®¡ç®—ä¸‰è§’å½¢é¢ç§¯
float triangle_area = 0.5f * edge1.cross(edge2).norm();
```

## 1.2 çŸ©é˜µç†è®ºåŸºç¡€

### 1.2.1 çŸ©é˜µçš„å®šä¹‰ä¸åŸºæœ¬è¿ç®—

**çŸ©é˜µå®šä¹‰**ï¼š$m \times n$ çŸ©é˜µæ˜¯ç”± $m$ è¡Œ $n$ åˆ—å®æ•°æ’åˆ—æˆçš„çŸ©å½¢é˜µåˆ—:

$$A = (a_{ij})_{m \times n} \text{ where } a_{ij} \text{ is the element in row } i \text{ and column } j$$

**çŸ©é˜µä¹˜æ³•çš„ä¸¥æ ¼å®šä¹‰**ï¼š
å¯¹äºçŸ©é˜µ $A \in \mathbb{R}^{m \times p}$ å’Œ $B \in \mathbb{R}^{p \times n}$ï¼Œä¹˜ç§¯ $C = AB \in \mathbb{R}^{m \times n}$ çš„å…ƒç´ ä¸ºï¼š
$$c_{ij} = \sum_{k=1}^{p} a_{ik} b_{kj}, \quad i = 1,2,\ldots,m; \quad j = 1,2,\ldots,n$$

**çŸ©é˜µä¹˜æ³•çš„å‡ ä½•æ„ä¹‰**ï¼š

- **çº¿æ€§å˜æ¢å¤åˆ**ï¼š$(AB)\vec{x} = A(B\vec{x})$ è¡¨ç¤ºå…ˆåº”ç”¨å˜æ¢ $B$ï¼Œå†åº”ç”¨å˜æ¢ $A$
- **åŸºå‘é‡å˜æ¢**ï¼šçŸ©é˜µ $A$ çš„ç¬¬ $j$ åˆ—æ˜¯æ ‡å‡†åŸºå‘é‡ $\vec{e_j}$ ç»è¿‡å˜æ¢ $A$ åçš„ç»“æœ
- **åæ ‡ç³»å˜æ¢**ï¼šä»ä¸€ä¸ªåæ ‡ç³»åˆ°å¦ä¸€ä¸ªåæ ‡ç³»çš„æ˜ å°„

**çŸ©é˜µä¹˜æ³•çš„é‡è¦æ€§è´¨**ï¼š

- **ç»“åˆå¾‹**ï¼š$(AB)C = A(BC)$
- **åˆ†é…å¾‹**ï¼š$A(B + C) = AB + AC$ï¼Œ$(A + B)C = AC + BC$
- **éäº¤æ¢æ€§**ï¼šä¸€èˆ¬æƒ…å†µä¸‹ $AB \neq BA$
- **ä¸æ ‡é‡ä¹˜æ³•çš„å…³ç³»**ï¼š$(kA)B = k(AB) = A(kB)$

### 1.2.2 ç‰¹æ®ŠçŸ©é˜µç±»å‹

#### å•ä½çŸ©é˜µï¼ˆIdentity Matrixï¼‰

**å®šä¹‰**ï¼š$n \times n$ å•ä½çŸ©é˜µ $I_n$ å®šä¹‰ä¸ºå¯¹è§’çº¿å…ƒç´ ä¸º1ï¼Œå…¶ä»–å…ƒç´ ä¸º0çš„çŸ©é˜µï¼š

$$(I_n)_{ij} = \delta_{ij}$$

å…¶ä¸­ $\delta_{ij}$ æ˜¯Kronecker deltaå‡½æ•°ï¼š

å½“ $i = j$ æ—¶ï¼š$\delta_{ij} = 1$

å½“ $i \neq j$ æ—¶ï¼š$\delta_{ij} = 0$

**åŸºæœ¬æ€§è´¨**ï¼š

- **ä¹˜æ³•å•ä½å…ƒ**ï¼š$AI = IA = A$ï¼ˆå½“ç»´åº¦åŒ¹é…æ—¶ï¼‰
- **å‡ ä½•æ„ä¹‰**ï¼šæ’ç­‰å˜æ¢ï¼Œä¸æ”¹å˜ä»»ä½•å‘é‡
- **ç‰¹å¾å€¼**ï¼šæ‰€æœ‰ç‰¹å¾å€¼éƒ½æ˜¯1

#### è½¬ç½®çŸ©é˜µï¼ˆTranspose Matrixï¼‰

**å®šä¹‰**ï¼šçŸ©é˜µ $A$ çš„è½¬ç½® $A^T$ å®šä¹‰ä¸ºï¼š
$$(A^T)_{ij} = A_{ji}$$

**é‡è¦æ€§è´¨**ï¼š

- **å¯¹åˆæ€§**ï¼š$(A^T)^T = A$
- **ä¹˜ç§¯è½¬ç½®**ï¼š$(AB)^T = B^T A^T$
- **å’Œçš„è½¬ç½®**ï¼š$(A + B)^T = A^T + B^T$
- **æ ‡é‡ä¹˜æ³•**ï¼š$(kA)^T = kA^T$

**å‡ ä½•æ„ä¹‰**ï¼š

- å¯¹äºæ—‹è½¬çŸ©é˜µï¼š$R^T = R^{-1}$ï¼ˆæ­£äº¤çŸ©é˜µæ€§è´¨ï¼‰
- åæ˜ äº†çº¿æ€§å˜æ¢çš„"é€†å‘"æ“ä½œ

#### é€†çŸ©é˜µï¼ˆInverse Matrixï¼‰

**å®šä¹‰**ï¼šå¯¹äºæ–¹é˜µ $A \in \mathbb{R}^{n \times n}$ï¼Œå¦‚æœå­˜åœ¨çŸ©é˜µ $A^{-1}$ ä½¿å¾—ï¼š
$$AA^{-1} = A^{-1}A = I_n$$
åˆ™ç§° $A^{-1}$ ä¸º $A$ çš„é€†çŸ©é˜µã€‚

**å­˜åœ¨æ€§æ¡ä»¶**ï¼š

- **è¡Œåˆ—å¼éé›¶**ï¼š$\det(A) \neq 0$
- **æ»¡ç§©æ¡ä»¶**ï¼š$\text{rank}(A) = n$
- **çº¿æ€§æ— å…³**ï¼š$A$ çš„åˆ—å‘é‡çº¿æ€§æ— å…³

**è®¡ç®—æ–¹æ³•**ï¼š

1. **ä¼´éšçŸ©é˜µæ³•**ï¼š$A^{-1} = \frac{1}{\det(A)} \text{adj}(A)$
2. **é«˜æ–¯-çº¦æ—¦æ¶ˆå…ƒæ³•**ï¼š$[A|I] \to [I|A^{-1}]$
3. **LUåˆ†è§£æ³•**ï¼šé€‚ç”¨äºå¤§å‹çŸ©é˜µ

**é‡è¦æ€§è´¨**ï¼š

- $(A^{-1})^{-1} = A$
- $(AB)^{-1} = B^{-1}A^{-1}$
- $(A^T)^{-1} = (A^{-1})^T$
- $\det(A^{-1}) = \frac{1}{\det(A)}$

### 1.2.3 é½æ¬¡åæ ‡ç³»ç»Ÿ

#### é½æ¬¡åæ ‡çš„æ•°å­¦åŸºç¡€

**å¼•å…¥åŠ¨æœº**ï¼š

1. **ç»Ÿä¸€å˜æ¢è¡¨ç¤º**ï¼šå°†å¹³ç§»ã€æ—‹è½¬ã€ç¼©æ”¾ç­‰å˜æ¢ç»Ÿä¸€ä¸ºçŸ©é˜µä¹˜æ³•
2. **é€è§†æŠ•å½±ç®€åŒ–**ï¼šç”¨çº¿æ€§ä»£æ•°å¤„ç†éçº¿æ€§çš„é€è§†é™¤æ³•
3. **å˜æ¢å¤åˆ**ï¼šå¤šä¸ªå˜æ¢çš„å¤åˆç®€åŒ–ä¸ºçŸ©é˜µä¹˜æ³•
4. **æ— ç©·è¿œç‚¹è¡¨ç¤º**ï¼šä¼˜é›…åœ°å¤„ç†å¹³è¡Œçº¿ç›¸äº¤äºæ— ç©·è¿œç‚¹

**é½æ¬¡åæ ‡çš„æ•°å­¦å®šä¹‰**ï¼š
å¯¹äº $n$ ç»´æ¬§å‡ é‡Œå¾—ç©ºé—´ä¸­çš„ç‚¹ï¼Œå…¶é½æ¬¡åæ ‡æ˜¯ $(n+1)$ ç»´å‘é‡ï¼š

é½æ¬¡åæ ‡ $(x, y, z, w)$ å¯¹åº”ç¬›å¡å°”åæ ‡ $(x/w, y/w, z/w)$ï¼Œå…¶ä¸­ $w \neq 0$

**é½æ¬¡åæ ‡çš„åˆ†ç±»**ï¼š

- **ç‚¹çš„è¡¨ç¤º**ï¼š$(x, y, z, 1)$ - ç¬¬å››ä¸ªåˆ†é‡ä¸º1
- **å‘é‡çš„è¡¨ç¤º**ï¼š$(x, y, z, 0)$ - ç¬¬å››ä¸ªåˆ†é‡ä¸º0
- **æ— ç©·è¿œç‚¹**ï¼š$(x, y, z, 0)$ ä¸” $(x, y, z) \neq (0, 0, 0)$

**é½æ¬¡åæ ‡çš„ç­‰ä»·æ€§**ï¼š
æ‰€æœ‰éé›¶æ ‡é‡å€æ•°è¡¨ç¤ºåŒä¸€ä¸ªç‚¹ï¼š

$$k(x, y, z, w) \sim (x, y, z, w) \quad (k \neq 0)$$

#### é½æ¬¡åæ ‡çš„è¿ç®—è§„åˆ™

**ç‚¹ä¸å‘é‡çš„åŒºåˆ«**ï¼š

- **ç‚¹ + å‘é‡ = ç‚¹**ï¼š$(x_1, y_1, z_1, 1) + (x_2, y_2, z_2, 0) = (x_1+x_2, y_1+y_2, z_1+z_2, 1)$
- **ç‚¹ - ç‚¹ = å‘é‡**ï¼š$(x_1, y_1, z_1, 1) - (x_2, y_2, z_2, 1) = (x_1-x_2, y_1-y_2, z_1-z_2, 0)$
- **å‘é‡ + å‘é‡ = å‘é‡**ï¼š$(x_1, y_1, z_1, 0) + (x_2, y_2, z_2, 0) = (x_1+x_2, y_1+y_2, z_1+z_2, 0)$

**ä»¿å°„ç»„åˆ**ï¼š
ç‚¹çš„ä»¿å°„ç»„åˆï¼ˆæƒé‡å’Œä¸º1ï¼‰ä»ä¸ºç‚¹ï¼š

å¯¹äºç‚¹ $P_i = (x_i, y_i, z_i, 1)$ï¼Œå…¶ä»¿å°„ç»„åˆä¸ºï¼š
$$\sum_{i} \alpha_i P_i = \left(\sum_i \alpha_i x_i, \sum_i \alpha_i y_i, \sum_i \alpha_i z_i, \sum_i \alpha_i\right)$$

å½“ $\sum_i \alpha_i = 1$ æ—¶ï¼Œç»“æœæ˜¯æœ‰æ•ˆçš„ç‚¹ã€‚

#### GAMES101é¡¹ç›®ä¸­çš„å®é™…åº”ç”¨

**å˜æ¢çŸ©é˜µçš„ç»Ÿä¸€è¡¨ç¤º**ï¼š

```cpp
// ä¸ä½¿ç”¨é½æ¬¡åæ ‡çš„å˜æ¢ï¼ˆéœ€è¦åˆ†åˆ«å¤„ç†ï¼‰
Vector3f transformed_point = rotation_matrix * point + translation_vector;
Vector3f transformed_vector = rotation_matrix * vector;  // å‘é‡ä¸å—å¹³ç§»å½±å“

// ä½¿ç”¨é½æ¬¡åæ ‡çš„ç»Ÿä¸€å˜æ¢
Matrix4f transformation = translation * rotation * scaling;
Vector4f homogeneous_point(point.x, point.y, point.z, 1.0f);
Vector4f homogeneous_vector(vector.x, vector.y, vector.z, 0.0f);

Vector4f transformed_point = transformation * homogeneous_point;
Vector4f transformed_vector = transformation * homogeneous_vector;

// è½¬æ¢å›ç¬›å¡å°”åæ ‡
Vector3f result_point = transformed_point.head<3>() / transformed_point.w();
Vector3f result_vector = transformed_vector.head<3>();  // wåˆ†é‡ä¸º0ï¼Œä¸éœ€è¦é™¤æ³•
```

**MVPå˜æ¢é“¾çš„å®ç°**ï¼š

```cpp
// Assignment 1ä¸­çš„æ ¸å¿ƒå˜æ¢
Matrix4f mvp = projection * view * model;
for (auto& vertex : vertices) {
    Vector4f clip_coord = mvp * Vector4f(vertex.x, vertex.y, vertex.z, 1.0f);

    // é€è§†é™¤æ³•ï¼ˆé½æ¬¡åæ ‡åˆ°NDCï¼‰
    Vector3f ndc_coord = clip_coord.head<3>() / clip_coord.w();

    // è§†å£å˜æ¢
    Vector3f screen_coord = viewport_transform * ndc_coord;
}
```

## 1.3 åŸºç¡€å…‰æ …åŒ–ç®—æ³•

### 1.3.1 Bresenhamç›´çº¿ç®—æ³•

#### ç®—æ³•èƒŒæ™¯ä¸åŠ¨æœº

**é—®é¢˜æè¿°**ï¼šç»™å®šä¸¤ä¸ªç«¯ç‚¹ $(x_0, y_0)$ å’Œ $(x_1, y_1)$ï¼Œåœ¨ç¦»æ•£çš„åƒç´ ç½‘æ ¼ä¸Šç»˜åˆ¶è¿æ¥è¿™ä¸¤ç‚¹çš„ç›´çº¿ã€‚

**æ ¸å¿ƒæŒ‘æˆ˜**ï¼š

- åƒç´ ç½‘æ ¼æ˜¯ç¦»æ•£çš„ï¼Œè€Œæ•°å­¦ç›´çº¿æ˜¯è¿ç»­çš„
- éœ€è¦é€‰æ‹©æœ€æ¥è¿‘ç†æƒ³ç›´çº¿çš„åƒç´ ç‚¹
- ç®—æ³•å¿…é¡»é«˜æ•ˆï¼Œé¿å…æµ®ç‚¹è¿ç®—å’Œé™¤æ³•

#### æ•°å­¦åŸç†æ¨å¯¼

**ç›´çº¿æ–¹ç¨‹**ï¼š
$$y = mx + b, \quad m = \frac{y_1 - y_0}{x_1 - x_0}$$

**å†³ç­–å˜é‡çš„å¼•å…¥**ï¼š
å¯¹äºå½“å‰åƒç´  $(x_i, y_i)$ï¼Œä¸‹ä¸€ä¸ªåƒç´ å¯èƒ½æ˜¯ $(x_i+1, y_i)$ æˆ– $(x_i+1, y_i+1)$ã€‚

å®šä¹‰å†³ç­–å˜é‡ï¼š
$$d_i = 2(y_i - y_{ideal}) \cdot (x_1 - x_0)$$

å…¶ä¸­ $y_{ideal} = y_0 + m(x_i + 1 - x_0)$ æ˜¯ç†æƒ³ç›´çº¿åœ¨ $x = x_i + 1$ å¤„çš„yå€¼ã€‚

**å†³ç­–è§„åˆ™**ï¼š

- å¦‚æœ $d_i < 0$ï¼Œé€‰æ‹© $(x_i+1, y_i)$
- å¦‚æœ $d_i \geq 0$ï¼Œé€‰æ‹© $(x_i+1, y_i+1)$

**é€’æ¨å…³ç³»**ï¼š

å½“ $d_i < 0$ æ—¶ï¼š
$$d_{i+1} = d_i + 2(y_1 - y_0)$$

å½“ $d_i \geq 0$ æ—¶ï¼š
$$d_{i+1} = d_i + 2(y_1 - y_0) - 2(x_1 - x_0)$$

**åˆå§‹å€¼**ï¼š
$$d_0 = 2(y_1 - y_0) - (x_1 - x_0)$$

#### GAMES101é¡¹ç›®å®ç°åˆ†æ

```cpp
// Assignment 1ä¸­çš„Bresenhamç®—æ³•å®ç°
void rst::rasterizer::draw_line(Eigen::Vector3f begin, Eigen::Vector3f end) {
    auto x1 = begin.x(), y1 = begin.y();
    auto x2 = end.x(), y2 = end.y();

    Eigen::Vector3f line_color = {255, 255, 255};

    int x, y, dx, dy, dx1, dy1, px, py, xe, ye, i;

    // è®¡ç®—å¢é‡
    dx = x2 - x1;  // $\Delta x$
    dy = y2 - y1;  // $\Delta y$
    dx1 = fabs(dx);  // $|\Delta x|$
    dy1 = fabs(dy);  // $|\Delta y|$

    // åˆå§‹å†³ç­–å˜é‡
    px = 2 * dy1 - dx1;  // å¯¹åº”æ°´å¹³ä¸»å¯¼æƒ…å†µ
    py = 2 * dx1 - dy1;  // å¯¹åº”å‚ç›´ä¸»å¯¼æƒ…å†µ

    // æ ¹æ®æ–œç‡é€‰æ‹©ä¸»å¯¼æ–¹å‘
    if (dy1 <= dx1) {  // |æ–œç‡| â‰¤ 1ï¼Œæ°´å¹³ä¸»å¯¼
        // ç¡®ä¿ä»å·¦åˆ°å³ç»˜åˆ¶
        if (dx >= 0) { x = x1; y = y1; xe = x2; }
        else { x = x2; y = y2; xe = x1; }

        set_pixel(Eigen::Vector3f(x, y, 1.0f), line_color);

        for (i = 0; x < xe; i++) {
            x = x + 1;
            if (px < 0) {
                px = px + 2 * dy1;  // é€‰æ‹©æ°´å¹³åƒç´ 
            } else {
                // é€‰æ‹©å¯¹è§’åƒç´ ï¼Œyåæ ‡éœ€è¦æ ¹æ®æ–¹å‘è°ƒæ•´
                if ((dx < 0 && dy < 0) || (dx > 0 && dy > 0)) {
                    y = y + 1;
                } else {
                    y = y - 1;
                }
                px = px + 2 * (dy1 - dx1);
            }
            set_pixel(Eigen::Vector3f(x, y, 1.0f), line_color);
        }
    } else {  // |æ–œç‡| > 1ï¼Œå‚ç›´ä¸»å¯¼
        // ç±»ä¼¼å¤„ç†ï¼Œä½†ä»¥yä¸ºä¸»å¯¼æ–¹å‘
        // ... å‚ç›´ä¸»å¯¼çš„å®ç°
    }
}
```

#### ç®—æ³•ä¼˜åŒ–ä¸å˜ç§

**æ•´æ•°ä¼˜åŒ–**ï¼š

- æ‰€æœ‰è®¡ç®—éƒ½ä½¿ç”¨æ•´æ•°è¿ç®—
- é¿å…æµ®ç‚¹æ•°å’Œé™¤æ³•è¿ç®—
- æ—¶é—´å¤æ‚åº¦ï¼š$O(max(|x_1-x_0|, |y_1-y_0|))$

**å¯¹ç§°æ€§å¤„ç†**ï¼š

- é€šè¿‡äº¤æ¢åæ ‡å¤„ç†ä¸åŒè±¡é™çš„ç›´çº¿
- ç»Ÿä¸€å¤„ç†å„ç§æ–œç‡æƒ…å†µ

**æŠ—é”¯é½¿æ‰©å±•**ï¼š

- Wu'sç®—æ³•ï¼šè€ƒè™‘åƒç´ è¦†ç›–é¢ç§¯
- è¶…é‡‡æ ·ï¼šæé«˜é‡‡æ ·ç‡åä¸‹é‡‡æ ·

---

## å‡ ä½•å˜æ¢æ•°å­¦åŸç†

## 2.1 çº¿æ€§å˜æ¢ç†è®º

### 2.1.1 çº¿æ€§å˜æ¢çš„æ•°å­¦å®šä¹‰

**ä¸¥æ ¼æ•°å­¦å®šä¹‰**ï¼šè®¾ $V$ å’Œ $W$ æ˜¯å‘é‡ç©ºé—´ï¼Œæ˜ å°„ $T: V \to W$ ç§°ä¸ºçº¿æ€§å˜æ¢ï¼Œå½“ä¸”ä»…å½“å¯¹äºä»»æ„ $\vec{u}, \vec{v} \in V$ å’Œæ ‡é‡ $k$ï¼Œæ»¡è¶³ï¼š

1. **åŠ æ³•ä¿æŒæ€§ï¼ˆå¯åŠ æ€§ï¼‰**ï¼š$T(\vec{u} + \vec{v}) = T(\vec{u}) + T(\vec{v})$
2. **æ•°ä¹˜ä¿æŒæ€§ï¼ˆé½æ¬¡æ€§ï¼‰**ï¼š$T(k\vec{u}) = kT(\vec{u})$

**ç­‰ä»·æ¡ä»¶**ï¼šçº¿æ€§å˜æ¢ä¹Ÿå¯ä»¥ç”¨å•ä¸€æ¡ä»¶è¡¨ç¤ºï¼š
$$T(\alpha\vec{u} + \beta\vec{v}) = \alpha T(\vec{u}) + \beta T(\vec{v})$$

**çŸ©é˜µè¡¨ç¤ºå®šç†**ï¼š
å¯¹äºæœ‰é™ç»´å‘é‡ç©ºé—´ï¼Œä»»ä½•çº¿æ€§å˜æ¢ $T: \mathbb{R}^n \to \mathbb{R}^m$ éƒ½å¯ä»¥å”¯ä¸€åœ°è¡¨ç¤ºä¸ºçŸ©é˜µä¹˜æ³•ï¼š
$$T(\vec{v}) = A\vec{v}$$
å…¶ä¸­ $A \in \mathbb{R}^{m \times n}$ æ˜¯å˜æ¢çŸ©é˜µã€‚

**å˜æ¢çŸ©é˜µçš„æ„é€ **ï¼š
å˜æ¢çŸ©é˜µ $A$ çš„ç¬¬ $j$ åˆ—æ˜¯æ ‡å‡†åŸºå‘é‡ $\vec{e_j}$ çš„åƒï¼š
$$A = [T(\vec{e_1}) \quad T(\vec{e_2}) \quad \cdots \quad T(\vec{e_n})]$$

**çº¿æ€§å˜æ¢çš„é‡è¦æ€§è´¨**ï¼š

- **é›¶å‘é‡ä¿æŒ**ï¼š$T(\vec{0}) = \vec{0}$
- **çº¿æ€§ç»„åˆä¿æŒ**ï¼š$T(\sum_i \alpha_i \vec{v_i}) = \sum_i \alpha_i T(\vec{v_i})$
- **å­ç©ºé—´ä¿æŒ**ï¼šçº¿æ€§å­ç©ºé—´çš„åƒä»æ˜¯çº¿æ€§å­ç©ºé—´
- **å¹³è¡Œçº¿ä¿æŒ**ï¼šå¹³è¡Œçº¿å˜æ¢åä»å¹³è¡Œï¼ˆæˆ–é‡åˆï¼‰
- **åŸç‚¹å›ºå®š**ï¼šçº¿æ€§å˜æ¢æ€»æ˜¯å°†åŸç‚¹æ˜ å°„åˆ°åŸç‚¹

### 2.1.2 åŸºæœ¬çº¿æ€§å˜æ¢

#### ç¼©æ”¾å˜æ¢ï¼ˆScaling Transformï¼‰

**æ•°å­¦å®šä¹‰**ï¼š
ç¼©æ”¾å˜æ¢æ˜¯ä¸€ç§çº¿æ€§å˜æ¢ï¼Œå°†å‘é‡çš„å„ä¸ªåˆ†é‡åˆ†åˆ«ä¹˜ä»¥å¯¹åº”çš„ç¼©æ”¾å› å­ï¼š
$$S(s_x, s_y, s_z): \begin{pmatrix} x \\ y \\ z \end{pmatrix} \mapsto \begin{pmatrix} s_x \cdot x \\ s_y \cdot y \\ s_z \cdot z \end{pmatrix}$$

**é½æ¬¡åæ ‡çŸ©é˜µè¡¨ç¤º**ï¼š

ç¼©æ”¾å˜æ¢çŸ©é˜µ $S(s_x, s_y, s_z)$ æ˜¯ä¸€ä¸ª $4 \times 4$ å¯¹è§’çŸ©é˜µï¼š

- å¯¹è§’çº¿å…ƒç´ ï¼š$(s_x, s_y, s_z, 1)$
- å…¶ä»–å…ƒç´ å‡ä¸º0

$$S(s_x, s_y, s_z) = \text{diag}(s_x, s_y, s_z, 1)$$

**å‡ ä½•æ•ˆæœåˆ†æ**ï¼š

- **å‡åŒ€ç¼©æ”¾**ï¼š$s_x = s_y = s_z = s$
  - $s > 1$ï¼šç‰©ä½“æ”¾å¤§ $s$ å€
  - $0 < s < 1$ï¼šç‰©ä½“ç¼©å°ä¸ºåŸæ¥çš„ $s$ å€
  - $s = 1$ï¼šæ’ç­‰å˜æ¢
- **éå‡åŒ€ç¼©æ”¾**ï¼š$s_x, s_y, s_z$ ä¸å…¨ç›¸ç­‰
  - æ”¹å˜ç‰©ä½“çš„é•¿å®½é«˜æ¯”ä¾‹
  - å¯èƒ½å¯¼è‡´åœ†å˜æ¤­åœ†ç­‰å½¢å˜
- **åå°„ç¼©æ”¾**ï¼šæŸä¸ª $s_i < 0$
  - $s_i = -1$ï¼šæ²¿ç¬¬ $i$ è½´åå°„
  - $s_i < -1$ï¼šåå°„å¹¶æ”¾å¤§
  - $-1 < s_i < 0$ï¼šåå°„å¹¶ç¼©å°

**é‡è¦æ€§è´¨**ï¼š

- **å¯é€†æ€§**ï¼šå½“æ‰€æœ‰ $s_i \neq 0$ æ—¶ï¼Œ$S^{-1}(s_x, s_y, s_z) = S(1/s_x, 1/s_y, 1/s_z)$
- **è¡Œåˆ—å¼**ï¼š$\det(S) = s_x \cdot s_y \cdot s_z$ï¼ˆä½“ç§¯ç¼©æ”¾å› å­ï¼‰
- **ç‰¹å¾å€¼**ï¼šå¯¹è§’å…ƒç´  $s_x, s_y, s_z$ å°±æ˜¯ç‰¹å¾å€¼
- **äº¤æ¢æ€§**ï¼šç¼©æ”¾çŸ©é˜µä¹‹é—´æ»¡è¶³äº¤æ¢å¾‹

**GAMES101é¡¹ç›®å®ç°**ï¼š

```cpp
Eigen::Matrix4f create_scaling_matrix(float sx, float sy, float sz) {
    Eigen::Matrix4f scaling = Eigen::Matrix4f::Identity();
    scaling(0, 0) = sx;
    scaling(1, 1) = sy;
    scaling(2, 2) = sz;
    return scaling;
}

// åº”ç”¨ç¤ºä¾‹ï¼šåœ¨Assignment 1ä¸­ç¼©æ”¾ä¸‰è§’å½¢
Matrix4f model = create_scaling_matrix(1.5f, 1.5f, 1.5f);  // æ”¾å¤§1.5å€
for (auto& vertex : triangle_vertices) {
    Vector4f scaled_vertex = model * Vector4f(vertex.x, vertex.y, vertex.z, 1.0f);
    vertex = scaled_vertex.head<3>();
}
```

**ç‰¹æ®Šç¼©æ”¾å˜æ¢**ï¼š

- **å„å‘åŒæ€§ç¼©æ”¾**ï¼š$S(s, s, s)$ - ä¿æŒå½¢çŠ¶ï¼Œåªæ”¹å˜å¤§å°
- **æ²¿è½´ç¼©æ”¾**ï¼š$S(s, 1, 1)$ - åªæ²¿xè½´ç¼©æ”¾
- **é•œåƒå˜æ¢**ï¼š$S(-1, 1, 1)$ - æ²¿xè½´é•œåƒ

#### æ—‹è½¬å˜æ¢ï¼ˆRotation Transformï¼‰

### ç»•åæ ‡è½´æ—‹è½¬çš„æ•°å­¦æ¨å¯¼

**ç»•Zè½´æ—‹è½¬çš„è¯¦ç»†æ¨å¯¼**ï¼š
è®¾ç‚¹ $P(x, y)$ ç»•åŸç‚¹é€†æ—¶é’ˆæ—‹è½¬è§’åº¦ $\theta$ åˆ°ç‚¹ $P'(x', y')$ã€‚

**æåæ ‡æ–¹æ³•**ï¼š
å°†ç‚¹ $P$ è¡¨ç¤ºä¸ºæåæ ‡å½¢å¼ï¼š

- $P: (r\cos\phi, r\sin\phi)$ï¼Œå…¶ä¸­ $r = \sqrt{x^2 + y^2}$ï¼Œ$\phi = \arctan(y/x)$
- $P': (r\cos(\phi + \theta), r\sin(\phi + \theta))$

åˆ©ç”¨ä¸‰è§’æ’ç­‰å¼ï¼š

å¯¹äº x åæ ‡ï¼š
$$x' = r\cos(\phi + \theta) = r(\cos\phi\cos\theta - \sin\phi\sin\theta) = x\cos\theta - y\sin\theta$$

å¯¹äº y åæ ‡ï¼š
$$y' = r\sin(\phi + \theta) = r(\sin\phi\cos\theta + \cos\phi\sin\theta) = x\sin\theta + y\cos\theta$$

**çŸ©é˜µå½¢å¼**ï¼š

ç»• z è½´æ—‹è½¬çŸ©é˜µ $R_z(\theta)$ çš„ç»“æ„ï¼š

- å·¦ä¸Šè§’ $2 \times 2$ å­çŸ©é˜µï¼šæ ‡å‡†2Dæ—‹è½¬çŸ©é˜µï¼Œå…ƒç´ ä¸º $(\cos\theta, -\sin\theta; \sin\theta, \cos\theta)$
- z åæ ‡ä¸å˜ï¼šç¬¬3è¡Œç¬¬3åˆ—ä¸º1
- é½æ¬¡åæ ‡ï¼šç¬¬4è¡Œç¬¬4åˆ—ä¸º1
- å…¶ä»–å…ƒç´ ä¸º0

$$R_z(\theta) = \text{rotation matrix around z-axis}$$

**å…¶ä»–åæ ‡è½´æ—‹è½¬**ï¼š

**ç»• x è½´æ—‹è½¬** $R_x(\theta)$ï¼š

- x åæ ‡ä¸å˜ï¼šç¬¬1è¡Œç¬¬1åˆ—ä¸º1
- yz å¹³é¢å†…æ—‹è½¬ï¼šç¬¬2,3è¡Œç¬¬2,3åˆ—ä¸º $2 \times 2$ æ—‹è½¬çŸ©é˜µ
- é½æ¬¡åæ ‡ï¼šç¬¬4è¡Œç¬¬4åˆ—ä¸º1

**ç»• y è½´æ—‹è½¬** $R_y(\theta)$ï¼š

- y åæ ‡ä¸å˜ï¼šç¬¬2è¡Œç¬¬2åˆ—ä¸º1
- xz å¹³é¢å†…æ—‹è½¬ï¼šæ³¨æ„ $\sin\theta$ çš„ç¬¦å·ä¸å…¶ä»–è½´ç›¸å
- é½æ¬¡åæ ‡ï¼šç¬¬4è¡Œç¬¬4åˆ—ä¸º1

**æ—‹è½¬çŸ©é˜µçš„é‡è¦æ€§è´¨**ï¼š

- **æ­£äº¤æ€§**ï¼š$R^T R = I$ï¼Œå³ $R^{-1} = R^T$
- **è¡Œåˆ—å¼**ï¼š$\det(R) = 1$ï¼ˆä¿æŒå®šå‘ï¼‰
- **é•¿åº¦ä¿æŒ**ï¼š$\|R\vec{v}\| = \|\vec{v}\|$
- **è§’åº¦ä¿æŒ**ï¼š$\vec{u} \cdot \vec{v} = (R\vec{u}) \cdot (R\vec{v})$

**GAMES101 Assignment 1å®ç°**ï¼š

```cpp
Eigen::Matrix4f get_model_matrix(float rotation_angle) {
    Eigen::Matrix4f model = Eigen::Matrix4f::Identity();

    // è§’åº¦è½¬å¼§åº¦
    float angle_rad = rotation_angle * MY_PI / 180.0f;
    float cos_a = std::cos(angle_rad);
    float sin_a = std::sin(angle_rad);

    // ç»•Zè½´æ—‹è½¬çŸ©é˜µ
    model(0, 0) = cos_a;   model(0, 1) = -sin_a;
    model(1, 0) = sin_a;   model(1, 1) = cos_a;

    return model;
}
```

### ä»»æ„è½´æ—‹è½¬ï¼ˆRodriguesæ—‹è½¬å…¬å¼ï¼‰

**é—®é¢˜æè¿°**ï¼šç»™å®šå•ä½å‘é‡ $\vec{n}$ å’Œè§’åº¦ $\theta$ï¼Œæ±‚ç»•è½´ $\vec{n}$ æ—‹è½¬ $\theta$ è§’åº¦çš„æ—‹è½¬çŸ©é˜µã€‚

**Rodrigueså…¬å¼æ¨å¯¼**ï¼š
å¯¹äºä»»æ„å‘é‡ $\vec{v}$ï¼Œç»•å•ä½è½´ $\vec{n}$ æ—‹è½¬ $\theta$ è§’åº¦åçš„ç»“æœä¸ºï¼š
$$\vec{v}_{rot} = \vec{v}\cos\theta + (\vec{n} \times \vec{v})\sin\theta + \vec{n}(\vec{n} \cdot \vec{v})(1-\cos\theta)$$

**çŸ©é˜µå½¢å¼çš„Rodrigueså…¬å¼**ï¼š
$$R(\vec{n}, \theta) = I\cos\theta + [\vec{n}]_{\times}\sin\theta + \vec{n}\vec{n}^T(1-\cos\theta)$$

å…¶ä¸­ $[\vec{n}]_{\times}$ æ˜¯ $\vec{n} = (n_x, n_y, n_z)$ çš„åå¯¹ç§°çŸ©é˜µï¼ˆå‰ç§¯çŸ©é˜µï¼‰ï¼š

åå¯¹ç§°çŸ©é˜µçš„ç»“æ„ï¼š

- å¯¹è§’çº¿å…ƒç´ å…¨ä¸º0
- ç¬¬1è¡Œï¼š$(0, -n_z, n_y)$
- ç¬¬2è¡Œï¼š$(n_z, 0, -n_x)$
- ç¬¬3è¡Œï¼š$(-n_y, n_x, 0)$

$$[\vec{n}]_{\times} = \text{skew-symmetric matrix of } \vec{n}$$

**å…¬å¼çš„å‡ ä½•æ„ä¹‰**ï¼š

- $\vec{n}\vec{n}^T(1-\cos\theta)$ï¼šå‘é‡åœ¨æ—‹è½¬è½´ä¸Šçš„æŠ•å½±åˆ†é‡ï¼ˆä¸å˜éƒ¨åˆ†ï¼‰
- $I\cos\theta$ï¼šå‚ç›´äºæ—‹è½¬è½´çš„åˆ†é‡çš„ä½™å¼¦éƒ¨åˆ†
- $[\vec{n}]_{\times}\sin\theta$ï¼šå‚ç›´äºæ—‹è½¬è½´çš„åˆ†é‡çš„æ­£å¼¦éƒ¨åˆ†

**æ¨å¯¼è¿‡ç¨‹**ï¼š

1. å°†å‘é‡ $\vec{v}$ åˆ†è§£ä¸ºå¹³è¡Œå’Œå‚ç›´äº $\vec{n}$ çš„åˆ†é‡ï¼š
   $$\vec{v} = \vec{v}_{\parallel} + \vec{v}_{\perp}$$
   å…¶ä¸­ $\vec{v}_{\parallel} = (\vec{v} \cdot \vec{n})\vec{n}$ï¼Œ$\vec{v}_{\perp} = \vec{v} - \vec{v}_{\parallel}$

2. å¹³è¡Œåˆ†é‡ä¸å—æ—‹è½¬å½±å“ï¼š$\vec{v}_{\parallel}' = \vec{v}_{\parallel}$

3. å‚ç›´åˆ†é‡åœ¨å‚ç›´äº $\vec{n}$ çš„å¹³é¢å†…æ—‹è½¬ï¼š
   $$\vec{v}_{\perp}' = \vec{v}_{\perp}\cos\theta + (\vec{n} \times \vec{v}_{\perp})\sin\theta$$

**GAMES101é¡¹ç›®å®ç°**ï¼š

```cpp
Eigen::Matrix4f get_rotation(Vector3f axis, float angle) {
    // ç¡®ä¿è½´å‘é‡ä¸ºå•ä½å‘é‡
    axis.normalize();
    float theta = angle * MY_PI / 180.0f;

    // æ„å»º3x3æ—‹è½¬çŸ©é˜µ
    Eigen::Matrix3f I = Eigen::Matrix3f::Identity();

    // åå¯¹ç§°çŸ©é˜µ [n]Ã—
    Eigen::Matrix3f N;
    N << 0, -axis[2], axis[1],
         axis[2], 0, -axis[0],
         -axis[1], axis[0], 0;

    // å¤–ç§¯çŸ©é˜µ nnáµ€
    Eigen::Matrix3f nnT = axis * axis.transpose();

    // Rodrigueså…¬å¼
    Eigen::Matrix3f R = I * cos(theta) +
                        N * sin(theta) +
                        nnT * (1 - cos(theta));

    // æ‰©å±•ä¸º4x4é½æ¬¡çŸ©é˜µ
    Eigen::Matrix4f rotation_matrix = Eigen::Matrix4f::Identity();
    rotation_matrix.block<3,3>(0,0) = R;

    return rotation_matrix;
}
```

**ç‰¹æ®Šæƒ…å†µéªŒè¯**ï¼š

- å½“ $\vec{n} = (0,0,1)$ æ—¶ï¼Œé€€åŒ–ä¸ºç»•Zè½´æ—‹è½¬
- å½“ $\theta = 0$ æ—¶ï¼Œ$R = I$ï¼ˆæ’ç­‰å˜æ¢ï¼‰
- å½“ $\theta = \pi$ æ—¶ï¼Œ$R = 2\vec{n}\vec{n}^T - I$ï¼ˆå…³äºè½´çš„180Â°æ—‹è½¬ï¼‰

## 2.2 ä»¿å°„å˜æ¢ç†è®º

### 2.2.1 ä»¿å°„å˜æ¢çš„æ•°å­¦ç‰¹æ€§

#### ä»¿å°„å˜æ¢çš„ä¸¥æ ¼å®šä¹‰

**æ•°å­¦å®šä¹‰**ï¼šä»¿å°„å˜æ¢æ˜¯çº¿æ€§å˜æ¢ä¸å¹³ç§»çš„å¤åˆï¼Œå¯¹äºå‘é‡ç©ºé—´ $\mathbb{R}^n$ï¼Œä»¿å°„å˜æ¢ $T: \mathbb{R}^n \to \mathbb{R}^n$ å®šä¹‰ä¸ºï¼š
$$T(\vec{v}) = A\vec{v} + \vec{b}$$
å…¶ä¸­ $A \in \mathbb{R}^{n \times n}$ æ˜¯çº¿æ€§å˜æ¢çŸ©é˜µï¼Œ$\vec{b} \in \mathbb{R}^n$ æ˜¯å¹³ç§»å‘é‡ã€‚

**ä»¿å°„ç©ºé—´çš„æ¦‚å¿µ**ï¼š
ä»¿å°„ç©ºé—´æ˜¯æ²¡æœ‰å›ºå®šåŸç‚¹çš„å‡ ä½•ç©ºé—´ï¼Œä»¿å°„å˜æ¢åœ¨ä»¿å°„ç©ºé—´ä¸­å…·æœ‰ç‰¹æ®Šæ„ä¹‰ï¼š

- **ç‚¹çš„å˜æ¢**ï¼š$P' = AP + \vec{b}$
- **å‘é‡çš„å˜æ¢**ï¼š$\vec{v}' = A\vec{v}$ï¼ˆå‘é‡ä¸å—å¹³ç§»å½±å“ï¼‰

#### ä»¿å°„å˜æ¢çš„å‡ ä½•æ€§è´¨

**ä¿æŒæ€§è´¨ï¼ˆä¸å˜é‡ï¼‰**ï¼š

1. **ç›´çº¿æ€§ä¿æŒ**ï¼šç›´çº¿ $L: \vec{p}(t) = \vec{p_0} + t\vec{d}$ å˜æ¢åä»ä¸ºç›´çº¿
   $$L': \vec{p}'(t) = A\vec{p_0} + \vec{b} + tA\vec{d}$$

2. **å¹³è¡Œæ€§ä¿æŒ**ï¼šå¹³è¡Œç›´çº¿å˜æ¢åä»å¹³è¡Œ
   - è¯æ˜ï¼šå¹³è¡Œçº¿å…·æœ‰ç›¸åŒæ–¹å‘å‘é‡ï¼Œ$A\vec{d}$ ä¿æŒæ–¹å‘å…³ç³»

3. **æ¯”ä¾‹ä¿æŒ**ï¼šçº¿æ®µä¸Šçš„æ¯”ä¾‹å…³ç³»ä¿æŒä¸å˜
   - è‹¥ $\vec{p} = (1-t)\vec{p_1} + t\vec{p_2}$ï¼Œåˆ™ $\vec{p}' = (1-t)\vec{p_1}' + t\vec{p_2}'$

4. **é‡å¿ƒä¿æŒ**ï¼šç‚¹é›†çš„é‡å¿ƒå˜æ¢åä»ä¸ºå˜æ¢åç‚¹é›†çš„é‡å¿ƒ

**ä¸ä¿æŒçš„æ€§è´¨**ï¼š

- **é•¿åº¦**ï¼š$\|\vec{v}'\| \neq \|\vec{v}\|$ï¼ˆé™¤é $A$ æ˜¯æ­£äº¤çŸ©é˜µï¼‰
- **è§’åº¦**ï¼š$\angle(\vec{u}, \vec{v}) \neq \angle(\vec{u}', \vec{v}')$ï¼ˆé™¤é $A$ æ˜¯ç›¸ä¼¼å˜æ¢ï¼‰
- **é¢ç§¯/ä½“ç§¯**ï¼šç¼©æ”¾å› å­ä¸º $|\det(A)|$

#### ä»¿å°„å˜æ¢çš„åˆ†ç±»

**æŒ‰å‡ ä½•æ•ˆæœåˆ†ç±»**ï¼š

1. **åˆšä½“å˜æ¢ï¼ˆRigid Transformï¼‰**ï¼š$A$ æ˜¯æ­£äº¤çŸ©é˜µï¼Œ$\det(A) = 1$
   - ä¿æŒé•¿åº¦ã€è§’åº¦ã€é¢ç§¯
   - åªåŒ…å«æ—‹è½¬å’Œå¹³ç§»

2. **ç›¸ä¼¼å˜æ¢ï¼ˆSimilarity Transformï¼‰**ï¼š$A = sR$ï¼Œ$s > 0$ï¼Œ$R$ æ˜¯æ­£äº¤çŸ©é˜µ
   - ä¿æŒè§’åº¦å’Œå½¢çŠ¶
   - åŒ…å«å‡åŒ€ç¼©æ”¾ã€æ—‹è½¬ã€å¹³ç§»

3. **ä¸€èˆ¬ä»¿å°„å˜æ¢**ï¼šä»»æ„å¯é€†çŸ©é˜µ $A$
   - å¯èƒ½åŒ…å«å‰ªåˆ‡ã€éå‡åŒ€ç¼©æ”¾ç­‰

**æŒ‰å˜æ¢åˆ†è§£åˆ†ç±»**ï¼š
ä»»ä½•ä»¿å°„å˜æ¢éƒ½å¯ä»¥åˆ†è§£ä¸ºåŸºæœ¬å˜æ¢çš„å¤åˆï¼š
$$T = T_{trans} \circ T_{rot} \circ T_{scale} \circ T_{shear}$$

### 2.2.2 å¹³ç§»å˜æ¢çš„æ·±åº¦åˆ†æ

#### å¹³ç§»å˜æ¢çš„æ•°å­¦æœ¬è´¨

**ä¸ºä»€ä¹ˆå¹³ç§»ä¸æ˜¯çº¿æ€§å˜æ¢**ï¼š
çº¿æ€§å˜æ¢å¿…é¡»æ»¡è¶³ï¼š

1. $T(\vec{0}) = \vec{0}$ï¼ˆé›¶å‘é‡ä¿æŒï¼‰
2. $T(\alpha\vec{u} + \beta\vec{v}) = \alpha T(\vec{u}) + \beta T(\vec{v})$ï¼ˆçº¿æ€§æ€§ï¼‰

ä½†å¹³ç§»å˜æ¢ $T(\vec{v}) = \vec{v} + \vec{t}$ ä¸æ»¡è¶³ç¬¬ä¸€ä¸ªæ¡ä»¶ï¼š
$$T(\vec{0}) = \vec{0} + \vec{t} = \vec{t} \neq \vec{0} \quad (\text{å½“} \vec{t} \neq \vec{0})$$

**ä»¿å°„å˜æ¢çš„å¼•å…¥**ï¼š
ä¸ºäº†ç»Ÿä¸€å¤„ç†çº¿æ€§å˜æ¢å’Œå¹³ç§»ï¼Œå¼•å…¥ä»¿å°„å˜æ¢ï¼š
$$T(\vec{v}) = A\vec{v} + \vec{t}$$

#### é½æ¬¡åæ ‡ä¸­çš„å¹³ç§»è¡¨ç¤º

**é½æ¬¡åæ ‡çŸ©é˜µ**ï¼š

å¹³ç§»å˜æ¢çŸ©é˜µ $T(t_x, t_y, t_z)$ çš„ç»“æ„ï¼š

- å·¦ä¸Šè§’ $3 \times 3$ å­çŸ©é˜µä¸ºå•ä½çŸ©é˜µ
- ç¬¬4åˆ—å‰ä¸‰ä¸ªå…ƒç´ ä¸ºå¹³ç§»å‘é‡ $(t_x, t_y, t_z)$
- ç¬¬4è¡Œä¸º $(0, 0, 0, 1)$

$$T(t_x, t_y, t_z) = \text{translation matrix}$$

**å˜æ¢è¿‡ç¨‹çš„æ•°å­¦éªŒè¯**ï¼š

å¯¹äºç‚¹ $(x, y, z, 1)$ï¼Œå¹³ç§»å˜æ¢çš„ç»“æœä¸ºï¼š
$$(x, y, z, 1) \xrightarrow{T(t_x, t_y, t_z)} (x + t_x, y + t_y, z + t_z, 1)$$

**å‘é‡ä¸ç‚¹çš„åŒºåˆ«**ï¼š

- **ç‚¹çš„å¹³ç§»**ï¼š$(x, y, z, 1) \to (x+t_x, y+t_y, z+t_z, 1)$
- **å‘é‡çš„å¹³ç§»**ï¼š$(x, y, z, 0) \to (x, y, z, 0)$ï¼ˆå‘é‡ä¸å—å¹³ç§»å½±å“ï¼‰

è¿™æ­£ç¡®åæ˜ äº†å‡ ä½•ç›´è§‰ï¼šå‘é‡è¡¨ç¤ºæ–¹å‘å’Œå¤§å°ï¼Œä¸ä½ç½®æ— å…³ã€‚

#### å¹³ç§»å˜æ¢çš„æ€§è´¨

**ç¾¤è®ºæ€§è´¨**ï¼š
å¹³ç§»å˜æ¢æ„æˆä¸€ä¸ªäº¤æ¢ç¾¤ $(T, \circ)$ï¼š

1. **å°é—­æ€§**ï¼š$T(\vec{a}) \circ T(\vec{b}) = T(\vec{a} + \vec{b})$
2. **ç»“åˆå¾‹**ï¼š$(T(\vec{a}) \circ T(\vec{b})) \circ T(\vec{c}) = T(\vec{a}) \circ (T(\vec{b}) \circ T(\vec{c}))$
3. **å•ä½å…ƒ**ï¼š$T(\vec{0})$ æ˜¯æ’ç­‰å˜æ¢
4. **é€†å…ƒ**ï¼š$T(\vec{a})^{-1} = T(-\vec{a})$
5. **äº¤æ¢å¾‹**ï¼š$T(\vec{a}) \circ T(\vec{b}) = T(\vec{b}) \circ T(\vec{a})$

**çŸ©é˜µè¡¨ç¤ºçš„ä¼˜åŠ¿**ï¼š

```cpp
// ä¼ ç»Ÿæ–¹æ³•ï¼šéœ€è¦ç‰¹æ®Šå¤„ç†
Vector3f translate_point(const Vector3f& point, const Vector3f& translation) {
    return point + translation;
}

Vector3f translate_vector(const Vector3f& vector, const Vector3f& translation) {
    return vector;  // å‘é‡ä¸å—å¹³ç§»å½±å“
}

// é½æ¬¡åæ ‡æ–¹æ³•ï¼šç»Ÿä¸€å¤„ç†
Matrix4f translation_matrix = create_translation_matrix(tx, ty, tz);
Vector4f result_point = translation_matrix * Vector4f(point.x, point.y, point.z, 1.0f);
Vector4f result_vector = translation_matrix * Vector4f(vector.x, vector.y, vector.z, 0.0f);
```

#### GAMES101é¡¹ç›®ä¸­çš„åº”ç”¨

**åˆ›å»ºå¹³ç§»çŸ©é˜µ**ï¼š

```cpp
Eigen::Matrix4f create_translation_matrix(float tx, float ty, float tz) {
    Eigen::Matrix4f translation = Eigen::Matrix4f::Identity();
    translation(0, 3) = tx;
    translation(1, 3) = ty;
    translation(2, 3) = tz;
    return translation;
}

// Assignment 1ä¸­çš„è§†å›¾å˜æ¢
Eigen::Matrix4f get_view_matrix(Eigen::Vector3f eye_pos) {
    Eigen::Matrix4f view = Eigen::Matrix4f::Identity();

    // å¹³ç§»åˆ°åŸç‚¹ï¼ˆç›¸æœºä½ç½®çš„é€†å˜æ¢ï¼‰
    Eigen::Matrix4f translate = create_translation_matrix(-eye_pos[0], -eye_pos[1], -eye_pos[2]);

    view = translate * view;
    return view;
}
```

### 2.2.3 å˜æ¢å¤åˆçš„æ•°å­¦ç†è®º

#### å˜æ¢å¤åˆçš„åŸºæœ¬åŸç†

**å‡½æ•°å¤åˆçš„å®šä¹‰**ï¼š
å¯¹äºå˜æ¢ $T_1, T_2, T_3$ï¼Œå¤åˆå˜æ¢å®šä¹‰ä¸ºï¼š
$$(T_3 \circ T_2 \circ T_1)(\vec{v}) = T_3(T_2(T_1(\vec{v})))$$

**çŸ©é˜µä¹˜æ³•å¯¹åº”å…³ç³»**ï¼š
åœ¨é½æ¬¡åæ ‡ç³»ç»Ÿä¸­ï¼Œå˜æ¢å¤åˆå¯¹åº”çŸ©é˜µä¹˜æ³•ï¼š
$$T_3 \circ T_2 \circ T_1 \longleftrightarrow M_3 M_2 M_1$$

**é‡è¦æ³¨æ„**ï¼šçŸ©é˜µä¹˜æ³•çš„é¡ºåºä¸å˜æ¢åº”ç”¨é¡ºåºç›¸åï¼

- å˜æ¢åº”ç”¨é¡ºåºï¼š$T_1 \to T_2 \to T_3$
- çŸ©é˜µä¹˜æ³•é¡ºåºï¼š$M_3 M_2 M_1$

#### å˜æ¢é¡ºåºçš„é‡è¦æ€§

**éäº¤æ¢æ€§è¯æ˜**ï¼š
è€ƒè™‘å¹³ç§» $T(1,0,0)$ å’Œç»•Zè½´æ—‹è½¬90Â°çš„å¤åˆï¼š

**é¡ºåº1**ï¼šå…ˆå¹³ç§»åæ—‹è½¬
$$R_{90Â°} \circ T(1,0,0): (0,0,0) \to (1,0,0) \to (0,1,0)$$

**é¡ºåº2**ï¼šå…ˆæ—‹è½¬åå¹³ç§»
$$T(1,0,0) \circ R_{90Â°}: (0,0,0) \to (0,0,0) \to (1,0,0)$$

ç»“æœä¸åŒï¼Œè¯´æ˜å˜æ¢é¡ºåºè‡³å…³é‡è¦ï¼

#### æ ‡å‡†å˜æ¢åºåˆ—ï¼ˆSRTåˆ†è§£ï¼‰

**Scale-Rotate-Translateé¡ºåº**ï¼š
$$M_{total} = T \cdot R \cdot S$$

**ä¸ºä»€ä¹ˆé‡‡ç”¨SRTé¡ºåº**ï¼š

1. **ç¼©æ”¾ï¼ˆScaleï¼‰**ï¼šåœ¨å±€éƒ¨åæ ‡ç³»ä¸­è¿›è¡Œï¼Œä¸å½±å“ç‰©ä½“çš„æœå‘
2. **æ—‹è½¬ï¼ˆRotateï¼‰**ï¼šåœ¨ç¼©æ”¾åçš„åæ ‡ç³»ä¸­è¿›è¡Œï¼Œä¿æŒç‰©ä½“å½¢çŠ¶
3. **å¹³ç§»ï¼ˆTranslateï¼‰**ï¼šæœ€åç§»åŠ¨åˆ°ä¸–ç•Œåæ ‡ç³»ä¸­çš„ç›®æ ‡ä½ç½®

**æ•°å­¦éªŒè¯**ï¼š

```cpp
// é”™è¯¯é¡ºåºï¼šRSTï¼ˆæ—‹è½¬-ç¼©æ”¾-å¹³ç§»ï¼‰
Matrix4f wrong_order = T * S * R;
// é—®é¢˜ï¼šç¼©æ”¾ä¼šå½±å“å·²ç»æ—‹è½¬çš„ç‰©ä½“ï¼Œå¯èƒ½å¯¼è‡´éå‡åŒ€æ‹‰ä¼¸

// æ­£ç¡®é¡ºåºï¼šSRTï¼ˆç¼©æ”¾-æ—‹è½¬-å¹³ç§»ï¼‰
Matrix4f correct_order = T * R * S;
// ä¼˜åŠ¿ï¼šæ¯ä¸ªå˜æ¢éƒ½åœ¨åˆé€‚çš„åæ ‡ç³»ä¸­è¿›è¡Œ
```

#### å›¾å½¢å­¦ä¸­çš„å˜æ¢é“¾

**å®Œæ•´çš„MVPå˜æ¢é“¾**ï¼š
$$\text{å±å¹•åæ ‡} = M_{viewport} \cdot M_{projection} \cdot M_{view} \cdot M_{model} \cdot \text{å±€éƒ¨åæ ‡}$$

**å„é˜¶æ®µçš„ä½œç”¨**ï¼š

1. **æ¨¡å‹å˜æ¢ï¼ˆModelï¼‰**ï¼šå±€éƒ¨åæ ‡ â†’ ä¸–ç•Œåæ ‡
2. **è§†å›¾å˜æ¢ï¼ˆViewï¼‰**ï¼šä¸–ç•Œåæ ‡ â†’ è§‚å¯Ÿåæ ‡
3. **æŠ•å½±å˜æ¢ï¼ˆProjectionï¼‰**ï¼šè§‚å¯Ÿåæ ‡ â†’ è£å‰ªåæ ‡
4. **è§†å£å˜æ¢ï¼ˆViewportï¼‰**ï¼šNDC â†’ å±å¹•åæ ‡

#### GAMES101é¡¹ç›®å®ç°

**Assignment 1ä¸­çš„å˜æ¢é“¾**ï¼š

```cpp
// æ„å»ºå®Œæ•´çš„MVPçŸ©é˜µ
Eigen::Matrix4f get_model_matrix(float rotation_angle) {
    // æ¨¡å‹å˜æ¢ï¼šåªåŒ…å«æ—‹è½¬
    Eigen::Matrix4f model = Eigen::Matrix4f::Identity();
    float angle_rad = rotation_angle * MY_PI / 180.0f;

    model(0, 0) = cos(angle_rad);   model(0, 1) = -sin(angle_rad);
    model(1, 0) = sin(angle_rad);   model(1, 1) = cos(angle_rad);

    return model;
}

Eigen::Matrix4f get_view_matrix(Eigen::Vector3f eye_pos) {
    // è§†å›¾å˜æ¢ï¼šç›¸æœºç§»åŠ¨åˆ°åŸç‚¹
    Eigen::Matrix4f view = Eigen::Matrix4f::Identity();
    Eigen::Matrix4f translate;
    translate << 1, 0, 0, -eye_pos[0],
                 0, 1, 0, -eye_pos[1],
                 0, 0, 1, -eye_pos[2],
                 0, 0, 0, 1;
    view = translate * view;
    return view;
}

// åœ¨æ¸²æŸ“å¾ªç¯ä¸­åº”ç”¨å˜æ¢
Matrix4f mvp = projection * view * model;
for (auto& vertex : vertices) {
    Vector4f clip_coord = mvp * Vector4f(vertex.x, vertex.y, vertex.z, 1.0f);
    // é€è§†é™¤æ³•å’Œè§†å£å˜æ¢...
}
```

**å˜æ¢åˆ†è§£çš„å®é™…åº”ç”¨**ï¼š

```cpp
// å¤æ‚ç‰©ä½“çš„å˜æ¢åˆ†è§£
Matrix4f create_complex_transform(Vector3f scale, Vector3f rotation_angles, Vector3f translation) {
    // 1. åˆ›å»ºåŸºæœ¬å˜æ¢çŸ©é˜µ
    Matrix4f S = create_scaling_matrix(scale.x, scale.y, scale.z);
    Matrix4f Rx = create_rotation_x(rotation_angles.x);
    Matrix4f Ry = create_rotation_y(rotation_angles.y);
    Matrix4f Rz = create_rotation_z(rotation_angles.z);
    Matrix4f T = create_translation_matrix(translation.x, translation.y, translation.z);

    // 2. æŒ‰SRTé¡ºåºå¤åˆï¼ˆæ³¨æ„çŸ©é˜µä¹˜æ³•é¡ºåºï¼‰
    Matrix4f R = Rz * Ry * Rx;  // æ—‹è½¬é¡ºåºï¼šXâ†’Yâ†’Z
    Matrix4f transform = T * R * S;

    return transform;
}
```

---

## æŠ•å½±å‡ ä½•å­¦

## 3.1 æŠ•å½±å˜æ¢çš„æ•°å­¦åŸºç¡€

### 3.1.1 æŠ•å½±çš„å‡ ä½•åŸç†

**æŠ•å½±å®šä¹‰**ï¼šå°†é«˜ç»´ç©ºé—´çš„ç‚¹æ˜ å°„åˆ°ä½ç»´ç©ºé—´çš„è¿‡ç¨‹

**æŠ•å½±ç±»å‹**ï¼š

1. **å¹³è¡ŒæŠ•å½±**ï¼šæŠ•å½±çº¿å¹³è¡Œ
   - æ­£äº¤æŠ•å½±ï¼šæŠ•å½±çº¿å‚ç›´äºæŠ•å½±å¹³é¢
   - æ–œæŠ•å½±ï¼šæŠ•å½±çº¿ä¸å‚ç›´äºæŠ•å½±å¹³é¢

2. **é€è§†æŠ•å½±**ï¼šæŠ•å½±çº¿æ±‡èšäºä¸€ç‚¹ï¼ˆè§†ç‚¹ï¼‰

### 3.1.2 é€è§†æŠ•å½±çš„å®Œæ•´æ•°å­¦æ¨å¯¼

#### é€è§†æŠ•å½±çš„å‡ ä½•åŸºç¡€

**é—®é¢˜è®¾å®š**ï¼š
ç»™å®šè§‚å¯Ÿç‚¹ï¼ˆè§†ç‚¹ï¼‰$E$ å’ŒæŠ•å½±å¹³é¢ $\Pi$ï¼Œå°†3Dç©ºé—´ä¸­çš„ç‚¹æŠ•å½±åˆ°2Då¹³é¢ä¸Šã€‚

**æ ‡å‡†è®¾ç½®**ï¼š

- è§†ç‚¹ä½äºåæ ‡åŸç‚¹ï¼š$E = (0, 0, 0)$
- æŠ•å½±å¹³é¢å‚ç›´äºZè½´ï¼š$\Pi: z = -d$ï¼ˆ$d > 0$ï¼‰
- è§‚å¯Ÿæ–¹å‘æ²¿è´ŸZè½´æ–¹å‘

#### ç›¸ä¼¼ä¸‰è§’å½¢æ¨å¯¼

**å‡ ä½•åˆ†æ**ï¼š
å¯¹äºç©ºé—´ä¸­çš„ç‚¹ $P(x, y, z)$ï¼ˆå…¶ä¸­ $z < 0$ï¼‰ï¼Œä»è§†ç‚¹ $E$ å‘ç‚¹ $P$ å‘å‡ºçš„å°„çº¿ä¸æŠ•å½±å¹³é¢ $\Pi$ çš„äº¤ç‚¹ä¸º $P'(x', y', -d)$ã€‚

**Xåæ ‡æ¨å¯¼**ï¼š
åœ¨XZå¹³é¢å†…ï¼Œè€ƒè™‘ä¸‰è§’å½¢ï¼š

- å¤§ä¸‰è§’å½¢ï¼šé¡¶ç‚¹ä¸º $(0,0)$ã€$(x, z)$ã€$(x, 0)$
- å°ä¸‰è§’å½¢ï¼šé¡¶ç‚¹ä¸º $(0,0)$ã€$(x', -d)$ã€$(x', 0)$

ç”±ç›¸ä¼¼ä¸‰è§’å½¢æ€§è´¨ï¼š
$$\frac{x'}{x} = \frac{d}{-z} \implies x' = -\frac{dx}{z}$$

**Yåæ ‡æ¨å¯¼**ï¼š
ç±»ä¼¼åœ°ï¼Œåœ¨YZå¹³é¢å†…ï¼š
$$\frac{y'}{y} = \frac{d}{-z} \implies y' = -\frac{dy}{z}$$

**é€è§†é™¤æ³•çš„æœ¬è´¨**ï¼š
é€è§†æŠ•å½±çš„æ ¸å¿ƒæ˜¯é™¤æ³•è¿ç®—ï¼š$(x, y, z) \to (-dx/z, -dy/z, -d)$

#### é½æ¬¡åæ ‡ä¸­çš„é€è§†æŠ•å½±

**é—®é¢˜**ï¼šå¦‚ä½•ç”¨çŸ©é˜µè¡¨ç¤ºåŒ…å«é™¤æ³•çš„é€è§†æŠ•å½±ï¼Ÿ

**è§£å†³æ–¹æ¡ˆ**ï¼šåˆ©ç”¨é½æ¬¡åæ ‡çš„æ€§è´¨
é½æ¬¡åæ ‡ $(x, y, z, w)$ å¯¹åº”ç¬›å¡å°”åæ ‡ $(x/w, y/w, z/w)$

**é€è§†æŠ•å½±çŸ©é˜µæ„é€ **ï¼š
æˆ‘ä»¬å¸Œæœ›æ‰¾åˆ°çŸ©é˜µ $P$ï¼Œä½¿å¾—ï¼š

å¯¹è¾“å…¥ç‚¹ $(x, y, z, 1)$ï¼Œè¾“å‡ºé½æ¬¡åæ ‡ $(x', y', z', w')$

å…¶ä¸­é€è§†é™¤æ³•åå¾—åˆ°ï¼š$(-dx/z, -dy/z, -d)$

**çŸ©é˜µæ¨å¯¼**ï¼š
è®¾ $w' = -z/d$ï¼Œåˆ™ï¼š

- $x'/w' = -dx/z \implies x' = -dx/z \cdot (-z/d) = x$
- $y'/w' = -dy/z \implies y' = -dy/z \cdot (-z/d) = y$
- $z'/w' = -d \implies z' = -d \cdot (-z/d) = z$

å› æ­¤é€è§†æŠ•å½±çŸ©é˜µä¸ºï¼š

ç®€å•é€è§†æŠ•å½±çŸ©é˜µ $P_{simple}$ çš„ç»“æ„ï¼š

- å‰ä¸‰è¡Œä¸ºå•ä½çŸ©é˜µçš„å‰ä¸‰è¡Œ
- ç¬¬4è¡Œä¸º $(0, 0, -1/d, 0)$
- å…¶ä»–å…ƒç´ ä¸º0

$$P_{simple} = \text{simple perspective projection matrix}$$

**éªŒè¯**ï¼š
å¯¹è¾“å…¥å‘é‡ $(x, y, z, 1)$ï¼Œå˜æ¢ç»“æœä¸º $(x, y, z, -z/d)$

é€è§†é™¤æ³•åï¼š$(x/(-z/d), y/(-z/d), z/(-z/d)) = (-dx/z, -dy/z, -d)$ âœ“

#### é€è§†æŠ•å½±çš„æ·±åº¦é—®é¢˜

**æ·±åº¦ä¿¡æ¯çš„ä¿æŒ**ï¼š
ç®€å•é€è§†æŠ•å½±ä¼šä¸¢å¤±æ·±åº¦ä¿¡æ¯ï¼Œå› ä¸ºæ‰€æœ‰ç‚¹éƒ½è¢«æŠ•å½±åˆ° $z = -d$ å¹³é¢ã€‚

**è§£å†³æ–¹æ¡ˆ**ï¼š
ä¿®æ”¹Zåˆ†é‡çš„è®¡ç®—ï¼Œä½¿å…¶ä¿æŒæ·±åº¦é¡ºåºï¼š
$$z' = \alpha z + \beta$$

å…¶ä¸­ $\alpha, \beta$ æ˜¯å¾…å®šå¸¸æ•°ï¼Œéœ€è¦æ»¡è¶³ï¼š

1. è¿‘å¹³é¢ $z = -n$ æ˜ å°„åˆ° $z' = -1$
2. è¿œå¹³é¢ $z = -f$ æ˜ å°„åˆ° $z' = 1$

**æ±‚è§£è¿‡ç¨‹**ï¼š

å»ºç«‹çº¿æ€§æ–¹ç¨‹ç»„ï¼š

å½“ $z = -n$ æ—¶ï¼š$\alpha(-n) + \beta = -1$

å½“ $z = -f$ æ—¶ï¼š$\alpha(-f) + \beta = 1$

è§£å¾—ï¼š
$$\alpha = -\frac{2}{f-n}, \quad \beta = -\frac{f+n}{f-n}$$

å› æ­¤ï¼š
$$z' = -\frac{2z}{f-n} - \frac{f+n}{f-n} = -\frac{2z + f + n}{f-n}$$

ä½†åœ¨é½æ¬¡åæ ‡ä¸­ï¼Œæˆ‘ä»¬éœ€è¦ï¼š
$$\frac{z'}{w'} = -\frac{2z + f + n}{f-n} \cdot \frac{d}{-z} = \frac{d(2z + f + n)}{z(f-n)}$$

è¿™å¯¼è‡´äº†æ ‡å‡†é€è§†æŠ•å½±çŸ©é˜µä¸­Zè¡Œçš„å¤æ‚å½¢å¼ã€‚

### 3.1.3 æ ‡å‡†é€è§†æŠ•å½±çŸ©é˜µçš„å®Œæ•´æ¨å¯¼

#### è§†é”¥ä½“ï¼ˆView Frustumï¼‰çš„å®šä¹‰

**è§†é”¥ä½“å‚æ•°**ï¼š

- $\text{fov}$ï¼šå‚ç›´è§†åœºè§’ï¼ˆField of Viewï¼‰ï¼Œå•ä½ä¸ºåº¦
- $\text{aspect}$ï¼šå®½é«˜æ¯” $= \frac{\text{width}}{\text{height}}$
- $n$ï¼šè¿‘è£å‰ªé¢è·ç¦»ï¼ˆnear planeï¼‰
- $f$ï¼šè¿œè£å‰ªé¢è·ç¦»ï¼ˆfar planeï¼‰

**è§†é”¥ä½“çš„å‡ ä½•å½¢çŠ¶**ï¼š
è§†é”¥ä½“æ˜¯ä¸€ä¸ªæˆªå¤´é”¥ä½“ï¼ˆfrustumï¼‰ï¼Œç”±6ä¸ªå¹³é¢å›´æˆï¼š

- è¿‘å¹³é¢ï¼š$z = -n$
- è¿œå¹³é¢ï¼š$z = -f$
- å·¦å¹³é¢ã€å³å¹³é¢ã€ä¸Šå¹³é¢ã€ä¸‹å¹³é¢

#### æŠ•å½±å¹³é¢å°ºå¯¸çš„è®¡ç®—

**è¿‘å¹³é¢å°ºå¯¸æ¨å¯¼**ï¼š
åœ¨è¿‘å¹³é¢ $z = -n$ å¤„ï¼Œè§†é”¥ä½“çš„å°ºå¯¸ä¸ºï¼š

$$\text{top} = n \cdot \tan\left(\frac{\text{fov}}{2}\right)$$
$$\text{bottom} = -\text{top}$$
$$\text{right} = \text{top} \cdot \text{aspect}$$
$$\text{left} = -\text{right}$$

**å‡ ä½•è§£é‡Š**ï¼š

- $\tan(\text{fov}/2) = \text{top}/n$ï¼Œå› æ­¤ $\text{top} = n \cdot \tan(\text{fov}/2)$
- å¯¹ç§°è§†é”¥ä½“ï¼š$\text{left} = -\text{right}$ï¼Œ$\text{bottom} = -\text{top}$

#### ä¸€èˆ¬é€è§†æŠ•å½±çŸ©é˜µæ¨å¯¼

**ç›®æ ‡**ï¼šå°†è§†é”¥ä½“å†…çš„ç‚¹ $(x, y, z)$ æ˜ å°„åˆ°æ ‡å‡†ç«‹æ–¹ä½“ $[-1,1]^3$

**Xåæ ‡å˜æ¢**ï¼š
è¿‘å¹³é¢ä¸Šçš„ç‚¹ $x \in [\text{left}, \text{right}]$ åº”æ˜ å°„åˆ° $[-1, 1]$ï¼š
$$x_{ndc} = \frac{2x - (\text{right} + \text{left})}{\text{right} - \text{left}}$$

ä½†é€è§†æŠ•å½±ä¸­ï¼Œ$x$ åæ ‡ä¼šè¢« $z$ ç¼©æ”¾ï¼Œå› æ­¤ï¼š
$$x_{ndc} = \frac{2x/(-z) - (\text{right} + \text{left})/(-z)}{(\text{right} - \text{left})/(-z)}$$

æ•´ç†å¾—ï¼š
$$x_{ndc} = \frac{2x + z(\text{right} + \text{left})/n}{z(\text{right} - \text{left})/n}$$

**Yåæ ‡å˜æ¢**ï¼š
ç±»ä¼¼åœ°ï¼š
$$y_{ndc} = \frac{2y + z(\text{top} + \text{bottom})/n}{z(\text{top} - \text{bottom})/n}$$

**Zåæ ‡å˜æ¢**ï¼š
Zåæ ‡çš„å˜æ¢éœ€è¦ä¿æŒæ·±åº¦é¡ºåºï¼š
$$z_{ndc} = \frac{\alpha z + \beta}{z}$$

è¾¹ç•Œæ¡ä»¶ï¼š

- $z = -n \implies z_{ndc} = -1$
- $z = -f \implies z_{ndc} = 1$

è§£å¾—ï¼š$\alpha = -(f+n)$ï¼Œ$\beta = -2fn$

#### é½æ¬¡åæ ‡çŸ©é˜µå½¢å¼

**ä¸€èˆ¬é€è§†æŠ•å½±çŸ©é˜µ**ï¼š

é€è§†æŠ•å½±çŸ©é˜µ $P$ çš„ç»“æ„ï¼š

- ç¬¬1è¡Œï¼š$(\frac{2n}{r-l}, 0, \frac{r+l}{r-l}, 0)$
- ç¬¬2è¡Œï¼š$(0, \frac{2n}{t-b}, \frac{t+b}{t-b}, 0)$
- ç¬¬3è¡Œï¼š$(0, 0, -\frac{f+n}{f-n}, -\frac{2fn}{f-n})$
- ç¬¬4è¡Œï¼š$(0, 0, -1, 0)$

$$P = \text{general perspective projection matrix}$$

å…¶ä¸­ï¼š$n=\text{near}$, $f=\text{far}$, $l=\text{left}$, $r=\text{right}$, $t=\text{top}$, $b=\text{bottom}$

#### å¯¹ç§°è§†é”¥ä½“çš„ç®€åŒ–

**å¯¹ç§°æ¡ä»¶**ï¼š$l = -r$, $b = -t$

æ­¤æ—¶ï¼š$r + l = 0$, $t + b = 0$ï¼ŒçŸ©é˜µç®€åŒ–ä¸ºï¼š

å¯¹ç§°é€è§†æŠ•å½±çŸ©é˜µ $P_{symmetric}$ çš„ç»“æ„ï¼š

- ç¬¬1è¡Œï¼š$(\frac{1}{\text{aspect} \cdot \tan(\text{fov}/2)}, 0, 0, 0)$
- ç¬¬2è¡Œï¼š$(0, \frac{1}{\tan(\text{fov}/2)}, 0, 0)$
- ç¬¬3è¡Œï¼š$(0, 0, -\frac{f+n}{f-n}, -\frac{2fn}{f-n})$
- ç¬¬4è¡Œï¼š$(0, 0, -1, 0)$

$$P_{symmetric} = \text{symmetric perspective projection matrix}$$

**æ¨å¯¼éªŒè¯**ï¼š

- $\frac{2n}{r-l} = \frac{2n}{2r} = \frac{n}{r} = \frac{n}{n \cdot \tan(\text{fov}/2) \cdot \text{aspect}} = \frac{1}{\text{aspect} \cdot \tan(\text{fov}/2)}$
- $\frac{2n}{t-b} = \frac{2n}{2t} = \frac{n}{t} = \frac{n}{n \cdot \tan(\text{fov}/2)} = \frac{1}{\tan(\text{fov}/2)}$

#### GAMES101 Assignment 1é¡¹ç›®å®ç°

**å®Œæ•´çš„é€è§†æŠ•å½±çŸ©é˜µå®ç°**ï¼š

```cpp
Eigen::Matrix4f get_projection_matrix(float eye_fov, float aspect_ratio,
                                      float zNear, float zFar) {
    // åˆ›å»ºå•ä½çŸ©é˜µä½œä¸ºåŸºç¡€
    Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();

    // å°†è§†åœºè§’ä»åº¦è½¬æ¢ä¸ºå¼§åº¦
    float eye_fov_rad = eye_fov * MY_PI / 180.0f;

    // è®¡ç®— tan(fov/2)ï¼Œè¿™æ˜¯æ¨å¯¼ä¸­çš„å…³é”®é‡
    float t = std::tan(eye_fov_rad / 2.0f);

    // æ ¹æ®å¯¹ç§°è§†é”¥ä½“çš„ç®€åŒ–å…¬å¼å¡«å……çŸ©é˜µå…ƒç´ 
    projection(0, 0) = 1.0f / (aspect_ratio * t);  // Xç¼©æ”¾å› å­
    projection(1, 1) = 1.0f / t;                   // Yç¼©æ”¾å› å­
    projection(2, 2) = -(zFar + zNear) / (zFar - zNear);     // Zå˜æ¢ç³»æ•°A
    projection(2, 3) = -2.0f * zFar * zNear / (zFar - zNear); // Zå˜æ¢ç³»æ•°B
    projection(3, 2) = -1.0f;                      // é€è§†é™¤æ³•è§¦å‘å™¨
    projection(3, 3) = 0.0f;                       // æ¸…é™¤åŸæœ‰çš„1

    return projection;
}
```

**çŸ©é˜µå…ƒç´ çš„å‡ ä½•æ„ä¹‰**ï¼š

1. `projection(0,0) = 1/(aspect*tan(fov/2))`ï¼šXæ–¹å‘çš„ç¼©æ”¾ï¼Œå°†è§†é”¥ä½“å®½åº¦æ˜ å°„åˆ°[-1,1]
2. `projection(1,1) = 1/tan(fov/2)`ï¼šYæ–¹å‘çš„ç¼©æ”¾ï¼Œå°†è§†é”¥ä½“é«˜åº¦æ˜ å°„åˆ°[-1,1]
3. `projection(2,2) = -(f+n)/(f-n)`ï¼šZåæ ‡çš„çº¿æ€§éƒ¨åˆ†
4. `projection(2,3) = -2fn/(f-n)`ï¼šZåæ ‡çš„å¸¸æ•°éƒ¨åˆ†
5. `projection(3,2) = -1`ï¼šä½¿å¾—w' = -zï¼Œå®ç°é€è§†é™¤æ³•

**å˜æ¢è¿‡ç¨‹éªŒè¯**ï¼š

```cpp
// æµ‹è¯•è¿‘å¹³é¢ä¸Šçš„ç‚¹
Vector4f near_point(0, 0, -zNear, 1);
Vector4f projected = projection * near_point;
// projected = (0, 0, zNear, zNear)
// é€è§†é™¤æ³•å: (0, 0, 1) - æ­£ç¡®æ˜ å°„åˆ°è¿‘å¹³é¢

// æµ‹è¯•è¿œå¹³é¢ä¸Šçš„ç‚¹
Vector4f far_point(0, 0, -zFar, 1);
Vector4f projected_far = projection * far_point;
// é€è§†é™¤æ³•åçš„zåæ ‡åº”è¯¥æ¥è¿‘-1
```

**åœ¨æ¸²æŸ“ç®¡çº¿ä¸­çš„åº”ç”¨**ï¼š

```cpp
// Assignment 1ä¸­çš„å®Œæ•´å˜æ¢é“¾
void rasterizer::draw(pos_buf_id pos_buffer, ind_buf_id ind_buffer, Primitive type) {
    auto& buf = pos_buf[pos_buffer.pos_id];
    auto& ind = ind_buf[ind_buffer.ind_id];

    // æ„å»ºMVPçŸ©é˜µ
    Eigen::Matrix4f mvp = projection * view * model;

    for (auto& i : ind) {
        Triangle t;

        // åº”ç”¨MVPå˜æ¢åˆ°ä¸‰è§’å½¢çš„ä¸‰ä¸ªé¡¶ç‚¹
        Eigen::Vector4f v[] = {
            mvp * to_vec4(buf[i[0]], 1.0f),  // é½æ¬¡åæ ‡å˜æ¢
            mvp * to_vec4(buf[i[1]], 1.0f),
            mvp * to_vec4(buf[i[2]], 1.0f)
        };

        // é€è§†é™¤æ³•ï¼šä»é½æ¬¡åæ ‡è½¬æ¢åˆ°NDC
        for (auto& vec : v) {
            vec /= vec.w();  // å…³é”®çš„é€è§†é™¤æ³•æ­¥éª¤
        }

        // è§†å£å˜æ¢ï¼šä»NDCè½¬æ¢åˆ°å±å¹•åæ ‡
        for (auto& vert : v) {
            vert.x() = 0.5f * width * (vert.x() + 1.0f);   // [-1,1] -> [0,width]
            vert.y() = 0.5f * height * (vert.y() + 1.0f);  // [-1,1] -> [0,height]
            vert.z() = vert.z() * f1 + f2;  // æ·±åº¦ç¼“å†²åŒºæ˜ å°„
        }

        // è®¾ç½®ä¸‰è§’å½¢é¡¶ç‚¹å¹¶è¿›è¡Œå…‰æ …åŒ–
        for (int i = 0; i < 3; ++i) {
            t.setVertex(i, v[i].head<3>());
        }

        rasterize_wireframe(t);
    }
}
```

### 3.1.4 æ·±åº¦å€¼çš„éçº¿æ€§åˆ†å¸ƒ

**é—®é¢˜**ï¼šé€è§†æŠ•å½±åçš„æ·±åº¦å€¼åˆ†å¸ƒä¸å‡åŒ€

**æ•°å­¦åˆ†æ**ï¼š
æŠ•å½±åçš„zåæ ‡ä¸ºï¼š
$$z' = -\frac{f+n}{f-n} + \frac{-2fn}{z(f-n)}$$

**æ·±åº¦ç²¾åº¦åˆ†æ**ï¼š

- è¿‘å¤„ç‰©ä½“ï¼šæ·±åº¦ç²¾åº¦é«˜
- è¿œå¤„ç‰©ä½“ï¼šæ·±åº¦ç²¾åº¦ä½
- å¤§éƒ¨åˆ†ç²¾åº¦é›†ä¸­åœ¨è¿‘è£å‰ªé¢é™„è¿‘

**è§£å†³æ–¹æ¡ˆ**ï¼š

1. åˆç†è®¾ç½®near/faræ¯”å€¼
2. ä½¿ç”¨åå‘Zç¼“å†²
3. å¯¹æ•°æ·±åº¦ç¼“å†²

## 3.2 è§†å›¾å˜æ¢

### 3.2.1 æ‘„åƒæœºæ¨¡å‹

**æ‘„åƒæœºå‚æ•°**ï¼š

- eyeï¼šæ‘„åƒæœºä½ç½®
- targetï¼šè§‚å¯Ÿç›®æ ‡ç‚¹
- upï¼šä¸Šæ–¹å‘å‘é‡

**å±€éƒ¨åæ ‡ç³»æ„å»º**ï¼š

```cpp
Vector3f forward = (target - eye).normalized();  // å‰æ–¹å‘ï¼ˆ-zè½´ï¼‰
Vector3f right = forward.cross(up).normalized(); // å³æ–¹å‘ï¼ˆxè½´ï¼‰
Vector3f camera_up = right.cross(forward);       // ä¸Šæ–¹å‘ï¼ˆyè½´ï¼‰
```

### 3.2.2 è§†å›¾çŸ©é˜µæ¨å¯¼

**ç›®æ ‡**ï¼šå°†ä¸–ç•Œåæ ‡ç³»å˜æ¢åˆ°æ‘„åƒæœºåæ ‡ç³»

**ä¸¤æ­¥å˜æ¢**ï¼š

1. å¹³ç§»ï¼šå°†æ‘„åƒæœºç§»åŠ¨åˆ°åŸç‚¹
2. æ—‹è½¬ï¼šå°†æ‘„åƒæœºåæ ‡è½´ä¸ä¸–ç•Œåæ ‡è½´å¯¹é½

**å¹³ç§»çŸ©é˜µ**ï¼š

è§†å›¾å˜æ¢å¹³ç§»çŸ©é˜µ $\mathbf{T}$ çš„ç»“æ„ï¼š

- å·¦ä¸Šè§’ $3 \times 3$ å­çŸ©é˜µä¸ºå•ä½çŸ©é˜µ
- ç¬¬4åˆ—å‰ä¸‰ä¸ªå…ƒç´ ä¸º $(-eye_x, -eye_y, -eye_z)$
- ç¬¬4è¡Œä¸º $(0, 0, 0, 1)$

$$\mathbf{T} = \text{view translation matrix}$$

**æ—‹è½¬çŸ©é˜µ**ï¼š

è§†å›¾å˜æ¢æ—‹è½¬çŸ©é˜µ $\mathbf{R}$ çš„ç»“æ„ï¼š

- ç¬¬1è¡Œï¼š$(right_x, right_y, right_z, 0)$ - å³å‘é‡
- ç¬¬2è¡Œï¼š$(up_x, up_y, up_z, 0)$ - ä¸Šå‘é‡
- ç¬¬3è¡Œï¼š$(-forward_x, -forward_y, -forward_z, 0)$ - è´Ÿå‰å‘é‡
- ç¬¬4è¡Œï¼š$(0, 0, 0, 1)$ - é½æ¬¡åæ ‡

$$\mathbf{R} = \text{view rotation matrix}$$

**å®Œæ•´è§†å›¾çŸ©é˜µ**ï¼š
$$\mathbf{V} = \mathbf{R} \times \mathbf{T}$$

**é¡¹ç›®ç®€åŒ–å®ç°**ï¼š

```cpp
Eigen::Matrix4f get_view_matrix(Eigen::Vector3f eye_pos) {
    Eigen::Matrix4f view = Eigen::Matrix4f::Identity();

    Eigen::Matrix4f translate;
    translate << 1, 0, 0, -eye_pos[0],
                 0, 1, 0, -eye_pos[1],
                 0, 0, 1, -eye_pos[2],
                 0, 0, 0, 1;

    view = translate * view;
    return view;
}
```

### 3.1.4 æ·±åº¦ç¼“å†²åŒºä¸Z-Fightingé—®é¢˜

#### æ·±åº¦å€¼çš„éçº¿æ€§åˆ†å¸ƒ

**é—®é¢˜åˆ†æ**ï¼š
é€è§†æŠ•å½±åçš„æ·±åº¦å€¼åœ¨ $[0, 1]$ èŒƒå›´å†…å‘ˆéçº¿æ€§åˆ†å¸ƒï¼Œè¿™ä¼šå¯¼è‡´æ·±åº¦ç²¾åº¦é—®é¢˜ã€‚

**æ·±åº¦å˜æ¢å‡½æ•°**ï¼š
ç»è¿‡é€è§†æŠ•å½±å’Œé€è§†é™¤æ³•åï¼ŒåŸå§‹æ·±åº¦ $z$ å˜æ¢ä¸ºï¼š
$$z_{buffer} = \frac{1}{2}\left(\frac{-(f+n)z - 2fn}{-z(f-n)} + 1\right)$$

ç®€åŒ–ä¸ºï¼š
$$z_{buffer} = \frac{1}{2}\left(\frac{f+n}{f-n} + \frac{2fn}{z(f-n)}\right)$$

**éçº¿æ€§ç‰¹æ€§åˆ†æ**ï¼š

- å½“ $z \to -n$ï¼ˆè¿‘å¹³é¢ï¼‰æ—¶ï¼Œ$z_{buffer} \to 0$
- å½“ $z \to -f$ï¼ˆè¿œå¹³é¢ï¼‰æ—¶ï¼Œ$z_{buffer} \to 1$
- æ·±åº¦ç²¾åº¦åœ¨è¿‘å¹³é¢é™„è¿‘æœ€é«˜ï¼Œåœ¨è¿œå¹³é¢é™„è¿‘æœ€ä½

**ç²¾åº¦åˆ†å¸ƒè®¡ç®—**ï¼š
æ·±åº¦ç²¾åº¦å®šä¹‰ä¸º $\frac{dz_{buffer}}{dz}$ï¼š
$$\frac{dz_{buffer}}{dz} = \frac{fn}{z^2(f-n)}$$

è¿™è¡¨æ˜æ·±åº¦ç²¾åº¦ä¸ $z^2$ æˆåæ¯”ï¼Œè·ç¦»è¶Šè¿œç²¾åº¦è¶Šä½ã€‚

#### Z-Fightingç°è±¡

**å®šä¹‰**ï¼šå½“ä¸¤ä¸ªè¡¨é¢éå¸¸æ¥è¿‘æ—¶ï¼Œç”±äºæ·±åº¦ç¼“å†²åŒºç²¾åº¦é™åˆ¶ï¼Œä¼šå‡ºç°é—ªçƒç°è±¡ã€‚

**äº§ç”ŸåŸå› **ï¼š

1. **æœ‰é™ç²¾åº¦**ï¼šæ·±åº¦ç¼“å†²åŒºé€šå¸¸ä½¿ç”¨24ä½æˆ–32ä½æµ®ç‚¹æ•°
2. **éçº¿æ€§åˆ†å¸ƒ**ï¼šè¿œå¤„ç‰©ä½“çš„æ·±åº¦ç²¾åº¦æä½
3. **æ•°å€¼è¯¯å·®**ï¼šæµ®ç‚¹è¿ç®—çš„èˆå…¥è¯¯å·®

**æ•°å­¦åˆ†æ**ï¼š
è®¾ä¸¤ä¸ªè¡¨é¢çš„æ·±åº¦åˆ†åˆ«ä¸º $z_1$ å’Œ $z_2$ï¼Œä¸” $|z_1 - z_2| < \epsilon$ï¼Œå…¶ä¸­ $\epsilon$ æ˜¯æ·±åº¦ç¼“å†²åŒºçš„ç²¾åº¦ã€‚

å½“ $\frac{fn}{z^2(f-n)} \cdot |z_1 - z_2| < \frac{1}{2^{24}}$ æ—¶ï¼Œä¸¤ä¸ªè¡¨é¢åœ¨æ·±åº¦ç¼“å†²åŒºä¸­æ— æ³•åŒºåˆ†ã€‚

#### è§£å†³Z-Fightingçš„æ–¹æ³•

**1. ä¼˜åŒ–è¿‘è¿œå¹³é¢æ¯”å€¼**ï¼š
$$\text{ç²¾åº¦} \propto \frac{n}{f-n}$$

å‡å° $f/n$ æ¯”å€¼å¯ä»¥æé«˜æ•´ä½“ç²¾åº¦ï¼š

```cpp
// ä¸å¥½çš„è®¾ç½®
float near = 0.1f, far = 10000.0f;  // æ¯”å€¼ = 100000

// æ›´å¥½çš„è®¾ç½®
float near = 1.0f, far = 1000.0f;   // æ¯”å€¼ = 1000
```

**2. å¤šè¾¹å½¢åç§»ï¼ˆPolygon Offsetï¼‰**ï¼š

```cpp
// OpenGLä¸­çš„å¤šè¾¹å½¢åç§»
glEnable(GL_POLYGON_OFFSET_FILL);
glPolygonOffset(factor, units);
// ä¿®æ”¹æ·±åº¦å€¼ï¼šz' = z + factor * dz/dx + units * r
```

**3. å¯¹æ•°æ·±åº¦ç¼“å†²åŒº**ï¼š
ä½¿ç”¨å¯¹æ•°åˆ†å¸ƒæ”¹å–„æ·±åº¦ç²¾åº¦ï¼š
$$z_{log} = \frac{\log(z/n)}{\log(f/n)}$$

**4. åå‘Zç¼“å†²åŒº**ï¼š
å°†è¿œå¹³é¢æ˜ å°„åˆ°0ï¼Œè¿‘å¹³é¢æ˜ å°„åˆ°1ï¼Œåˆ©ç”¨æµ®ç‚¹æ•°åœ¨0é™„è¿‘ç²¾åº¦æ›´é«˜çš„ç‰¹æ€§ã€‚

#### GAMES101é¡¹ç›®ä¸­çš„æ·±åº¦å¤„ç†

```cpp
// Assignment 2ä¸­çš„æ·±åº¦æµ‹è¯•å®ç°
void rst::rasterizer::rasterize_triangle(const Triangle& t) {
    // è·å–ä¸‰è§’å½¢çš„å±å¹•ç©ºé—´åŒ…å›´ç›’
    auto v = t.toVector4();

    // éå†åŒ…å›´ç›’å†…çš„æ¯ä¸ªåƒç´ 
    for (int x = bbox_min_x; x <= bbox_max_x; x++) {
        for (int y = bbox_min_y; y <= bbox_max_y; y++) {
            // è®¡ç®—é‡å¿ƒåæ ‡
            auto [alpha, beta, gamma] = computeBarycentric2D(x, y, t.v);

            // æ£€æŸ¥ç‚¹æ˜¯å¦åœ¨ä¸‰è§’å½¢å†…
            if (alpha >= 0 && beta >= 0 && gamma >= 0) {
                // æ’å€¼è®¡ç®—æ·±åº¦å€¼
                float z_interpolated = alpha * v[0].z() + beta * v[1].z() + gamma * v[2].z();

                // æ·±åº¦æµ‹è¯•
                if (z_interpolated < depth_buf[get_index(x, y)]) {
                    // æ›´æ–°æ·±åº¦ç¼“å†²åŒº
                    depth_buf[get_index(x, y)] = z_interpolated;

                    // è®¾ç½®åƒç´ é¢œè‰²
                    set_pixel(Vector3f(x, y, 1.0f), t.getColor());
                }
            }
        }
    }
}
```

**æ·±åº¦ç²¾åº¦ä¼˜åŒ–å»ºè®®**ï¼š

1. **åˆç†è®¾ç½®è¿‘è¿œå¹³é¢**ï¼šé¿å…è¿‡å¤§çš„ $f/n$ æ¯”å€¼
2. **ä½¿ç”¨32ä½æ·±åº¦ç¼“å†²åŒº**ï¼šç›¸æ¯”24ä½æœ‰æ›´é«˜ç²¾åº¦
3. **åˆ†å±‚æ¸²æŸ“**ï¼šå°†åœºæ™¯åˆ†ä¸ºå¤šä¸ªæ·±åº¦å±‚åˆ†åˆ«æ¸²æŸ“
4. **é¿å…å…±é¢å‡ ä½•ä½“**ï¼šè®¾è®¡æ—¶é¿å…ä¸¤ä¸ªè¡¨é¢å®Œå…¨é‡åˆ

---

## å¾®ç§¯åˆ†åœ¨å›¾å½¢å­¦ä¸­çš„åº”ç”¨

## 4.1 å‚æ•°æ›²çº¿çš„å¾®åˆ†å‡ ä½•ç†è®º

### 4.1.1 å‚æ•°æ›²çº¿çš„æ•°å­¦è¡¨ç¤º

#### å‚æ•°æ›²çº¿çš„åŸºæœ¬å®šä¹‰

**å‚æ•°æ–¹ç¨‹çš„ä¸€èˆ¬å½¢å¼**ï¼š
ä¸‰ç»´ç©ºé—´ä¸­çš„å‚æ•°æ›²çº¿å¯ä»¥è¡¨ç¤ºä¸ºï¼š
$$\vec{r}(t) = \begin{pmatrix} x(t) \\ y(t) \\ z(t) \end{pmatrix}, \quad t \in [a, b]$$

å…¶ä¸­ $x(t)$ã€$y(t)$ã€$z(t)$ æ˜¯å…³äºå‚æ•° $t$ çš„è¿ç»­å¯å¾®å‡½æ•°ã€‚

**å‚æ•°åŒ–çš„ä¼˜åŠ¿**ï¼š

- **ç»Ÿä¸€è¡¨ç¤º**ï¼šç›´çº¿ã€åœ†ã€æ¤­åœ†ç­‰éƒ½å¯ç”¨å‚æ•°æ–¹ç¨‹ç»Ÿä¸€æè¿°
- **æ–¹å‘æ€§**ï¼šå‚æ•°å¢åŠ æ–¹å‘ç»™å‡ºæ›²çº¿çš„è‡ªç„¶å®šå‘
- **è®¡ç®—ä¾¿åˆ©**ï¼šå¾®åˆ†ã€ç§¯åˆ†è¿ç®—è½¬åŒ–ä¸ºå¯¹å‚æ•°çš„è¿ç®—

#### åˆ‡å‘é‡ä¸é€Ÿåº¦å‘é‡

**ä¸€é˜¶å¯¼æ•°ï¼ˆåˆ‡å‘é‡ï¼‰**ï¼š
$$\vec{r}'(t) = \frac{d\vec{r}}{dt} = \begin{pmatrix} x'(t) \\ y'(t) \\ z'(t) \end{pmatrix}$$

**å‡ ä½•ä¸ç‰©ç†æ„ä¹‰**ï¼š

- **å‡ ä½•æ„ä¹‰**ï¼š$\vec{r}'(t)$ æ˜¯æ›²çº¿åœ¨ç‚¹ $\vec{r}(t)$ å¤„çš„åˆ‡å‘é‡
- **ç‰©ç†æ„ä¹‰**ï¼šè‹¥ $t$ è¡¨ç¤ºæ—¶é—´ï¼Œåˆ™ $\vec{r}'(t)$ æ˜¯è´¨ç‚¹çš„ç¬æ—¶é€Ÿåº¦å‘é‡
- **æ–¹å‘**ï¼šæŒ‡å‘å‚æ•°å¢åŠ çš„æ–¹å‘

**å•ä½åˆ‡å‘é‡**ï¼š
$$\vec{T}(t) = \frac{\vec{r}'(t)}{\|\vec{r}'(t)\|}$$

å½“ $\|\vec{r}'(t)\| \neq 0$ æ—¶ï¼Œ$\vec{T}(t)$ æ˜¯å•ä½é•¿åº¦çš„åˆ‡å‘é‡ã€‚

### 4.1.2 æ›²ç‡ç†è®ºä¸è®¡ç®—

#### æ›²ç‡çš„æ•°å­¦å®šä¹‰

**æ›²ç‡çš„å‡ ä½•å®šä¹‰**ï¼š
æ›²ç‡ $\kappa(t)$ æè¿°æ›²çº¿åœ¨æŸç‚¹å¤„åç¦»ç›´çº¿çš„ç¨‹åº¦ï¼Œå®šä¹‰ä¸ºå•ä½åˆ‡å‘é‡çš„å˜åŒ–ç‡ï¼š
$$\kappa(t) = \left\|\frac{d\vec{T}}{dt}\right\| = \left\|\frac{d}{dt}\left(\frac{\vec{r}'(t)}{\|\vec{r}'(t)\|}\right)\right\|$$

**è®¡ç®—å…¬å¼æ¨å¯¼**ï¼š
åˆ©ç”¨å‘é‡å¾®åˆ†çš„å•†æ³•åˆ™ï¼š
$$\frac{d\vec{T}}{dt} = \frac{d}{dt}\left(\frac{\vec{r}'}{\|\vec{r}'\|}\right) = \frac{\vec{r}'' \|\vec{r}'\| - \vec{r}'(\vec{r}' \cdot \vec{r}'') / \|\vec{r}'\|}{\|\vec{r}'\|^2}$$

ç»è¿‡åŒ–ç®€å¾—åˆ°ï¼š
$$\kappa(t) = \frac{\|\vec{r}'(t) \times \vec{r}''(t)\|}{\|\vec{r}'(t)\|^3}$$

**äºŒç»´æƒ…å†µçš„ç‰¹æ®Šå½¢å¼**ï¼š
å¯¹äºå¹³é¢æ›²çº¿ $y = f(x)$ï¼š
$$\kappa = \frac{|f''(x)|}{(1 + (f'(x))^2)^{3/2}}$$

#### æ›²ç‡çš„å‡ ä½•æ„ä¹‰ä¸åº”ç”¨

**å‡ ä½•è§£é‡Š**ï¼š

- $\kappa = 0$ï¼šæ›²çº¿ä¸ºç›´çº¿
- $\kappa > 0$ï¼šæ›²çº¿å¼¯æ›²ï¼Œæ•°å€¼è¶Šå¤§å¼¯æ›²ç¨‹åº¦è¶Šå¤§
- $\kappa = 1/R$ï¼š$R$ ä¸ºæ›²ç‡åŠå¾„ï¼Œå³å¯†åˆ‡åœ†çš„åŠå¾„

**åœ¨è®¡ç®—æœºå›¾å½¢å­¦ä¸­çš„åº”ç”¨**ï¼š

1. **è‡ªé€‚åº”æ›²çº¿ç»†åˆ†**ï¼š

```cpp
float compute_curvature(const Vector3f& p0, const Vector3f& p1, const Vector3f& p2) {
    Vector3f v1 = p1 - p0;
    Vector3f v2 = p2 - p1;
    Vector3f cross_product = v1.cross(v2);

    float numerator = cross_product.norm();
    float denominator = std::pow(v1.norm(), 3);

    return (denominator > 1e-6) ? numerator / denominator : 0.0f;
}

void adaptive_subdivision(const BezierCurve& curve, float tolerance) {
    for (float t = 0; t < 1.0; ) {
        float curvature = compute_curvature_at(curve, t);
        float step = std::min(tolerance / std::max(curvature, 1e-3), 0.1f);

        // åœ¨é«˜æ›²ç‡å¤„ä½¿ç”¨æ›´å°çš„æ­¥é•¿
        render_curve_segment(curve, t, t + step);
        t += step;
    }
}
```

2. **åŠ¨ç”»è·¯å¾„å¹³æ»‘**ï¼š
é€šè¿‡æ§åˆ¶æ›²ç‡è¿ç»­æ€§ç¡®ä¿åŠ¨ç”»çš„å¹³æ»‘è¿‡æ¸¡ã€‚

## 4.2 ç§¯åˆ†ç†è®ºåœ¨æ¸²æŸ“ä¸­çš„åº”ç”¨

### 4.2.1 æ¸²æŸ“æ–¹ç¨‹çš„æ•°å­¦åŸºç¡€

#### æ¸²æŸ“æ–¹ç¨‹çš„ç‰©ç†æ¨å¯¼

**èƒ½é‡å®ˆæ’åŸç†**ï¼š
åœ¨ç¨³æ€æ¡ä»¶ä¸‹ï¼Œè¡¨é¢æŸç‚¹çš„å‡ºå°„è¾å°„åº¦ç­‰äºè‡ªå‘å…‰åŠ ä¸Šæ‰€æœ‰å…¥å°„å…‰çº¿ç»åå°„åçš„è´¡çŒ®ã€‚

**æ¸²æŸ“æ–¹ç¨‹çš„å®Œæ•´å½¢å¼**ï¼š
$$L_o(\mathbf{p}, \omega_o) = L_e(\mathbf{p}, \omega_o) + \int_{\Omega} f_r(\mathbf{p}, \omega_i, \omega_o) L_i(\mathbf{p}, \omega_i) \cos\theta_i \, d\omega_i$$

**ç¬¦å·è¯´æ˜**ï¼š

- $L_o(\mathbf{p}, \omega_o)$ï¼šç‚¹ $\mathbf{p}$ æ²¿æ–¹å‘ $\omega_o$ çš„å‡ºå°„è¾å°„åº¦
- $L_e(\mathbf{p}, \omega_o)$ï¼šç‚¹ $\mathbf{p}$ çš„è‡ªå‘å…‰è¾å°„åº¦
- $f_r(\mathbf{p}, \omega_i, \omega_o)$ï¼šåŒå‘åå°„åˆ†å¸ƒå‡½æ•°ï¼ˆBRDFï¼‰
- $L_i(\mathbf{p}, \omega_i)$ï¼šæ²¿æ–¹å‘ $\omega_i$ çš„å…¥å°„è¾å°„åº¦
- $\Omega$ï¼šä»¥ç‚¹ $\mathbf{p}$ ä¸ºä¸­å¿ƒçš„ä¸ŠåŠçƒç«‹ä½“è§’
- $\theta_i$ï¼šå…¥å°„æ–¹å‘ä¸è¡¨é¢æ³•å‘é‡çš„å¤¹è§’

#### BRDFçš„æ•°å­¦æ€§è´¨

**BRDFçš„å®šä¹‰**ï¼š
$$f_r(\mathbf{p}, \omega_i, \omega_o) = \frac{dL_o(\mathbf{p}, \omega_o)}{dE_i(\mathbf{p}, \omega_i)}$$

å…¶ä¸­ $dE_i$ æ˜¯å¾®åˆ†è¾ç…§åº¦ã€‚

**é‡è¦æ€§è´¨**ï¼š

1. **éè´Ÿæ€§**ï¼š$f_r(\mathbf{p}, \omega_i, \omega_o) \geq 0$
2. **äº’æ˜“æ€§**ï¼š$f_r(\mathbf{p}, \omega_i, \omega_o) = f_r(\mathbf{p}, \omega_o, \omega_i)$
3. **èƒ½é‡å®ˆæ’**ï¼š$\int_{\Omega} f_r(\mathbf{p}, \omega_i, \omega_o) \cos\theta_o \, d\omega_o \leq 1$

### 4.2.2 è’™ç‰¹å¡æ´›ç§¯åˆ†ç†è®º

#### è’™ç‰¹å¡æ´›æ–¹æ³•çš„æ•°å­¦åŸºç¡€

**åŸºæœ¬åŸç†**ï¼š
å¯¹äºç§¯åˆ† $I = \int_D f(\mathbf{x}) d\mathbf{x}$ï¼Œè’™ç‰¹å¡æ´›ä¼°è®¡ä¸ºï¼š
$$\hat{I} = \frac{1}{N} \sum_{i=1}^N \frac{f(\mathbf{X}_i)}{p(\mathbf{X}_i)}$$

å…¶ä¸­ $\mathbf{X}_i$ æ˜¯æ ¹æ®æ¦‚ç‡å¯†åº¦å‡½æ•° $p(\mathbf{x})$ é‡‡æ ·çš„éšæœºå˜é‡ã€‚

**ä¼°è®¡é‡çš„æ€§è´¨**ï¼š

- **æ— åæ€§**ï¼š$E[\hat{I}] = I$
- **æ–¹å·®**ï¼š$\text{Var}[\hat{I}] = \frac{1}{N} \int_D \left(\frac{f(\mathbf{x})}{p(\mathbf{x})} - I\right)^2 p(\mathbf{x}) d\mathbf{x}$
- **æ”¶æ•›æ€§**ï¼š$\hat{I} \xrightarrow{P} I$ å½“ $N \to \infty$

#### é‡è¦æ€§é‡‡æ ·çš„æ•°å­¦ä¼˜åŒ–

**æ–¹å·®æœ€å°åŒ–**ï¼š
æœ€ä¼˜çš„æ¦‚ç‡å¯†åº¦å‡½æ•°ä¸ºï¼š
$$p^*(\mathbf{x}) = \frac{|f(\mathbf{x})|}{\int_D |f(\mathbf{y})| d\mathbf{y}}$$

æ­¤æ—¶æ–¹å·®ä¸ºé›¶ï¼Œä½†å®é™…ä¸­éš¾ä»¥å®ç°ã€‚

**å®ç”¨çš„é‡è¦æ€§é‡‡æ ·ç­–ç•¥**ï¼š
é€‰æ‹© $p(\mathbf{x}) \propto |f(\mathbf{x})|$ å¯ä»¥æ˜¾è‘—å‡å°‘æ–¹å·®ã€‚

#### åœ¨è·¯å¾„è¿½è¸ªä¸­çš„å®ç°

```cpp
Vector3f monte_carlo_integration(const Intersection& hit_point, int samples) {
    Vector3f color(0, 0, 0);
    const Vector3f& normal = hit_point.normal;

    for (int i = 0; i < samples; ++i) {
        // é‡è¦æ€§é‡‡æ ·ï¼šæŒ‰ä½™å¼¦åˆ†å¸ƒé‡‡æ ·
        Vector3f sample_dir = cosine_weighted_hemisphere_sample();

        // è®¡ç®—é‡‡æ ·æ¦‚ç‡å¯†åº¦
        float cos_theta = std::max(0.0f, normal.dot(sample_dir));
        float pdf = cos_theta / M_PI;  // ä½™å¼¦åŠ æƒé‡‡æ ·çš„PDF

        if (pdf > 1e-6) {
            // è®¡ç®—BRDFå€¼
            Vector3f brdf_value = evaluate_brdf(hit_point, sample_dir);

            // é€’å½’è¿½è¸ªå…‰çº¿
            Vector3f incoming_radiance = trace_ray(hit_point.position, sample_dir);

            // è’™ç‰¹å¡æ´›ä¼°è®¡
            color += brdf_value * incoming_radiance * cos_theta / pdf;
        }
    }

    return color / static_cast<float>(samples);
}

// ä½™å¼¦åŠ æƒåŠçƒé‡‡æ ·
Vector3f cosine_weighted_hemisphere_sample() {
    float u1 = random_float();
    float u2 = random_float();

    float cos_theta = std::sqrt(u1);
    float sin_theta = std::sqrt(1.0f - u1);
    float phi = 2.0f * M_PI * u2;

    return Vector3f(sin_theta * std::cos(phi),
                   sin_theta * std::sin(phi),
                   cos_theta);
}
```

## å›¾å½¢æ¸²æŸ“ç®¡çº¿æ¦‚è¿°

## 5.1 æ¸²æŸ“ç®¡çº¿çš„æ•´ä½“æ¶æ„

### 5.1.1 ç®¡çº¿é˜¶æ®µåˆ’åˆ†

**åº”ç”¨é˜¶æ®µï¼ˆApplication Stageï¼‰**ï¼š

- åœºæ™¯ç®¡ç†ï¼šæ„å»ºåœºæ™¯å›¾
- è§†é”¥ä½“è£å‰ªï¼šå‰”é™¤ä¸å¯è§ç‰©ä½“
- ç»†èŠ‚å±‚æ¬¡æ§åˆ¶ï¼šæ ¹æ®è·ç¦»é€‰æ‹©æ¨¡å‹ç²¾åº¦
- åŠ¨ç”»æ›´æ–°ï¼šéª¨éª¼åŠ¨ç”»ã€å˜å½¢åŠ¨ç”»

**å‡ ä½•é˜¶æ®µï¼ˆGeometry Stageï¼‰**ï¼š

- é¡¶ç‚¹ç€è‰²ï¼šå˜æ¢é¡¶ç‚¹ä½ç½®
- æŠ•å½±ï¼š3Dåˆ°2Dçš„æ˜ å°„
- è£å‰ªï¼šç§»é™¤è§†é”¥ä½“å¤–çš„å‡ ä½•ä½“
- å±å¹•æ˜ å°„ï¼šNDCåˆ°å±å¹•åæ ‡

**å…‰æ …åŒ–é˜¶æ®µï¼ˆRasterization Stageï¼‰**ï¼š

- ä¸‰è§’å½¢è®¾ç½®ï¼šè®¡ç®—è¾¹æ–¹ç¨‹
- ä¸‰è§’å½¢éå†ï¼šç¡®å®šè¦†ç›–çš„åƒç´ 
- åƒç´ ç€è‰²ï¼šè®¡ç®—æ¯ä¸ªåƒç´ çš„é¢œè‰²
- åˆå¹¶ï¼šæ·±åº¦æµ‹è¯•ã€æ··åˆç­‰

### 5.1.2 åæ ‡ç³»å˜æ¢æµç¨‹çš„æ•°å­¦æ¨å¯¼

#### å®Œæ•´çš„å˜æ¢é“¾

**åæ ‡ç©ºé—´åºåˆ—**ï¼š
$$\text{æ¨¡å‹åæ ‡} \xrightarrow{M} \text{ä¸–ç•Œåæ ‡} \xrightarrow{V} \text{è§‚å¯Ÿåæ ‡} \xrightarrow{P} \text{è£å‰ªåæ ‡} \xrightarrow{\text{é€è§†é™¤æ³•}} \text{NDC} \xrightarrow{S} \text{å±å¹•åæ ‡}$$

#### MVPå˜æ¢çš„æ•°å­¦è¡¨ç¤º

**å¤åˆå˜æ¢çŸ©é˜µ**ï¼š
$$\mathbf{V}_{clip} = \mathbf{P} \cdot \mathbf{V} \cdot \mathbf{M} \cdot \mathbf{V}_{model}$$

å…¶ä¸­ï¼š

- $\mathbf{M} \in \mathbb{R}^{4 \times 4}$ï¼šæ¨¡å‹å˜æ¢çŸ©é˜µï¼ˆModel Matrixï¼‰
- $\mathbf{V} \in \mathbb{R}^{4 \times 4}$ï¼šè§†å›¾å˜æ¢çŸ©é˜µï¼ˆView Matrixï¼‰
- $\mathbf{P} \in \mathbb{R}^{4 \times 4}$ï¼šæŠ•å½±å˜æ¢çŸ©é˜µï¼ˆProjection Matrixï¼‰

#### é€è§†é™¤æ³•ï¼ˆPerspective Divisionï¼‰

**é½æ¬¡åæ ‡åˆ°NDCçš„è½¬æ¢**ï¼š

é€è§†é™¤æ³•ï¼š$(x_{clip}, y_{clip}, z_{clip}, w_{clip}) \rightarrow (x_{clip}/w_{clip}, y_{clip}/w_{clip}, z_{clip}/w_{clip})$

$$\mathbf{V}_{ndc} = (x_{ndc}, y_{ndc}, z_{ndc}) = (x_{clip}/w_{clip}, y_{clip}/w_{clip}, z_{clip}/w_{clip})$$

**NDCèŒƒå›´**ï¼š$x_{ndc}, y_{ndc}, z_{ndc} \in [-1, 1]$

#### è§†å£å˜æ¢ï¼ˆViewport Transformï¼‰

**ä»NDCåˆ°å±å¹•åæ ‡**ï¼š

è§†å£å˜æ¢çŸ©é˜µ $\mathbf{S}$ çš„ç»“æ„ï¼š

- ç¬¬1è¡Œï¼š$(\frac{w}{2}, 0, 0, \frac{w}{2})$
- ç¬¬2è¡Œï¼š$(0, \frac{h}{2}, 0, \frac{h}{2})$
- ç¬¬3è¡Œï¼š$(0, 0, \frac{d}{2}, \frac{d}{2})$
- ç¬¬4è¡Œï¼š$(0, 0, 0, 1)$

$$\mathbf{S} = \text{viewport transformation matrix}$$

å…¶ä¸­ï¼š

- $w$ï¼šå±å¹•å®½åº¦ï¼ˆåƒç´ ï¼‰
- $h$ï¼šå±å¹•é«˜åº¦ï¼ˆåƒç´ ï¼‰
- $d$ï¼šæ·±åº¦ç¼“å†²åŒºèŒƒå›´

**æœ€ç»ˆå±å¹•åæ ‡**ï¼š

å¯¹äºNDCåæ ‡ $(x_{ndc}, y_{ndc}, z_{ndc}, 1)$ï¼Œå±å¹•åæ ‡ä¸ºï¼š
$$\mathbf{V}_{screen} = \left(\frac{w}{2}(x_{ndc} + 1), \frac{h}{2}(y_{ndc} + 1), \frac{d}{2}(z_{ndc} + 1), 1\right)$$

#### å˜æ¢çš„å‡ ä½•æ„ä¹‰

**åæ ‡ç³»çš„å³æ‰‹/å·¦æ‰‹çº¦å®š**ï¼š

- **OpenGL**ï¼šå³æ‰‹åæ ‡ç³»ï¼Œ$z_{ndc} \in [-1, 1]$
- **DirectX**ï¼šå·¦æ‰‹åæ ‡ç³»ï¼Œ$z_{ndc} \in [0, 1]$

**æ·±åº¦å€¼çš„éçº¿æ€§åˆ†å¸ƒ**ï¼š
é€è§†æŠ•å½±åï¼Œæ·±åº¦å€¼åœ¨è¿‘å¹³é¢é™„è¿‘å¯†é›†ï¼Œè¿œå¹³é¢é™„è¿‘ç¨€ç–ï¼š
$$z_{ndc} = \frac{-(f+n)z - 2fn}{z(f-n)}$$

## 5.2 å¯ç¼–ç¨‹ç€è‰²å™¨æ¶æ„

### 5.2.1 é¡¶ç‚¹ç€è‰²å™¨ï¼ˆVertex Shaderï¼‰

**ä¸»è¦åŠŸèƒ½**ï¼š

- é¡¶ç‚¹ä½ç½®å˜æ¢
- æ³•å‘é‡å˜æ¢
- çº¹ç†åæ ‡ä¼ é€’
- å…‰ç…§è®¡ç®—ï¼ˆGouraudç€è‰²ï¼‰

**å…¸å‹é¡¶ç‚¹ç€è‰²å™¨**ï¼š

```glsl
# version 330 core

layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoord;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

out vec3 FragPos;
out vec3 Normal;
out vec2 TexCoord;

void main() {
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = mat3(transpose(inverse(model))) * aNormal;
    TexCoord = aTexCoord;

    gl_Position = projection * view * vec4(FragPos, 1.0);
}
```

### 5.2.2 ç‰‡æ®µç€è‰²å™¨ï¼ˆFragment Shaderï¼‰

**ä¸»è¦åŠŸèƒ½**ï¼š

- åƒç´ é¢œè‰²è®¡ç®—
- çº¹ç†é‡‡æ ·
- å…‰ç…§è®¡ç®—ï¼ˆPhongç€è‰²ï¼‰
- ç‰¹æ•ˆå¤„ç†

**å…¸å‹ç‰‡æ®µç€è‰²å™¨**ï¼š

```glsl
# version 330 core

in vec3 FragPos;
in vec3 Normal;
in vec2 TexCoord;

uniform sampler2D texture_diffuse1;
uniform vec3 lightPos;
uniform vec3 viewPos;

out vec4 FragColor;

void main() {
    // ç¯å¢ƒå…‰
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * vec3(1.0);

    // æ¼«åå°„
    vec3 norm = normalize(Normal);
    vec3 lightDir = normalize(lightPos - FragPos);
    float diff = max(dot(norm, lightDir), 0.0);
    vec3 diffuse = diff * vec3(1.0);

    // é•œé¢åå°„
    float specularStrength = 0.5;
    vec3 viewDir = normalize(viewPos - FragPos);
    vec3 reflectDir = reflect(-lightDir, norm);
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
    vec3 specular = specularStrength * spec * vec3(1.0);

    vec3 result = (ambient + diffuse + specular) * texture(texture_diffuse1, TexCoord).rgb;
    FragColor = vec4(result, 1.0);
}
```

---

## é¡¶ç‚¹å¤„ç†ä¸å˜æ¢

## 6.1 é¡¶ç‚¹å±æ€§ä¸æ•°æ®ç»“æ„

### 6.1.1 é¡¶ç‚¹æ•°æ®ç»„ç»‡

**åŸºæœ¬é¡¶ç‚¹å±æ€§**ï¼š

```cpp
struct Vertex {
    Vector3f position;    // ä½ç½®
    Vector3f normal;      // æ³•å‘é‡
    Vector2f texCoord;    // çº¹ç†åæ ‡
    Vector3f tangent;     // åˆ‡å‘é‡
    Vector3f bitangent;   // å‰¯åˆ‡å‘é‡
    Vector4f color;       // é¡¶ç‚¹é¢œè‰²
};
```

**é¡¶ç‚¹ç¼“å†²å¯¹è±¡ï¼ˆVBOï¼‰**ï¼š

```cpp
// åˆ›å»ºå¹¶ç»‘å®šVBO
unsigned int VBO;
glGenBuffers(1, &VBO);
glBindBuffer(GL_ARRAY_BUFFER, VBO);
glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex),
             vertices.data(), GL_STATIC_DRAW);
```

### 6.1.2 é¡¶ç‚¹æ•°ç»„å¯¹è±¡ï¼ˆVAOï¼‰

**VAOçš„ä½œç”¨**ï¼š

- å­˜å‚¨é¡¶ç‚¹å±æ€§é…ç½®
- ç®€åŒ–æ¸²æŸ“è°ƒç”¨
- æé«˜æ¸²æŸ“æ•ˆç‡

**VAOé…ç½®ç¤ºä¾‹**ï¼š

```cpp
unsigned int VAO;
glGenVertexArrays(1, &VAO);
glBindVertexArray(VAO);

// ä½ç½®å±æ€§
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);
glEnableVertexAttribArray(0);

// æ³•å‘é‡å±æ€§
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex),
                      (void*)offsetof(Vertex, normal));
glEnableVertexAttribArray(1);

// çº¹ç†åæ ‡å±æ€§
glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex),
                      (void*)offsetof(Vertex, texCoord));
glEnableVertexAttribArray(2);
```

## 6.2 å˜æ¢çŸ©é˜µçš„è®¡ç®—ä¸ä¼˜åŒ–

### 6.2.1 æ³•å‘é‡å˜æ¢çš„æ•°å­¦æ¨å¯¼

#### é—®é¢˜çš„æå‡º

**æ ¸å¿ƒé—®é¢˜**ï¼šæ³•å‘é‡ä¸èƒ½ç›´æ¥ç”¨æ¨¡å‹å˜æ¢çŸ©é˜µè¿›è¡Œå˜æ¢ï¼Œå¦åˆ™ä¼šç ´åå‚ç›´å…³ç³»ã€‚

#### æ•°å­¦æ¨å¯¼è¿‡ç¨‹

**å¹³é¢çš„éšå¼è¡¨ç¤º**ï¼š
è®¾å¹³é¢æ–¹ç¨‹ä¸ºï¼š
$$\vec{n} \cdot \vec{p} = d$$

å…¶ä¸­ $\vec{n}$ æ˜¯æ³•å‘é‡ï¼Œ$\vec{p}$ æ˜¯å¹³é¢ä¸Šçš„ç‚¹ï¼Œ$d$ æ˜¯å¸¸æ•°ã€‚

**å˜æ¢åçš„çº¦æŸæ¡ä»¶**ï¼š
å˜æ¢åçš„å¹³é¢æ–¹ç¨‹åº”ä¸ºï¼š
$$\vec{n}' \cdot \vec{p}' = d$$

**ç‚¹çš„å˜æ¢å…³ç³»**ï¼š
å·²çŸ¥ç‚¹çš„å˜æ¢ä¸ºï¼š$\vec{p}' = \mathbf{M}\vec{p}$

**æ³•å‘é‡å˜æ¢çš„æ¨å¯¼**ï¼š
ä¸ºä¿æŒå‚ç›´å…³ç³»ï¼Œéœ€è¦ï¼š
$$\vec{n}' \cdot (\mathbf{M}\vec{p}) = \vec{n} \cdot \vec{p}$$

å°†å…¶å†™æˆçŸ©é˜µå½¢å¼ï¼š
$$(\vec{n}')^T \mathbf{M}\vec{p} = \vec{n}^T \vec{p}$$

ç”±äºè¿™å¯¹æ‰€æœ‰ $\vec{p}$ éƒ½æˆç«‹ï¼Œå› æ­¤ï¼š
$$(\vec{n}')^T \mathbf{M} = \vec{n}^T$$

è½¬ç½®å¾—åˆ°ï¼š
$$\mathbf{M}^T \vec{n}' = \vec{n}$$

è§£å¾—ï¼š
$$\vec{n}' = (\mathbf{M}^T)^{-1}\vec{n} = (\mathbf{M}^{-1})^T\vec{n}$$

#### æ³•å‘é‡å˜æ¢çŸ©é˜µ

**æ³•å‘é‡å˜æ¢çŸ©é˜µ**ï¼š
$$\mathbf{N} = (\mathbf{M}^{-1})^T$$

å…¶ä¸­ $\mathbf{M}$ æ˜¯æ¨¡å‹å˜æ¢çŸ©é˜µçš„å·¦ä¸Šè§’ $3 \times 3$ å­çŸ©é˜µã€‚

**ç‰¹æ®Šæƒ…å†µ**ï¼š

- **æ­£äº¤å˜æ¢**ï¼šå½“ $\mathbf{M}$ æ˜¯æ­£äº¤çŸ©é˜µæ—¶ï¼Œ$\mathbf{M}^{-1} = \mathbf{M}^T$ï¼Œå› æ­¤ $\mathbf{N} = \mathbf{M}$
- **å‡åŒ€ç¼©æ”¾**ï¼šå½“ $\mathbf{M} = s\mathbf{I}$ æ—¶ï¼Œ$\mathbf{N} = \frac{1}{s}\mathbf{I}$

#### å·¥ç¨‹å®ç°

```cpp
// è®¡ç®—æ³•å‘é‡å˜æ¢çŸ©é˜µ
Matrix3f compute_normal_matrix(const Matrix4f& model_matrix) {
    Matrix3f upper_left = model_matrix.block<3,3>(0,0);
    return upper_left.inverse().transpose();
}

// åº”ç”¨æ³•å‘é‡å˜æ¢
Vector3f transform_normal(const Vector3f& normal, const Matrix4f& model_matrix) {
    Matrix3f normal_matrix = compute_normal_matrix(model_matrix);
    Vector3f transformed = normal_matrix * normal;
    return transformed.normalized();  // é‡æ–°å½’ä¸€åŒ–
}
```

### 6.2.2 å˜æ¢çŸ©é˜µçš„TRSåˆ†è§£

#### TRSåˆ†è§£çš„æ•°å­¦ç†è®º

**åˆ†è§£å®šç†**ï¼š
ä»»ä½•éå¥‡å¼‚çš„ä»¿å°„å˜æ¢çŸ©é˜µ $\mathbf{M}$ éƒ½å¯ä»¥å”¯ä¸€åˆ†è§£ä¸ºï¼š
$$\mathbf{M} = \mathbf{T} \cdot \mathbf{R} \cdot \mathbf{S}$$

å…¶ä¸­ï¼š

- $\mathbf{T}$ï¼šå¹³ç§»çŸ©é˜µï¼ˆTranslationï¼‰
- $\mathbf{R}$ï¼šæ—‹è½¬çŸ©é˜µï¼ˆRotationï¼‰
- $\mathbf{S}$ï¼šç¼©æ”¾çŸ©é˜µï¼ˆScalingï¼‰

#### åˆ†è§£ç®—æ³•çš„æ•°å­¦æ¨å¯¼

**çŸ©é˜µç»“æ„åˆ†æ**ï¼š

å˜æ¢çŸ©é˜µçš„åˆ†å—ç»“æ„ï¼š

- å·¦ä¸Šè§’ $3 \times 3$ å­çŸ©é˜µ $\mathbf{A}$ï¼šåŒ…å«æ—‹è½¬å’Œç¼©æ”¾
- å³ä¸Šè§’åˆ—å‘é‡ $\vec{t}$ï¼šå¹³ç§»å‘é‡
- å·¦ä¸‹è§’è¡Œå‘é‡ $\vec{0}^T$ï¼šé›¶å‘é‡
- å³ä¸‹è§’æ ‡é‡ï¼š1

$$\mathbf{M} = \text{block matrix structure}$$

å…¶ä¸­ $\mathbf{A} \in \mathbb{R}^{3 \times 3}$ æ˜¯çº¿æ€§å˜æ¢éƒ¨åˆ†ï¼Œ$\vec{t} \in \mathbb{R}^3$ æ˜¯å¹³ç§»å‘é‡ã€‚

**ç¬¬ä¸€æ­¥ï¼šæå–å¹³ç§»**
$$\vec{t} = \mathbf{M}_{[0:3,3]}$$

**ç¬¬äºŒæ­¥ï¼šåˆ†è§£çº¿æ€§å˜æ¢**
å¯¹çŸ©é˜µ $\mathbf{A}$ è¿›è¡Œæåˆ†è§£ï¼š$\mathbf{A} = \mathbf{R} \cdot \mathbf{S}$

**ç¼©æ”¾å› å­è®¡ç®—**ï¼š
$$s_x = \|\mathbf{A}_{[:,0]}\|, \quad s_y = \|\mathbf{A}_{[:,1]}\|, \quad s_z = \|\mathbf{A}_{[:,2]}\|$$

**æ—‹è½¬çŸ©é˜µæå–**ï¼š

æ—‹è½¬çŸ©é˜µé€šè¿‡å½’ä¸€åŒ–åˆ—å‘é‡è·å¾—ï¼š
$$\mathbf{R} = [\frac{\mathbf{A}_{[:,0]}}{s_x}, \frac{\mathbf{A}_{[:,1]}}{s_y}, \frac{\mathbf{A}_{[:,2]}}{s_z}]$$

å…¶ä¸­æ¯ä¸€åˆ—éƒ½æ˜¯å½’ä¸€åŒ–åçš„æ—‹è½¬è½´ã€‚

#### å¤„ç†åå°„å˜æ¢

**è¡Œåˆ—å¼æ£€æŸ¥**ï¼š
å¦‚æœ $\det(\mathbf{A}) < 0$ï¼Œè¯´æ˜åŒ…å«åå°„å˜æ¢ï¼š
$$s_z = -s_z$$
$$\mathbf{R}_{[:,2]} = -\mathbf{R}_{[:,2]}$$

#### å®Œæ•´çš„åˆ†è§£å®ç°

```cpp
struct Transform {
    Vector3f translation;
    Quaternionf rotation;
    Vector3f scale;
};

Transform decompose_matrix(const Matrix4f& matrix) {
    Transform result;

    // 1. æå–å¹³ç§»
    result.translation = matrix.block<3,1>(0,3);

    // 2. æå–çº¿æ€§å˜æ¢éƒ¨åˆ†
    Matrix3f A = matrix.block<3,3>(0,0);

    // 3. è®¡ç®—ç¼©æ”¾å› å­
    result.scale.x() = A.col(0).norm();
    result.scale.y() = A.col(1).norm();
    result.scale.z() = A.col(2).norm();

    // 4. å¤„ç†åå°„ï¼ˆè´Ÿè¡Œåˆ—å¼ï¼‰
    if (A.determinant() < 0) {
        result.scale.z() = -result.scale.z();
    }

    // 5. æå–æ—‹è½¬çŸ©é˜µ
    Matrix3f R;
    R.col(0) = A.col(0) / result.scale.x();
    R.col(1) = A.col(1) / result.scale.y();
    R.col(2) = A.col(2) / result.scale.z();

    // 6. è½¬æ¢ä¸ºå››å…ƒæ•°
    result.rotation = Quaternionf(R);

    return result;
}
    rotation_matrix.col(1) = upper_left.col(1) / scale.y();
    rotation_matrix.col(2) = upper_left.col(2) / scale.z();

    // è½¬æ¢ä¸ºå››å…ƒæ•°
    rotation = Quaternionf(rotation_matrix);
}
```

---

## å›¾å…ƒè£…é…ä¸è£å‰ª

## 7.1 å›¾å…ƒè£…é…è¿‡ç¨‹

### 7.1.1 å›¾å…ƒç±»å‹

**åŸºæœ¬å›¾å…ƒ**ï¼š

- ç‚¹ï¼ˆPointsï¼‰
- çº¿æ®µï¼ˆLinesï¼‰
- ä¸‰è§’å½¢ï¼ˆTrianglesï¼‰

**æ‰©å±•å›¾å…ƒ**ï¼š

- çº¿æ¡å¸¦ï¼ˆLine Stripï¼‰
- ä¸‰è§’å½¢å¸¦ï¼ˆTriangle Stripï¼‰
- ä¸‰è§’å½¢æ‰‡ï¼ˆTriangle Fanï¼‰

### 7.1.2 ç´¢å¼•ç¼“å†²å¯¹è±¡ï¼ˆEBOï¼‰

**ä½œç”¨**ï¼šå‡å°‘é¡¶ç‚¹æ•°æ®å†—ä½™

**ç¤ºä¾‹**ï¼š

```cpp
// é¡¶ç‚¹æ•°æ®ï¼ˆ4ä¸ªé¡¶ç‚¹å®šä¹‰çŸ©å½¢ï¼‰
float vertices[] = {
     0.5f,  0.5f, 0.0f,  // å³ä¸Š
     0.5f, -0.5f, 0.0f,  // å³ä¸‹
    -0.5f, -0.5f, 0.0f,  // å·¦ä¸‹
    -0.5f,  0.5f, 0.0f   // å·¦ä¸Š
};

// ç´¢å¼•æ•°æ®ï¼ˆ2ä¸ªä¸‰è§’å½¢ï¼‰
unsigned int indices[] = {
    0, 1, 3,  // ç¬¬ä¸€ä¸ªä¸‰è§’å½¢
    1, 2, 3   // ç¬¬äºŒä¸ªä¸‰è§’å½¢
};

// åˆ›å»ºEBO
unsigned int EBO;
glGenBuffers(1, &EBO);
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
```

## 7.2 è£å‰ªç®—æ³•

### 7.2.1 è§†é”¥ä½“è£å‰ªçš„æ•°å­¦ç†è®º

#### è§†é”¥ä½“çš„æ•°å­¦å®šä¹‰

**æ ‡å‡†åŒ–è®¾å¤‡åæ ‡ï¼ˆNDCï¼‰ä¸­çš„è§†é”¥ä½“**ï¼š
åœ¨é½æ¬¡è£å‰ªåæ ‡ç³»ä¸­ï¼Œè§†é”¥ä½“ç”±å…­ä¸ªåŠç©ºé—´å®šä¹‰ï¼š

**å…­ä¸ªè£å‰ªå¹³é¢**ï¼š

- å·¦å¹³é¢ï¼š$x \geq -w$
- å³å¹³é¢ï¼š$x \leq w$
- ä¸‹å¹³é¢ï¼š$y \geq -w$
- ä¸Šå¹³é¢ï¼š$y \leq w$
- è¿‘å¹³é¢ï¼š$z \geq -w$
- è¿œå¹³é¢ï¼š$z \leq w$

å…¶ä¸­ $(x, y, z, w)$ æ˜¯é½æ¬¡è£å‰ªåæ ‡ã€‚

#### ç‚¹çš„è£å‰ªæµ‹è¯•

**æ•°å­¦æ¡ä»¶**ï¼š
ç‚¹ $\mathbf{P}_{clip} = (x, y, z, w)$ åœ¨è§†é”¥ä½“å†…å½“ä¸”ä»…å½“ï¼š
$$-w \leq x \leq w \quad \text{ä¸”} \quad -w \leq y \leq w \quad \text{ä¸”} \quad -w \leq z \leq w$$

**å‡ ä½•æ„ä¹‰**ï¼š
è¿™ç­‰ä»·äºé€è§†é™¤æ³•åçš„NDCåæ ‡æ»¡è¶³ï¼š
$$-1 \leq \frac{x}{w} \leq 1, \quad -1 \leq \frac{y}{w} \leq 1, \quad -1 \leq \frac{z}{w} \leq 1$$

#### å·¥ç¨‹å®ç°

```cpp
bool is_inside_frustum(const Vector4f& clip_pos) {
    float w = clip_pos.w();

    // æ£€æŸ¥wåˆ†é‡çš„æœ‰æ•ˆæ€§
    if (w <= 0) return false;  // åœ¨ç›¸æœºåæ–¹

    return (clip_pos.x() >= -w && clip_pos.x() <= w &&
            clip_pos.y() >= -w && clip_pos.y() <= w &&
            clip_pos.z() >= -w && clip_pos.z() <= w);
}

// è®¡ç®—ç‚¹åˆ°è£å‰ªå¹³é¢çš„è·ç¦»
float distance_to_plane(const Vector4f& point, int plane_index) {
    switch (plane_index) {
        case 0: return point.w() + point.x();  // å·¦å¹³é¢
        case 1: return point.w() - point.x();  // å³å¹³é¢
        case 2: return point.w() + point.y();  // ä¸‹å¹³é¢
        case 3: return point.w() - point.y();  // ä¸Šå¹³é¢
        case 4: return point.w() + point.z();  // è¿‘å¹³é¢
        case 5: return point.w() - point.z();  // è¿œå¹³é¢
        default: return 0.0f;
    }
}
```

### 7.2.2 Sutherland-Hodgmanè£å‰ªç®—æ³•

#### ç®—æ³•çš„æ•°å­¦åŸç†

**åŸºæœ¬æ€æƒ³**ï¼š
å¯¹å¤šè¾¹å½¢é€ä¸ªè£å‰ªå¹³é¢è¿›è¡Œè£å‰ªï¼Œæ¯æ¬¡è£å‰ªäº§ç”Ÿä¸€ä¸ªæ–°çš„å¤šè¾¹å½¢ï¼Œç›´åˆ°æ‰€æœ‰è£å‰ªå¹³é¢éƒ½å¤„ç†å®Œæ¯•ã€‚

**æ•°å­¦æ¨¡å‹**ï¼š
è®¾å¤šè¾¹å½¢çš„é¡¶ç‚¹åºåˆ—ä¸º $\{V_0, V_1, \ldots, V_{n-1}\}$ï¼Œè£å‰ªå¹³é¢æ–¹ç¨‹ä¸ºï¼š
$$\pi: \mathbf{n} \cdot \mathbf{p} + d = 0$$

å…¶ä¸­ $\mathbf{n}$ æ˜¯å¹³é¢æ³•å‘é‡ï¼Œ$d$ æ˜¯è·ç¦»å‚æ•°ã€‚

#### ç‚¹ä¸å¹³é¢çš„ä½ç½®å…³ç³»

**ç¬¦å·è·ç¦»å‡½æ•°**ï¼š
$$\text{dist}(\mathbf{p}, \pi) = \mathbf{n} \cdot \mathbf{p} + d$$

**ä½ç½®åˆ¤æ–­**ï¼š

- $\text{dist}(\mathbf{p}, \pi) > 0$ï¼šç‚¹åœ¨å¹³é¢æ­£ä¾§ï¼ˆå†…éƒ¨ï¼‰
- $\text{dist}(\mathbf{p}, \pi) = 0$ï¼šç‚¹åœ¨å¹³é¢ä¸Š
- $\text{dist}(\mathbf{p}, \pi) < 0$ï¼šç‚¹åœ¨å¹³é¢è´Ÿä¾§ï¼ˆå¤–éƒ¨ï¼‰

#### çº¿æ®µä¸å¹³é¢çš„äº¤ç‚¹è®¡ç®—

**å‚æ•°æ–¹ç¨‹**ï¼š
çº¿æ®µ $\overline{P_1P_2}$ çš„å‚æ•°æ–¹ç¨‹ä¸ºï¼š
$$\mathbf{L}(t) = \mathbf{P_1} + t(\mathbf{P_2} - \mathbf{P_1}), \quad t \in [0, 1]$$

**äº¤ç‚¹å‚æ•°æ±‚è§£**ï¼š
å°†å‚æ•°æ–¹ç¨‹ä»£å…¥å¹³é¢æ–¹ç¨‹ï¼š
$$\mathbf{n} \cdot [\mathbf{P_1} + t(\mathbf{P_2} - \mathbf{P_1})] + d = 0$$

è§£å¾—ï¼š
$$t = -\frac{\mathbf{n} \cdot \mathbf{P_1} + d}{\mathbf{n} \cdot (\mathbf{P_2} - \mathbf{P_1})} = -\frac{\text{dist}(\mathbf{P_1}, \pi)}{\mathbf{n} \cdot (\mathbf{P_2} - \mathbf{P_1})}$$

**äº¤ç‚¹åæ ‡**ï¼š
$$\mathbf{P}_{intersection} = \mathbf{P_1} + t(\mathbf{P_2} - \mathbf{P_1})$$

#### ç®—æ³•å®ç°

```cpp
class SutherlandHodgmanClipper {
private:
    struct Plane {
        Vector3f normal;
        float d;

        float distance(const Vector3f& point) const {
            return normal.dot(point) + d;
        }

        bool is_inside(const Vector3f& point) const {
            return distance(point) >= 0;
        }
    };

public:
    std::vector<Vector3f> clip_polygon(const std::vector<Vector3f>& polygon,
                                      const std::vector<Plane>& planes) {
        std::vector<Vector3f> input = polygon;

        for (const auto& plane : planes) {
            std::vector<Vector3f> output;

            if (input.empty()) break;

            Vector3f prev_vertex = input.back();
            bool prev_inside = plane.is_inside(prev_vertex);

            for (const auto& curr_vertex : input) {
                bool curr_inside = plane.is_inside(curr_vertex);

                if (curr_inside) {
                    if (!prev_inside) {
                        // ä»å¤–éƒ¨è¿›å…¥ï¼šæ·»åŠ äº¤ç‚¹
                        Vector3f intersection = compute_intersection(prev_vertex, curr_vertex, plane);
                        output.push_back(intersection);
                    }
                    // æ·»åŠ å½“å‰é¡¶ç‚¹
                    output.push_back(curr_vertex);
                } else if (prev_inside) {
                    // ä»å†…éƒ¨ç¦»å¼€ï¼šåªæ·»åŠ äº¤ç‚¹
                    Vector3f intersection = compute_intersection(prev_vertex, curr_vertex, plane);
                    output.push_back(intersection);
                }
                // ä¸¤ç‚¹éƒ½åœ¨å¤–éƒ¨ï¼šä¸æ·»åŠ ä»»ä½•ç‚¹

                prev_vertex = curr_vertex;
                prev_inside = curr_inside;
            }

            input = output;
        }

        return input;
    }

private:
    Vector3f compute_intersection(const Vector3f& p1, const Vector3f& p2, const Plane& plane) {
        Vector3f direction = p2 - p1;
        float denominator = plane.normal.dot(direction);

        if (std::abs(denominator) < 1e-6f) {
            return p1;  // çº¿æ®µå¹³è¡Œäºå¹³é¢
        }

        float t = -plane.distance(p1) / denominator;
        return p1 + t * direction;
    }
};
```

---

## å…‰æ …åŒ–ç®—æ³•è¯¦è§£

## 8.1 ä¸‰è§’å½¢å…‰æ …åŒ–åŸºç¡€

### 8.1.1 æ‰«æçº¿ç®—æ³•çš„æ•°å­¦åŸç†

#### ç®—æ³•æ¦‚è¿°ä¸æ•°å­¦åŸºç¡€

**åŸºæœ¬æ€æƒ³**ï¼šæ‰«æçº¿ç®—æ³•é€šè¿‡é€è¡Œæ‰«æçš„æ–¹å¼å¡«å……ä¸‰è§’å½¢ï¼Œæ˜¯ç»å…¸çš„å¤šè¾¹å½¢å…‰æ …åŒ–æ–¹æ³•ã€‚

**æ ¸å¿ƒæ•°å­¦åŸç†**ï¼š

1. **ç›´çº¿æ–¹ç¨‹**ï¼šåˆ©ç”¨ç›´çº¿çš„å‚æ•°æ–¹ç¨‹æˆ–éšå¼æ–¹ç¨‹è®¡ç®—äº¤ç‚¹
2. **åŒºé—´å¡«å……**ï¼šåœ¨æ¯æ¡æ‰«æçº¿ä¸Šå¡«å……å·¦å³è¾¹ç•Œä¹‹é—´çš„åƒç´ 
3. **å¢é‡è®¡ç®—**ï¼šåˆ©ç”¨ç›¸é‚»æ‰«æçº¿çš„ç›¸å…³æ€§ä¼˜åŒ–è®¡ç®—

#### ç›´çº¿æ–¹ç¨‹ä¸äº¤ç‚¹è®¡ç®—

**å‚æ•°ç›´çº¿æ–¹ç¨‹**ï¼š
è¿æ¥ç‚¹ $P_1(x_1, y_1)$ å’Œ $P_2(x_2, y_2)$ çš„ç›´çº¿ï¼š

å‚æ•°æ–¹ç¨‹ï¼ˆ$t \in [0, 1]$ï¼‰ï¼š
$$x(t) = x_1 + t(x_2 - x_1)$$
$$y(t) = y_1 + t(y_2 - y_1)$$

**æ‰«æçº¿äº¤ç‚¹è®¡ç®—**ï¼š
ç»™å®šæ°´å¹³æ‰«æçº¿ $y = y_s$ï¼Œæ±‚è§£å‚æ•° $t$ï¼š
$$y_s = y_1 + t(y_2 - y_1) \implies t = \frac{y_s - y_1}{y_2 - y_1}$$

ä»£å…¥xæ–¹ç¨‹å¾—äº¤ç‚¹ï¼š
$$x_s = x_1 + \frac{y_s - y_1}{y_2 - y_1}(x_2 - x_1) = x_1 + \frac{(y_s - y_1)(x_2 - x_1)}{y_2 - y_1}$$

**å¢é‡å½¢å¼ä¼˜åŒ–**ï¼š
ç›¸é‚»æ‰«æçº¿çš„xåæ ‡å¢é‡ï¼š
$$\Delta x = \frac{x_2 - x_1}{y_2 - y_1} = \frac{\Delta x}{\Delta y}$$

å› æ­¤ï¼š$x_{i+1} = x_i + \Delta x$

#### è¾¹æ–¹ç¨‹æ–¹æ³•ï¼ˆHalf-Space Testï¼‰

**éšå¼ç›´çº¿æ–¹ç¨‹**ï¼š
å¯¹äºç›´çº¿ $AB$ï¼Œéšå¼æ–¹ç¨‹ä¸ºï¼š
$$f_{AB}(x, y) = (y_A - y_B)x + (x_B - x_A)y + (x_A y_B - x_B y_A) = 0$$

**åŠç©ºé—´æµ‹è¯•**ï¼š
ç‚¹ $P(x, y)$ ç›¸å¯¹äºæœ‰å‘ç›´çº¿ $AB$ çš„ä½ç½®ï¼š

- $f_{AB}(P) > 0$ï¼šç‚¹åœ¨ç›´çº¿å·¦ä¾§
- $f_{AB}(P) = 0$ï¼šç‚¹åœ¨ç›´çº¿ä¸Š
- $f_{AB}(P) < 0$ï¼šç‚¹åœ¨ç›´çº¿å³ä¾§

**ä¸‰è§’å½¢å†…éƒ¨åˆ¤æ–­**ï¼š
å¯¹äºé€†æ—¶é’ˆæ–¹å‘çš„ä¸‰è§’å½¢ $ABC$ï¼Œç‚¹ $P$ åœ¨ä¸‰è§’å½¢å†…å½“ä¸”ä»…å½“ï¼š

**è¾¹å‡½æ•°å®šä¹‰**ï¼š

$$E_1(P) = (y_A - y_B)x_P + (x_B - x_A)y_P + (x_A y_B - x_B y_A) \geq 0$$

$$E_2(P) = (y_B - y_C)x_P + (x_C - x_B)y_P + (x_B y_C - x_C y_B) \geq 0$$

$$E_3(P) = (y_C - y_A)x_P + (x_A - x_C)y_P + (x_C y_A - x_A y_C) \geq 0$$

#### ä¼˜åŒ–çš„æ‰«æçº¿å®ç°

```cpp
void optimized_scanline_triangle(const Triangle& t) {
    auto vertices = t.toVector4();

    // æŒ‰yåæ ‡æ’åº
    std::sort(vertices.begin(), vertices.end(),
              [](const Vector4f& a, const Vector4f& b) { return a.y() < b.y(); });

    Vector4f v0 = vertices[0], v1 = vertices[1], v2 = vertices[2];

    // è®¡ç®—è¾¹çš„å¢é‡
    float dx01 = (v1.x() - v0.x()) / (v1.y() - v0.y());
    float dx02 = (v2.x() - v0.x()) / (v2.y() - v0.y());
    float dx12 = (v2.x() - v1.x()) / (v2.y() - v1.y());

    // ä¸ŠåŠéƒ¨åˆ†ä¸‰è§’å½¢ (v0 åˆ° v1)
    float x_left = v0.x(), x_right = v0.x();
    for (int y = v0.y(); y <= v1.y(); y++) {
        fill_horizontal_line(x_left, x_right, y, t.getColor());
        x_left += dx01;
        x_right += dx02;
    }

    // ä¸‹åŠéƒ¨åˆ†ä¸‰è§’å½¢ (v1 åˆ° v2)
    x_left = v1.x();  // é‡æ–°è®¾ç½®å·¦è¾¹ç•Œ
    for (int y = v1.y(); y <= v2.y(); y++) {
        fill_horizontal_line(x_left, x_right, y, t.getColor());
        x_left += dx12;
        x_right += dx02;
    }
}
```

### 8.1.2 é‡å¿ƒåæ ‡ç³»ç»Ÿï¼ˆBarycentric Coordinatesï¼‰

#### é‡å¿ƒåæ ‡çš„æ•°å­¦åŸºç¡€

**å®šä¹‰**ï¼šå¯¹äºä¸‰è§’å½¢ $\triangle ABC$ å’Œå¹³é¢å†…ä»»æ„ç‚¹ $P$ï¼Œé‡å¿ƒåæ ‡æ˜¯ä¸€ç»„æƒé‡ $(\alpha, \beta, \gamma)$ï¼Œä½¿å¾—ï¼š
$$P = \alpha A + \beta B + \gamma C$$
$$\alpha + \beta + \gamma = 1$$

**å‡ ä½•è§£é‡Š**ï¼š

- $\alpha, \beta, \gamma$ åˆ†åˆ«è¡¨ç¤ºç‚¹ $P$ ç›¸å¯¹äºé¡¶ç‚¹ $A, B, C$ çš„"é‡é‡"
- å½“ $\alpha, \beta, \gamma \geq 0$ æ—¶ï¼Œç‚¹ $P$ åœ¨ä¸‰è§’å½¢å†…éƒ¨
- é‡å¿ƒåæ ‡æä¾›äº†ä¸‰è§’å½¢å†…ä»»æ„ç‚¹çš„å”¯ä¸€è¡¨ç¤º

#### é‡å¿ƒåæ ‡çš„è®¡ç®—æ–¹æ³•

**é¢ç§¯æ¯”æ–¹æ³•**ï¼š
é‡å¿ƒåæ ‡ç­‰äºå­ä¸‰è§’å½¢é¢ç§¯ä¸æ€»ä¸‰è§’å½¢é¢ç§¯çš„æ¯”å€¼ï¼š
$$\alpha = \frac{S_{\triangle PBC}}{S_{\triangle ABC}}, \quad \beta = \frac{S_{\triangle APC}}{S_{\triangle ABC}}, \quad \gamma = \frac{S_{\triangle APB}}{S_{\triangle ABC}}$$

**å‘é‡å‰ç§¯è®¡ç®—**ï¼š
åˆ©ç”¨å‰ç§¯è®¡ç®—æœ‰å‘é¢ç§¯ï¼š
$$\alpha = \frac{(\vec{BP} \times \vec{BC}) \cdot \vec{n}}{(\vec{BA} \times \vec{BC}) \cdot \vec{n}}$$
å…¶ä¸­ $\vec{n}$ æ˜¯ä¸‰è§’å½¢çš„æ³•å‘é‡ã€‚

**GAMES101 Assignment 2å®ç°**ï¼š

```cpp
// åŸºäºé¢ç§¯çš„é‡å¿ƒåæ ‡è®¡ç®—
static std::tuple<float, float, float> computeBarycentric2D(float x, float y, const Vector3f* v) {
    float c1 = (x*(v[1].y() - v[2].y()) + (v[2].x() - v[1].x())*y + v[1].x()*v[2].y() - v[2].x()*v[1].y()) /
               (v[0].x()*(v[1].y() - v[2].y()) + (v[2].x() - v[1].x())*v[0].y() + v[1].x()*v[2].y() - v[2].x()*v[1].y());
    float c2 = (x*(v[2].y() - v[0].y()) + (v[0].x() - v[2].x())*y + v[2].x()*v[0].y() - v[0].x()*v[2].y()) /
               (v[1].x()*(v[2].y() - v[0].y()) + (v[0].x() - v[2].x())*v[1].y() + v[2].x()*v[0].y() - v[0].x()*v[2].y());
    float c3 = (x*(v[0].y() - v[1].y()) + (v[1].x() - v[0].x())*y + v[0].x()*v[1].y() - v[1].x()*v[0].y()) /
               (v[2].x()*(v[0].y() - v[1].y()) + (v[1].x() - v[0].x())*v[2].y() + v[0].x()*v[1].y() - v[1].x()*v[0].y());
    return {c1, c2, c3};
}

// ä¼˜åŒ–ç‰ˆæœ¬ï¼šé¿å…é‡å¤è®¡ç®—
Vector3f barycentric_coordinates(const Vector2f& A, const Vector2f& B,
                                const Vector2f& C, const Vector2f& P) {
    Vector2f v0 = C - A;
    Vector2f v1 = B - A;
    Vector2f v2 = P - A;

    float dot00 = v0.dot(v0);
    float dot01 = v0.dot(v1);
    float dot02 = v0.dot(v2);
    float dot11 = v1.dot(v1);
    float dot12 = v1.dot(v2);

    float inv_denom = 1.0f / (dot00 * dot11 - dot01 * dot01);
    float u = (dot11 * dot02 - dot01 * dot12) * inv_denom;
    float v = (dot00 * dot12 - dot01 * dot02) * inv_denom;

    return Vector3f(1.0f - u - v, v, u);  // $(\alpha, \beta, \gamma)$
}
```

#### é‡å¿ƒåæ ‡çš„å‡ ä½•æ„ä¹‰

**é¢ç§¯è§£é‡Š**ï¼š

- $\alpha = \frac{\text{Area}(\triangle PBC)}{\text{Area}(\triangle ABC)}$ï¼šç‚¹Påˆ°è¾¹BCçš„"è·ç¦»æƒé‡"
- $\beta = \frac{\text{Area}(\triangle APC)}{\text{Area}(\triangle ABC)}$ï¼šç‚¹Påˆ°è¾¹ACçš„"è·ç¦»æƒé‡"
- $\gamma = \frac{\text{Area}(\triangle APB)}{\text{Area}(\triangle ABC)}$ï¼šç‚¹Påˆ°è¾¹ABçš„"è·ç¦»æƒé‡"

**è¾¹ç•Œæƒ…å†µ**ï¼š

- $P = A$ï¼š$(\alpha, \beta, \gamma) = (1, 0, 0)$
- $P = B$ï¼š$(\alpha, \beta, \gamma) = (0, 1, 0)$
- $P = C$ï¼š$(\alpha, \beta, \gamma) = (0, 0, 1)$
- $P$ åœ¨è¾¹ $AB$ ä¸Šï¼š$\gamma = 0$ï¼Œ$\alpha + \beta = 1$

#### é‡å¿ƒåæ ‡çš„åº”ç”¨

**1. ç‚¹åœ¨ä¸‰è§’å½¢å†…éƒ¨åˆ¤æ–­**ï¼š

```cpp
bool is_inside_triangle(float alpha, float beta, float gamma) {
    return alpha >= 0 && beta >= 0 && gamma >= 0;
}
```

**2. å±æ€§æ’å€¼**ï¼š
å¯¹äºä¸‰è§’å½¢é¡¶ç‚¹çš„ä»»æ„å±æ€§ï¼ˆé¢œè‰²ã€æ·±åº¦ã€çº¹ç†åæ ‡ç­‰ï¼‰ï¼Œå¯ä»¥ç”¨é‡å¿ƒåæ ‡è¿›è¡Œæ’å€¼ï¼š

```cpp
// æ·±åº¦æ’å€¼
float interpolated_depth = alpha * depth_A + beta * depth_B + gamma * depth_C;

// é¢œè‰²æ’å€¼
Vector3f interpolated_color = alpha * color_A + beta * color_B + gamma * color_C;

// çº¹ç†åæ ‡æ’å€¼
Vector2f interpolated_uv = alpha * uv_A + beta * uv_B + gamma * uv_C;
```

## 8.2 å±æ€§æ’å€¼

### 8.2.1 é€è§†æ ¡æ­£æ’å€¼

**é—®é¢˜**ï¼šå±å¹•ç©ºé—´çš„çº¿æ€§æ’å€¼åœ¨é€è§†æŠ•å½±ä¸‹ä¸æ­£ç¡®

**è§£å†³æ–¹æ¡ˆ**ï¼šåœ¨é½æ¬¡åæ ‡ç©ºé—´è¿›è¡Œæ’å€¼

**é€è§†æ­£ç¡®æ’å€¼å…¬å¼**ï¼š

æ·±åº¦å€’æ•°æ’å€¼ï¼š
$$\frac{1}{z} = \frac{\alpha}{z_1} + \frac{\beta}{z_2} + \frac{\gamma}{z_3}$$

çº¹ç†åæ ‡uåˆ†é‡æ’å€¼ï¼š
$$\frac{u}{z} = \alpha\frac{u_1}{z_1} + \beta\frac{u_2}{z_2} + \gamma\frac{u_3}{z_3}$$

çº¹ç†åæ ‡våˆ†é‡æ’å€¼ï¼š
$$\frac{v}{z} = \alpha\frac{v_1}{z_1} + \beta\frac{v_2}{z_2} + \gamma\frac{v_3}{z_3}$$

æœ€ç»ˆçº¹ç†åæ ‡ï¼š
$$u = \frac{u/z}{1/z}, \quad v = \frac{v/z}{1/z}$$

**ä»£ç å®ç°**ï¼š

```cpp
Vector2f perspective_correct_interpolation(const Vector3f& bary,
                                          const Vector2f& uv1, float z1,
                                          const Vector2f& uv2, float z2,
                                          const Vector2f& uv3, float z3) {
    float inv_z = bary.x() / z1 + bary.y() / z2 + bary.z() / z3;
    float u_over_z = bary.x() * uv1.x() / z1 +
                     bary.y() * uv2.x() / z2 +
                     bary.z() * uv3.x() / z3;
    float v_over_z = bary.x() * uv1.y() / z1 +
                     bary.y() * uv2.y() / z2 +
                     bary.z() * uv3.y() / z3;

    return Vector2f(u_over_z / inv_z, v_over_z / inv_z);
}
```

### 8.2.2 ç°ä»£GPUå¹¶è¡Œå…‰æ …åŒ–ç®—æ³•

#### Tile-Basedå…‰æ …åŒ–

**åŸºæœ¬æ€æƒ³**ï¼š
ç°ä»£GPUå°†å±å¹•åˆ†å‰²æˆå°çš„tileï¼ˆé€šå¸¸8Ã—8æˆ–16Ã—16åƒç´ ï¼‰ï¼Œæ¯ä¸ªtileå¹¶è¡Œå¤„ç†ã€‚

**ç®—æ³•æµç¨‹**ï¼š

1. **Tileåˆ†å‰²**ï¼šå°†å±å¹•åˆ†æˆè§„åˆ™çš„tileç½‘æ ¼
2. **ä¸‰è§’å½¢åˆ†é…**ï¼šç¡®å®šæ¯ä¸ªä¸‰è§’å½¢è¦†ç›–å“ªäº›tile
3. **å¹¶è¡Œå…‰æ …åŒ–**ï¼šæ¯ä¸ªtileç‹¬ç«‹è¿›è¡Œå…‰æ …åŒ–
4. **ç»“æœåˆå¹¶**ï¼šå°†å„tileçš„ç»“æœåˆå¹¶åˆ°æœ€ç»ˆå›¾åƒ

**æ•°å­¦æ¨¡å‹**ï¼š
å¯¹äºtile $(i, j)$ï¼Œå…¶å±å¹•åæ ‡èŒƒå›´ä¸ºï¼š

**Tileåæ ‡è®¡ç®—**ï¼š
$$x_{min} = i \times \text{tile\_size}$$
$$x_{max} = (i + 1) \times \text{tile\_size} - 1$$
$$y_{min} = j \times \text{tile\_size}$$
$$y_{max} = (j + 1) \times \text{tile\_size} - 1$$

**ä¸‰è§’å½¢-Tileç›¸äº¤æµ‹è¯•**ï¼š
ä½¿ç”¨åˆ†ç¦»è½´å®šç†ï¼ˆSATï¼‰æˆ–åŒ…å›´ç›’æµ‹è¯•å¿«é€Ÿåˆ¤æ–­ä¸‰è§’å½¢æ˜¯å¦ä¸tileç›¸äº¤ã€‚

#### GPU Warp/Wavefrontå¹¶è¡Œæ¨¡å‹

**SIMDæ‰§è¡Œæ¨¡å‹**ï¼š
GPUä»¥warpï¼ˆNVIDIAï¼‰æˆ–wavefrontï¼ˆAMDï¼‰ä¸ºå•ä½æ‰§è¡Œï¼Œé€šå¸¸åŒ…å«32ä¸ªçº¿ç¨‹ã€‚

**å¹¶è¡Œå…‰æ …åŒ–å®ç°**ï¼š

```cpp
// GPU kernelä¼ªä»£ç 
__global__ void rasterize_triangle_kernel(Triangle* triangles, int num_triangles,
                                         float* framebuffer, float* depth_buffer,
                                         int width, int height) {
    int pixel_x = blockIdx.x * blockDim.x + threadIdx.x;
    int pixel_y = blockIdx.y * blockDim.y + threadIdx.y;

    if (pixel_x >= width || pixel_y >= height) return;

    float min_depth = FLT_MAX;
    Vector3f final_color(0, 0, 0);

    // éå†æ‰€æœ‰ä¸‰è§’å½¢
    for (int i = 0; i < num_triangles; i++) {
        Triangle& tri = triangles[i];

        // è®¡ç®—é‡å¿ƒåæ ‡
        auto [alpha, beta, gamma] = computeBarycentric2D(pixel_x, pixel_y, tri.vertices);

        // å†…éƒ¨æµ‹è¯•
        if (alpha >= 0 && beta >= 0 && gamma >= 0) {
            // æ’å€¼æ·±åº¦
            float depth = alpha * tri.vertices[0].z +
                         beta * tri.vertices[1].z +
                         gamma * tri.vertices[2].z;

            // æ·±åº¦æµ‹è¯•
            if (depth < min_depth) {
                min_depth = depth;

                // æ’å€¼é¢œè‰²
                final_color = alpha * tri.colors[0] +
                             beta * tri.colors[1] +
                             gamma * tri.colors[2];
            }
        }
    }

    // å†™å…¥framebuffer
    int pixel_index = pixel_y * width + pixel_x;
    framebuffer[pixel_index * 3 + 0] = final_color.x;
    framebuffer[pixel_index * 3 + 1] = final_color.y;
    framebuffer[pixel_index * 3 + 2] = final_color.z;
    depth_buffer[pixel_index] = min_depth;
}
```

#### Early-Zä¼˜åŒ–æŠ€æœ¯

**Z-Prepass**ï¼š
åœ¨ä¸»æ¸²æŸ“passä¹‹å‰ï¼Œå…ˆè¿›è¡Œä¸€æ¬¡åªå†™æ·±åº¦çš„passï¼š

```cpp
// Z-Prepassé˜¶æ®µ
void z_prepass(const std::vector<Triangle>& triangles) {
    for (const auto& tri : triangles) {
        rasterize_triangle_depth_only(tri);
    }
}

// ä¸»æ¸²æŸ“é˜¶æ®µ
void main_render_pass(const std::vector<Triangle>& triangles) {
    for (const auto& tri : triangles) {
        rasterize_triangle_with_early_z(tri);
    }
}
```

**Early-Zæµ‹è¯•**ï¼š
åœ¨ç‰‡æ®µç€è‰²å™¨æ‰§è¡Œå‰è¿›è¡Œæ·±åº¦æµ‹è¯•ï¼Œå¯ä»¥å¤§å¹…å‡å°‘ä¸å¿…è¦çš„ç€è‰²è®¡ç®—ã€‚

#### å±‚æ¬¡åŒ–Z-Bufferï¼ˆHi-Zï¼‰

**åŸºæœ¬åŸç†**ï¼š
æ„å»ºæ·±åº¦ç¼“å†²åŒºçš„mipmapå±‚æ¬¡ç»“æ„ï¼Œæ¯ä¸ªå±‚çº§å­˜å‚¨ä¸‹ä¸€çº§çš„æœ€å°/æœ€å¤§æ·±åº¦å€¼ã€‚

**å¿«é€Ÿå‰”é™¤**ï¼š

```cpp
bool hierarchical_z_test(int x, int y, float z, int level) {
    int tile_x = x >> level;
    int tile_y = y >> level;

    float max_z = hi_z_buffer[level][tile_y * (width >> level) + tile_x];

    return z <= max_z;  // å¦‚æœå½“å‰æ·±åº¦å¤§äºtileæœ€å¤§æ·±åº¦ï¼Œå¯ä»¥å‰”é™¤
}
```

### 8.2.3 Mipmapä¸çº¹ç†è¿‡æ»¤

**MipmapåŸç†**ï¼šé¢„è®¡ç®—å¤šçº§çº¹ç†ï¼Œæ ¹æ®åƒç´ è¦†ç›–é¢ç§¯é€‰æ‹©åˆé€‚çº§åˆ«

**çº§åˆ«è®¡ç®—**ï¼š

```cpp
float calculate_mipmap_level(const Vector2f& duv_dx, const Vector2f& duv_dy,
                            int texture_width, int texture_height) {
    float du_dx = duv_dx.x() * texture_width;
    float dv_dx = duv_dx.y() * texture_height;
    float du_dy = duv_dy.x() * texture_width;
    float dv_dy = duv_dy.y() * texture_height;

    float max_sqr = std::max(du_dx * du_dx + dv_dx * dv_dx,
                            du_dy * du_dy + dv_dy * dv_dy);

    return 0.5f * std::log2(max_sqr);
}
```

**ä¸‰çº¿æ€§è¿‡æ»¤**ï¼š

1. åœ¨ä¸¤ä¸ªç›¸é‚»mipmapçº§åˆ«åˆ†åˆ«è¿›è¡ŒåŒçº¿æ€§è¿‡æ»¤
2. åœ¨ä¸¤ä¸ªç»“æœé—´è¿›è¡Œçº¿æ€§æ’å€¼

---

## æ·±åº¦æµ‹è¯•ä¸éšè—é¢æ¶ˆé™¤

## 9.1 Z-Bufferç®—æ³•

### 9.1.1 ç®—æ³•åŸç†

**åŸºæœ¬æ€æƒ³**ï¼šä¸ºæ¯ä¸ªåƒç´ ç»´æŠ¤ä¸€ä¸ªæ·±åº¦å€¼ï¼Œåªç»˜åˆ¶æœ€è¿‘çš„è¡¨é¢

**ç®—æ³•æ­¥éª¤**ï¼š

```cpp
// åˆå§‹åŒ–
for each pixel (x, y):
    color_buffer[x][y] = background_color
    depth_buffer[x][y] = infinity

// æ¸²æŸ“
for each triangle:
    for each pixel (x, y) in triangle:
        z = interpolated_depth(x, y)
        if z < depth_buffer[x][y]:
            depth_buffer[x][y] = z
            color_buffer[x][y] = shaded_color(x, y)
```

### 9.1.2 æ·±åº¦å€¼è®¡ç®—çš„æ•°å­¦åˆ†æ

#### çº¿æ€§æ·±åº¦ä¸éçº¿æ€§æ·±åº¦

**çº¿æ€§æ·±åº¦ï¼ˆè§‚å¯Ÿç©ºé—´ï¼‰**ï¼š
åœ¨è§‚å¯Ÿç©ºé—´ä¸­ï¼Œæ·±åº¦å€¼ä¸è·ç¦»æˆçº¿æ€§å…³ç³»ï¼š
$$z_{linear} = \frac{z_{eye} - n}{f - n}$$

å…¶ä¸­ $z_{eye}$ æ˜¯è§‚å¯Ÿç©ºé—´ä¸­çš„æ·±åº¦ï¼Œ$n$ å’Œ $f$ åˆ†åˆ«æ˜¯è¿‘å¹³é¢å’Œè¿œå¹³é¢è·ç¦»ã€‚

**éçº¿æ€§æ·±åº¦ï¼ˆé€è§†æŠ•å½±åï¼‰**ï¼š
ç»è¿‡é€è§†æŠ•å½±å’Œé€è§†é™¤æ³•åï¼ŒNDCç©ºé—´ä¸­çš„æ·±åº¦ä¸ºï¼š
$$z_{ndc} = \frac{f + n}{f - n} + \frac{2fn}{(f - n) \cdot z_{eye}}$$

#### æ·±åº¦ç²¾åº¦åˆ†æ

**ç²¾åº¦åˆ†å¸ƒå‡½æ•°**ï¼š
æ·±åº¦ç¼“å†²åŒºç²¾åº¦å®šä¹‰ä¸ºï¼š
$$\text{precision}(z) = \frac{dz_{buffer}}{dz_{eye}} = \frac{2fn}{z_{eye}^2(f-n)}$$

**å…³é”®è§‚å¯Ÿ**ï¼š

- ç²¾åº¦ä¸ $z_{eye}^2$ æˆåæ¯”
- è¿‘å¹³é¢é™„è¿‘ç²¾åº¦æœ€é«˜
- è¿œå¹³é¢é™„è¿‘ç²¾åº¦æ€¥å‰§ä¸‹é™

#### Z-Fightingçš„æ•°å­¦åŸå› 

**æµ®ç‚¹ç²¾åº¦é™åˆ¶**ï¼š
å¯¹äº24ä½æ·±åº¦ç¼“å†²åŒºï¼Œæœ€å°å¯åˆ†è¾¨æ·±åº¦å·®ä¸ºï¼š
$$\Delta z_{min} = \frac{1}{2^{24}} \approx 5.96 \times 10^{-8}$$

**ä¸´ç•Œè·ç¦»è®¡ç®—**ï¼š
ä¸¤ä¸ªè¡¨é¢åœ¨è·ç¦» $z$ å¤„å¯åˆ†è¾¨çš„æœ€å°é—´è·ä¸ºï¼š
$$\Delta z_{world} = \frac{z^2(f-n)}{2fn} \cdot \Delta z_{min}$$

#### æ·±åº¦ç²¾åº¦ä¼˜åŒ–ç­–ç•¥

**1. è¿‘è¿œå¹³é¢æ¯”å€¼ä¼˜åŒ–**ï¼š
æœ€ä¼˜æ¯”å€¼å…³ç³»ï¼š
$$\frac{f}{n} < 10^3$$

**2. å¯¹æ•°æ·±åº¦ç¼“å†²**ï¼š
ä½¿ç”¨å¯¹æ•°åˆ†å¸ƒæ”¹å–„ç²¾åº¦ï¼š
$$z_{log} = \frac{\log(z_{eye}/n)}{\log(f/n)}$$

**3. åå‘Zç¼“å†²**ï¼š
å°†æ·±åº¦æ˜ å°„åè½¬ï¼š
$$z_{reverse} = 1 - z_{ndc}$$

åˆ©ç”¨æµ®ç‚¹æ•°åœ¨0é™„è¿‘ç²¾åº¦æ›´é«˜çš„ç‰¹æ€§ã€‚

#### å·¥ç¨‹å®ç°

```cpp
// æ·±åº¦ç²¾åº¦åˆ†æå·¥å…·
class DepthPrecisionAnalyzer {
public:
    static float compute_precision(float z_eye, float near, float far) {
        return (2.0f * far * near) / (z_eye * z_eye * (far - near));
    }

    static float min_resolvable_distance(float z_eye, float near, float far, int depth_bits) {
        float depth_resolution = 1.0f / (1 << depth_bits);
        float precision = compute_precision(z_eye, near, far);
        return depth_resolution / precision;
    }

    static void analyze_depth_distribution(float near, float far, int samples = 100) {
        std::cout << "Depth Precision Analysis:\n";
        std::cout << "Near: " << near << ", Far: " << far << "\n";
        std::cout << "Ratio: " << far/near << "\n\n";

        for (int i = 0; i < samples; i++) {
            float t = static_cast<float>(i) / (samples - 1);
            float z_eye = near + t * (far - near);
            float precision = compute_precision(z_eye, near, far);
            float min_dist = min_resolvable_distance(z_eye, near, far, 24);

            std::cout << "z=" << z_eye << ", precision=" << precision
                      << ", min_dist=" << min_dist << "\n";
        }
    }
};

// åå‘Zç¼“å†²å®ç°
Matrix4f create_reverse_z_projection(float fov, float aspect, float near, float far) {
    Matrix4f proj = Matrix4f::Zero();

    float tan_half_fov = std::tan(fov * 0.5f);

    proj(0, 0) = 1.0f / (aspect * tan_half_fov);
    proj(1, 1) = 1.0f / tan_half_fov;
    proj(2, 2) = near / (far - near);           // åå‘æ˜ å°„
    proj(2, 3) = (far * near) / (far - near);
    proj(3, 2) = 1.0f;                         // æ³¨æ„ï¼šè¿™é‡Œæ˜¯+1è€Œä¸æ˜¯-1

    return proj;
}
```

## 9.2 å…¶ä»–éšè—é¢æ¶ˆé™¤ç®—æ³•

### 9.2.1 ç”»å®¶ç®—æ³•

**åŸç†**ï¼šæŒ‰æ·±åº¦ä»è¿œåˆ°è¿‘ç»˜åˆ¶ç‰©ä½“

**ä¼˜ç‚¹**ï¼š

- ç®€å•æ˜“å®ç°
- æ”¯æŒé€æ˜åº¦æ··åˆ

**ç¼ºç‚¹**ï¼š

- éœ€è¦æ’åºï¼Œå¤æ‚åº¦é«˜
- æ— æ³•å¤„ç†å¾ªç¯é®æŒ¡

**å®ç°**ï¼š

```cpp
struct Triangle {
    Vector3f vertices[3];
    float avg_depth;
    Color color;
};

bool depth_compare(const Triangle& a, const Triangle& b) {
    return a.avg_depth > b.avg_depth;  // è¿œåˆ°è¿‘æ’åº
}

void painters_algorithm(std::vector<Triangle>& triangles) {
    // è®¡ç®—æ¯ä¸ªä¸‰è§’å½¢çš„å¹³å‡æ·±åº¦
    for (auto& tri : triangles) {
        tri.avg_depth = (tri.vertices[0].z() +
                        tri.vertices[1].z() +
                        tri.vertices[2].z()) / 3.0f;
    }

    // æ’åºå¹¶ç»˜åˆ¶
    std::sort(triangles.begin(), triangles.end(), depth_compare);

    for (const auto& tri : triangles) {
        rasterize_triangle(tri);
    }
}
```

### 9.2.2 BSPæ ‘ç®—æ³•

**åŸç†**ï¼šç”¨äºŒå‰ç©ºé—´åˆ†å‰²æ ‘é¢„å¤„ç†åœºæ™¯

**æ„å»ºè¿‡ç¨‹**ï¼š

1. é€‰æ‹©åˆ†å‰²å¹³é¢
2. å°†å¤šè¾¹å½¢åˆ†ä¸ºå‰ã€åä¸¤ç»„
3. é€’å½’æ„å»ºå­æ ‘

**éå†æ¸²æŸ“**ï¼š

```cpp
void render_bsp_tree(BSPNode* node, const Vector3f& view_pos) {
    if (!node) return;

    float distance = node->plane.distance_to_point(view_pos);

    if (distance > 0) {
        // è§‚å¯Ÿè€…åœ¨å¹³é¢å‰æ–¹
        render_bsp_tree(node->back, view_pos);   // å…ˆç”»åé¢
        render_polygons(node->polygons);         // å†ç”»å¹³é¢ä¸Šçš„å¤šè¾¹å½¢
        render_bsp_tree(node->front, view_pos);  // æœ€åç”»å‰é¢
    } else {
        // è§‚å¯Ÿè€…åœ¨å¹³é¢åæ–¹
        render_bsp_tree(node->front, view_pos);
        render_polygons(node->polygons);
        render_bsp_tree(node->back, view_pos);
    }
}
```

---

## å…‰ç…§æ¨¡å‹ä¸ç€è‰²

## 10.1 å…‰ç…§çš„ç‰©ç†åŸºç¡€ç†è®º

### 10.1.1 è¾å°„åº¦é‡å­¦çš„æ•°å­¦æ¡†æ¶

#### åŸºæœ¬è¾å°„é‡çš„å®šä¹‰

**è¾å°„èƒ½é‡ï¼ˆRadiant Energyï¼‰**ï¼š
$$Q \quad [\text{ç„¦è€³, J}]$$
è¡¨ç¤ºç”µç£è¾å°„æºå¸¦çš„æ€»èƒ½é‡ã€‚

**è¾å°„é€šé‡ï¼ˆRadiant Flux/Powerï¼‰**ï¼š
$$\Phi = \frac{dQ}{dt} \quad [\text{ç“¦ç‰¹, W}]$$
è¡¨ç¤ºå•ä½æ—¶é—´å†…é€šè¿‡æŸä¸ªè¡¨é¢çš„è¾å°„èƒ½é‡ã€‚

**è¾å°„å¼ºåº¦ï¼ˆRadiant Intensityï¼‰**ï¼š
$$I(\omega) = \frac{d\Phi}{d\omega} \quad [\text{W/sr}]$$
è¡¨ç¤ºç‚¹å…‰æºåœ¨æŸä¸ªæ–¹å‘ä¸Šå•ä½ç«‹ä½“è§’å†…çš„è¾å°„é€šé‡ã€‚

**è¾ç…§åº¦ï¼ˆIrradianceï¼‰**ï¼š
$$E(\mathbf{p}) = \frac{d\Phi}{dA} \quad [\text{W/m}^2]$$
è¡¨ç¤ºå•ä½é¢ç§¯æ¥æ”¶åˆ°çš„è¾å°„é€šé‡ã€‚

**è¾å°„åº¦ï¼ˆRadianceï¼‰**ï¼š
$$L(\mathbf{p}, \omega) = \frac{d^2\Phi}{d\omega \, dA \cos\theta} \quad [\text{W/(sr}\cdot\text{m}^2\text{)}]$$

è¿™æ˜¯æœ€é‡è¦çš„è¾å°„é‡ï¼Œå…¶ä¸­ $\theta$ æ˜¯æ–¹å‘ $\omega$ ä¸è¡¨é¢æ³•å‘é‡çš„å¤¹è§’ã€‚

#### è¾å°„åº¦çš„é‡è¦æ€§è´¨

**1. æ„ŸçŸ¥ç›¸å…³æ€§**ï¼š
è¾å°„åº¦ç›´æ¥å¯¹åº”äºäººçœ¼æˆ–ç›¸æœºä¼ æ„Ÿå™¨æ¥æ”¶åˆ°çš„å…‰å¼ºã€‚

**2. ä¼ æ’­ä¸å˜æ€§**ï¼š
åœ¨çœŸç©ºä¸­ï¼Œè¾å°„åº¦æ²¿ç›´çº¿ä¼ æ’­æ—¶ä¿æŒä¸å˜ï¼š
$$L(\mathbf{p}_1, \omega_{12}) = L(\mathbf{p}_2, \omega_{21})$$

**3. å¯åŠ æ€§**ï¼š
å¤šä¸ªå…‰æºçš„è¾å°„åº¦å¯ä»¥ç›´æ¥ç›¸åŠ ï¼š
$$L_{total} = \sum_i L_i$$

### 10.1.2 åŒå‘åå°„åˆ†å¸ƒå‡½æ•°ï¼ˆBRDFï¼‰ç†è®º

#### BRDFçš„ä¸¥æ ¼æ•°å­¦å®šä¹‰

**å¾®åˆ†å½¢å¼å®šä¹‰**ï¼š
$$f_r(\mathbf{p}, \omega_i, \omega_r) = \frac{dL_r(\mathbf{p}, \omega_r)}{dE_i(\mathbf{p}, \omega_i)} = \frac{dL_r(\mathbf{p}, \omega_r)}{L_i(\mathbf{p}, \omega_i) \cos\theta_i \, d\omega_i}$$

å…¶ä¸­ï¼š

- $L_r(\mathbf{p}, \omega_r)$ï¼šåå°„è¾å°„åº¦
- $E_i(\mathbf{p}, \omega_i)$ï¼šå…¥å°„è¾ç…§åº¦
- $L_i(\mathbf{p}, \omega_i)$ï¼šå…¥å°„è¾å°„åº¦

#### BRDFçš„ç‰©ç†çº¦æŸæ¡ä»¶

**1. éè´Ÿæ€§çº¦æŸ**ï¼š
$$f_r(\mathbf{p}, \omega_i, \omega_r) \geq 0$$

**2. èƒ½é‡å®ˆæ’çº¦æŸ**ï¼š
$$\int_{\Omega} f_r(\mathbf{p}, \omega_i, \omega_r) \cos\theta_r \, d\omega_r \leq 1$$

è¿™ç¡®ä¿åå°„çš„èƒ½é‡ä¸è¶…è¿‡å…¥å°„èƒ½é‡ã€‚

**3. äº¥å§†éœå…¹äº’æ˜“æ€§**ï¼š
$$f_r(\mathbf{p}, \omega_i, \omega_r) = f_r(\mathbf{p}, \omega_r, \omega_i)$$

è¿™æ˜¯åŸºäºå…‰è·¯å¯é€†æ€§çš„ç‰©ç†åŸç†ã€‚

#### BRDFçš„å‡ ä½•è§£é‡Š

**ç«‹ä½“è§’å¾®åˆ†**ï¼š
$$d\omega = \frac{dA \cos\theta}{r^2}$$

å…¶ä¸­ $dA$ æ˜¯æŠ•å½±é¢ç§¯ï¼Œ$r$ æ˜¯è·ç¦»ï¼Œ$\theta$ æ˜¯ä¸æ³•å‘é‡çš„å¤¹è§’ã€‚

**åŠçƒç§¯åˆ†**ï¼š
BRDFåœ¨ä¸ŠåŠçƒé¢ä¸Šçš„ç§¯åˆ†ç»™å‡ºäº†åå°„ç‡ï¼š
$$\rho(\omega_i) = \int_{\Omega} f_r(\omega_i, \omega_r) \cos\theta_r \, d\omega_r$$

## 10.2 ç»å…¸å…‰ç…§æ¨¡å‹çš„æ•°å­¦æ¨å¯¼

### 10.2.1 Lambertæ¼«åå°„æ¨¡å‹

#### ç‰©ç†åŸç†ä¸å‡è®¾

**ç†æƒ³æ¼«åå°„è¡¨é¢çš„ç‰¹å¾**ï¼š

1. **å„å‘åŒæ€§**ï¼šåå°„åœ¨æ‰€æœ‰æ–¹å‘ä¸Šå‡åŒ€åˆ†å¸ƒ
2. **å®Œå…¨æ¼«åå°„**ï¼šæ²¡æœ‰é•œé¢åå°„åˆ†é‡
3. **è¡¨é¢ç²—ç³™**ï¼šå¾®è§‚ç»“æ„å¯¼è‡´å…‰çº¿éšæœºæ•£å°„

#### Lambert BRDFçš„æ•°å­¦æ¨å¯¼

**åŸºæœ¬å‡è®¾**ï¼šåå°„è¾å°„åº¦åœ¨æ‰€æœ‰æ–¹å‘ä¸Šæ’å®š
$$L_r(\omega_r) = \text{å¸¸æ•°}$$

**èƒ½é‡å®ˆæ’çº¦æŸ**ï¼š
$$\int_{\Omega} f_r \cos\theta_r \, d\omega_r = \rho_d$$

å…¶ä¸­ $\rho_d$ æ˜¯æ¼«åå°„ç‡ï¼ˆalbedoï¼‰ã€‚

**åŠçƒç§¯åˆ†è®¡ç®—**ï¼š
$$\int_{\Omega} \cos\theta_r \, d\omega_r = \int_0^{2\pi} \int_0^{\pi/2} \cos\theta_r \sin\theta_r \, d\theta_r \, d\phi = \pi$$

**Lambert BRDFæ¨å¯¼**ï¼š
ç”±äº $f_r$ ä¸ºå¸¸æ•°ï¼Œç»“åˆèƒ½é‡å®ˆæ’ï¼š
$$f_r \cdot \pi = \rho_d$$

å› æ­¤ï¼š
$$f_r = \frac{\rho_d}{\pi}$$

#### Lambertä½™å¼¦å®šå¾‹

**åå°„è¾å°„åº¦è®¡ç®—**ï¼š
$$L_r = \int_{\Omega} f_r L_i(\omega_i) \cos\theta_i \, d\omega_i$$

å¯¹äºå¹³è¡Œå…‰æºï¼š
$$L_r = f_r L_i \cos\theta_i = \frac{\rho_d}{\pi} L_i \cos\theta_i$$

**ç‰©ç†æ„ä¹‰**ï¼š

- $\cos\theta_i$ é¡¹ä½“ç°äº†æŠ•å½±é¢ç§¯æ•ˆåº”
- å…¥å°„è§’è¶Šå¤§ï¼Œæœ‰æ•ˆç…§å°„é¢ç§¯è¶Šå°

#### å·¥ç¨‹å®ç°

```cpp
Vector3f lambert_diffuse(const Vector3f& light_dir, const Vector3f& normal,
                        const Vector3f& light_color, const Vector3f& albedo) {
    // è®¡ç®—å…¥å°„è§’ä½™å¼¦å€¼
    float cos_theta = std::max(0.0f, normal.dot(light_dir));

    // Lambert BRDF: $\frac{albedo}{\pi}$
    // æœ€ç»ˆé¢œè‰² = $BRDF \times å…¥å°„å…‰ \times \cos(\theta) \times \pi$ (ç§¯åˆ†å› å­)
    // ç®€åŒ–ä¸ºï¼š$albedo \times light\_color \times \cos(\theta)$
    return albedo * light_color * cos_theta;
}

// æ›´ä¸¥æ ¼çš„å®ç°ï¼ˆåŒ…å«$\pi$å› å­ï¼‰
Vector3f lambert_brdf_strict(const Vector3f& light_dir, const Vector3f& normal,
                            const Vector3f& light_color, const Vector3f& albedo) {
    float cos_theta = std::max(0.0f, normal.dot(light_dir));

    // ä¸¥æ ¼çš„Lambert BRDF
    Vector3f brdf = albedo / M_PI;

    // æ¸²æŸ“æ–¹ç¨‹çš„ç¦»æ•£å½¢å¼
    return brdf * light_color * cos_theta * M_PI;  // $\pi$æ¥è‡ªç«‹ä½“è§’ç§¯åˆ†
}
```

### 10.2.2 Phongåå°„æ¨¡å‹çš„æ•°å­¦æ¨å¯¼

#### Phongæ¨¡å‹çš„ä¸‰åˆ†é‡ç»“æ„

Phongæ¨¡å‹å°†å…‰ç…§åˆ†è§£ä¸ºä¸‰ä¸ªç‹¬ç«‹çš„åˆ†é‡ï¼š

**1. ç¯å¢ƒå…‰ï¼ˆAmbientï¼‰**ï¼š
$$I_a = k_a \cdot I_{ambient}$$
æ¨¡æ‹Ÿå¤æ‚çš„é—´æ¥å…‰ç…§ï¼Œæ˜¯ä¸€ä¸ªå¸¸æ•°é¡¹ã€‚

**2. æ¼«åå°„ï¼ˆDiffuseï¼‰**ï¼š
$$I_d = k_d \cdot I_{light} \cdot (\mathbf{N} \cdot \mathbf{L})$$
ä½¿ç”¨Lambertä½™å¼¦å®šå¾‹ã€‚

**3. é•œé¢åå°„ï¼ˆSpecularï¼‰**ï¼š
$$I_s = k_s \cdot I_{light} \cdot (\mathbf{R} \cdot \mathbf{V})^n$$
æ¨¡æ‹Ÿå…‰æ»‘è¡¨é¢çš„é•œé¢é«˜å…‰ã€‚

#### é•œé¢åå°„çš„æ•°å­¦æ¨å¯¼

**åå°„å‘é‡çš„è®¡ç®—**ï¼š
æ ¹æ®åå°„å®šå¾‹ï¼Œå…¥å°„å‘é‡ $\mathbf{L}$ å…³äºæ³•å‘é‡ $\mathbf{N}$ çš„åå°„å‘é‡ä¸ºï¼š
$$\mathbf{R} = 2(\mathbf{N} \cdot \mathbf{L})\mathbf{N} - \mathbf{L}$$

**æ¨å¯¼è¿‡ç¨‹**ï¼š
è®¾å…¥å°„å‘é‡ä¸º $\mathbf{L}$ï¼Œå°†å…¶åˆ†è§£ä¸ºæ³•å‘åˆ†é‡å’Œåˆ‡å‘åˆ†é‡ï¼š
$$\mathbf{L} = \mathbf{L}_{\parallel} + \mathbf{L}_{\perp}$$

å…¶ä¸­ï¼š

- $\mathbf{L}_{\parallel} = (\mathbf{L} \cdot \mathbf{N})\mathbf{N}$ï¼ˆæ³•å‘åˆ†é‡ï¼‰
- $\mathbf{L}_{\perp} = \mathbf{L} - \mathbf{L}_{\parallel}$ï¼ˆåˆ‡å‘åˆ†é‡ï¼‰

åå°„æ—¶ï¼Œåˆ‡å‘åˆ†é‡ä¸å˜ï¼Œæ³•å‘åˆ†é‡åå‘ï¼š
$$\mathbf{R} = \mathbf{L}_{\perp} - \mathbf{L}_{\parallel} = \mathbf{L} - 2\mathbf{L}_{\parallel} = \mathbf{L} - 2(\mathbf{L} \cdot \mathbf{N})\mathbf{N}$$

æ•´ç†å¾—ï¼š
$$\mathbf{R} = 2(\mathbf{N} \cdot \mathbf{L})\mathbf{N} - \mathbf{L}$$

#### å®Œæ•´çš„Phongå…‰ç…§æ–¹ç¨‹

$$I_{total} = k_a I_a + k_d I_l (\mathbf{N} \cdot \mathbf{L}) + k_s I_l (\mathbf{R} \cdot \mathbf{V})^n$$

å…¶ä¸­ï¼š

- $k_a, k_d, k_s$ï¼šæè´¨ç³»æ•°
- $n$ï¼šå…‰æ³½åº¦æŒ‡æ•°ï¼ˆshininessï¼‰
- $\mathbf{V}$ï¼šè§†çº¿æ–¹å‘å‘é‡

#### å·¥ç¨‹å®ç°

```cpp
Vector3f phong_lighting(const Vector3f& position, const Vector3f& normal,
                       const Vector3f& view_dir, const Vector3f& light_pos,
                       const Vector3f& light_color, const Material& material) {
    // ç¯å¢ƒå…‰åˆ†é‡
    Vector3f ambient = material.ambient * light_color;

    // è®¡ç®—å…‰çº¿æ–¹å‘
    Vector3f light_dir = (light_pos - position).normalized();

    // æ¼«åå°„åˆ†é‡ï¼ˆLambertï¼‰
    float diff = std::max(normal.dot(light_dir), 0.0f);
    Vector3f diffuse = material.diffuse * light_color * diff;

    // è®¡ç®—åå°„å‘é‡
    Vector3f reflect_dir = 2.0f * normal.dot(light_dir) * normal - light_dir;
    reflect_dir.normalize();

    // é•œé¢åå°„åˆ†é‡
    float spec = std::pow(std::max(view_dir.dot(reflect_dir), 0.0f), material.shininess);
    Vector3f specular = material.specular * light_color * spec;

    return ambient + diffuse + specular;
}
```

### 10.2.3 Blinn-Phongæ¨¡å‹çš„æ•°å­¦æ”¹è¿›

#### Blinn-Phongçš„ç†è®ºåŸºç¡€

**æ”¹è¿›åŠ¨æœº**ï¼š
Phongæ¨¡å‹åœ¨è®¡ç®—åå°„å‘é‡æ—¶å­˜åœ¨æ•ˆç‡å’Œç¨³å®šæ€§é—®é¢˜ï¼ŒBlinn-Phongé€šè¿‡å¼•å…¥åŠè§’å‘é‡æ¥è§£å†³è¿™äº›é—®é¢˜ã€‚

**åŠè§’å‘é‡çš„æ•°å­¦å®šä¹‰**ï¼š
$$\mathbf{H} = \frac{\mathbf{L} + \mathbf{V}}{\|\mathbf{L} + \mathbf{V}\|}$$

å…¶ä¸­ $\mathbf{L}$ æ˜¯å…‰çº¿æ–¹å‘ï¼Œ$\mathbf{V}$ æ˜¯è§†çº¿æ–¹å‘ã€‚

#### å‡ ä½•æ„ä¹‰ä¸ç‰©ç†è§£é‡Š

**å‡ ä½•æ„ä¹‰**ï¼š
$\mathbf{H}$ æ˜¯å…‰çº¿æ–¹å‘å’Œè§†çº¿æ–¹å‘çš„è§’å¹³åˆ†çº¿ï¼Œè¡¨ç¤ºèƒ½å¤Ÿäº§ç”Ÿé•œé¢åå°„çš„ç†æƒ³å¾®è¡¨é¢æ³•å‘é‡ã€‚

**ç‰©ç†è§£é‡Š**ï¼š
åœ¨å¾®è¡¨é¢ç†è®ºä¸­ï¼Œåªæœ‰æ³•å‘é‡ä¸åŠè§’å‘é‡å¹³è¡Œçš„å¾®è¡¨é¢æ‰ä¼šå°†å…‰çº¿ä» $\mathbf{L}$ æ–¹å‘åå°„åˆ° $\mathbf{V}$ æ–¹å‘ã€‚

#### Blinn-Phongé•œé¢åå°„å…¬å¼

**ä¿®æ”¹åçš„é•œé¢åå°„é¡¹**ï¼š
$$I_s = k_s I_l (\mathbf{N} \cdot \mathbf{H})^{n'}$$

**æŒ‡æ•°å…³ç³»**ï¼š
ä¸ºäº†è·å¾—ä¸Phongæ¨¡å‹ç›¸ä¼¼çš„è§†è§‰æ•ˆæœï¼Œé€šå¸¸éœ€è¦è°ƒæ•´å…‰æ³½åº¦æŒ‡æ•°ï¼š
$$n' \approx 4n_{phong}$$

#### æ•°å­¦ä¼˜åŠ¿åˆ†æ

**1. è®¡ç®—æ•ˆç‡**ï¼š

- **Phong**ï¼š$\mathbf{R} = 2(\mathbf{N} \cdot \mathbf{L})\mathbf{N} - \mathbf{L}$ ï¼ˆ6æ¬¡ä¹˜æ³•ï¼Œ3æ¬¡å‡æ³•ï¼‰
- **Blinn-Phong**ï¼š$\mathbf{H} = \frac{\mathbf{L} + \mathbf{V}}{\|\mathbf{L} + \mathbf{V}\|}$ ï¼ˆ3æ¬¡åŠ æ³•ï¼Œ1æ¬¡å½’ä¸€åŒ–ï¼‰

**2. æ•°å€¼ç¨³å®šæ€§**ï¼š
é¿å…äº†åå°„å‘é‡åœ¨æ å°„è§’é™„è¿‘çš„æ•°å€¼ä¸ç¨³å®šé—®é¢˜ã€‚

**3. ç‰©ç†åˆç†æ€§**ï¼š
æ›´å¥½åœ°ç¬¦åˆå¾®è¡¨é¢ç†è®ºçš„ç‰©ç†åŸºç¡€ã€‚

**ä»£ç å®ç°**ï¼š

```cpp
Vector3f blinn_phong_specular(const Vector3f& light_dir, const Vector3f& view_dir,
                             const Vector3f& normal, const Vector3f& light_color,
                             const Vector3f& specular_color, float shininess) {
    Vector3f half_dir = (light_dir + view_dir).normalized();
    float spec = std::pow(std::max(normal.dot(half_dir), 0.0f), shininess);
    return specular_color * light_color * spec;
}
```

## 10.3 ç€è‰²æŠ€æœ¯

### 10.3.1 å¹³é¢ç€è‰²ï¼ˆFlat Shadingï¼‰

**åŸç†**ï¼šæ¯ä¸ªä¸‰è§’å½¢ä½¿ç”¨å•ä¸€é¢œè‰²

**æ³•å‘é‡è®¡ç®—**ï¼š

```cpp
Vector3f calculate_face_normal(const Vector3f& v1, const Vector3f& v2, const Vector3f& v3) {
    Vector3f edge1 = v2 - v1;
    Vector3f edge2 = v3 - v1;
    return edge1.cross(edge2).normalized();
}
```

**ç‰¹ç‚¹**ï¼š

- è®¡ç®—ç®€å•
- å¤šé¢ä½“å¤–è§‚æ˜æ˜¾
- é€‚åˆä½å¤šè¾¹å½¢é£æ ¼

### 10.3.2 Gouraudç€è‰²

**åŸç†**ï¼šåœ¨é¡¶ç‚¹è®¡ç®—å…‰ç…§ï¼Œä¸‰è§’å½¢å†…éƒ¨æ’å€¼

**ç®—æ³•æ­¥éª¤**ï¼š

1. è®¡ç®—é¡¶ç‚¹æ³•å‘é‡ï¼ˆç›¸é‚»é¢æ³•å‘é‡å¹³å‡ï¼‰
2. åœ¨é¡¶ç‚¹è¿›è¡Œå…‰ç…§è®¡ç®—
3. åœ¨ä¸‰è§’å½¢å†…éƒ¨æ’å€¼é¢œè‰²

**é¡¶ç‚¹æ³•å‘é‡è®¡ç®—**ï¼š

```cpp
void calculate_vertex_normals(Mesh& mesh) {
    // åˆå§‹åŒ–é¡¶ç‚¹æ³•å‘é‡ä¸ºé›¶
    for (auto& vertex : mesh.vertices) {
        vertex.normal = Vector3f::Zero();
    }

    // ç´¯åŠ ç›¸é‚»é¢çš„æ³•å‘é‡
    for (const auto& face : mesh.faces) {
        Vector3f face_normal = calculate_face_normal(
            mesh.vertices[face.v1].position,
            mesh.vertices[face.v2].position,
            mesh.vertices[face.v3].position
        );

        mesh.vertices[face.v1].normal += face_normal;
        mesh.vertices[face.v2].normal += face_normal;
        mesh.vertices[face.v3].normal += face_normal;
    }

    // å½’ä¸€åŒ–
    for (auto& vertex : mesh.vertices) {
        vertex.normal.normalize();
    }
}
```

### 10.3.3 Phongç€è‰²

**åŸç†**ï¼šæ’å€¼æ³•å‘é‡ï¼Œåœ¨æ¯ä¸ªåƒç´ è¿›è¡Œå…‰ç…§è®¡ç®—

**ç®—æ³•æ­¥éª¤**ï¼š

1. åœ¨é¡¶ç‚¹å­˜å‚¨æ³•å‘é‡
2. åœ¨ä¸‰è§’å½¢å†…éƒ¨æ’å€¼æ³•å‘é‡
3. åœ¨æ¯ä¸ªåƒç´ è¿›è¡Œå…‰ç…§è®¡ç®—

**æ³•å‘é‡æ’å€¼**ï¼š

```cpp
Vector3f interpolate_normal(const Vector3f& bary,
                           const Vector3f& n1, const Vector3f& n2, const Vector3f& n3) {
    Vector3f interpolated = bary.x() * n1 + bary.y() * n2 + bary.z() * n3;
    return interpolated.normalized();
}
```

**è´¨é‡å¯¹æ¯”**ï¼š

- **Flat** < **Gouraud** < **Phong**ï¼ˆè´¨é‡é€’å¢ï¼‰
- **Flat** > **Gouraud** > **Phong**ï¼ˆæ€§èƒ½é€’å‡ï¼‰

---

## çº¹ç†æ˜ å°„æŠ€æœ¯

## 11.1 çº¹ç†æ˜ å°„åŸºç¡€ç†è®º

### 11.1.1 çº¹ç†åæ ‡ç³»ç»Ÿçš„æ•°å­¦åŸºç¡€

#### UVåæ ‡ç³»çš„å®šä¹‰

**æ ‡å‡†åŒ–çº¹ç†åæ ‡**ï¼š
çº¹ç†åæ ‡ $(u, v)$ å®šä¹‰åœ¨å•ä½æ­£æ–¹å½¢å†…ï¼š
$$(u, v) \in [0, 1] \times [0, 1]$$

å…¶ä¸­ï¼š

- $u$ è½´ï¼šæ°´å¹³æ–¹å‘ï¼Œå¯¹åº”çº¹ç†çš„å®½åº¦
- $v$ è½´ï¼šå‚ç›´æ–¹å‘ï¼Œå¯¹åº”çº¹ç†çš„é«˜åº¦

#### åæ ‡å˜æ¢

**çº¹ç†åæ ‡åˆ°åƒç´ åæ ‡çš„æ˜ å°„**ï¼š

æœ€è¿‘é‚»é‡‡æ ·çš„åƒç´ åæ ‡ï¼š
$$x_{pixel} = \lfloor u \cdot (W - 1) \rfloor$$
$$y_{pixel} = \lfloor v \cdot (H - 1) \rfloor$$

å…¶ä¸­ $W$ å’Œ $H$ åˆ†åˆ«æ˜¯çº¹ç†çš„å®½åº¦å’Œé«˜åº¦ï¼ˆä»¥åƒç´ ä¸ºå•ä½ï¼‰ã€‚

**è¿ç»­åæ ‡æ˜ å°„**ï¼š
å¯¹äºéœ€è¦æ’å€¼çš„æƒ…å†µï¼š

è¿ç»­åæ ‡è®¡ç®—ï¼š
$$x_{continuous} = u \cdot W - 0.5$$
$$y_{continuous} = v \cdot H - 0.5$$

å‡å»0.5æ˜¯ä¸ºäº†å°†é‡‡æ ·ç‚¹æ”¾åœ¨åƒç´ ä¸­å¿ƒã€‚

#### å·¥ç¨‹å®ç°

```cpp
struct TextureCoordinate {
    float u, v;

    // è½¬æ¢ä¸ºåƒç´ åæ ‡ï¼ˆæ•´æ•°ï¼‰
    std::pair<int, int> to_pixel_coords(int width, int height) const {
        int x = static_cast<int>(u * (width - 1));
        int y = static_cast<int>(v * (height - 1));
        return {x, y};
    }

    // è½¬æ¢ä¸ºè¿ç»­åƒç´ åæ ‡ï¼ˆç”¨äºæ’å€¼ï¼‰
    std::pair<float, float> to_continuous_coords(int width, int height) const {
        float x = u * width - 0.5f;
        float y = v * height - 0.5f;
        return {x, y};
    }
};
```

### 11.1.2 çº¹ç†é‡‡æ ·ç†è®º

#### ç‚¹é‡‡æ ·ï¼ˆæœ€è¿‘é‚»é‡‡æ ·ï¼‰

**æ•°å­¦å®šä¹‰**ï¼š
ç‚¹é‡‡æ ·é€‰æ‹©è·ç¦»é‡‡æ ·ç‚¹æœ€è¿‘çš„çº¹ç†åƒç´ ï¼š
$$T_{nearest}(u, v) = T\left(\left\lfloor u \cdot W + 0.5 \right\rfloor, \left\lfloor v \cdot H + 0.5 \right\rfloor\right)$$

å…¶ä¸­ $T(i, j)$ è¡¨ç¤ºçº¹ç†åœ¨åƒç´  $(i, j)$ å¤„çš„é¢œè‰²å€¼ã€‚

#### åŒçº¿æ€§è¿‡æ»¤çš„æ•°å­¦æ¨å¯¼

**é—®é¢˜è®¾å®š**ï¼š
ç»™å®šè¿ç»­çº¹ç†åæ ‡ $(u, v)$ï¼Œè®¡ç®—å¯¹åº”çš„çº¹ç†å€¼ã€‚

**åæ ‡å˜æ¢**ï¼š

è¿ç»­åæ ‡è®¡ç®—ï¼š
$$x = u \cdot W - 0.5$$
$$y = v \cdot H - 0.5$$

**å››ä¸ªé‚»è¿‘åƒç´ **ï¼š

åƒç´ åæ ‡å®šä¹‰ï¼š
$$(x_0, y_0) = (\lfloor x \rfloor, \lfloor y \rfloor)$$
$$(x_1, y_0) = (x_0 + 1, y_0)$$
$$(x_0, y_1) = (x_0, y_0 + 1)$$
$$(x_1, y_1) = (x_0 + 1, y_0 + 1)$$

**æ’å€¼æƒé‡**ï¼š

æƒé‡è®¡ç®—ï¼š
$$f_x = x - x_0$$
$$f_y = y - y_0$$

**åŒçº¿æ€§æ’å€¼å…¬å¼**ï¼š

åˆ†æ­¥è®¡ç®—ï¼š
$$T_{bilinear}(u, v) = [1-f_y]((1-f_x)T_{00} + f_x T_{10}) + f_y[(1-f_x)T_{01} + f_x T_{11}]$$

å±•å¼€å½¢å¼ï¼š
$$T_{bilinear}(u, v) = (1-f_x)(1-f_y)T_{00} + f_x(1-f_y)T_{10} + (1-f_x)f_y T_{01} + f_x f_y T_{11}$$

å…¶ä¸­ $T_{ij}$ è¡¨ç¤ºåƒç´  $(x_i, y_j)$ çš„é¢œè‰²å€¼ã€‚

**å‡ ä½•è§£é‡Š**ï¼š
åŒçº¿æ€§æ’å€¼ç­‰ä»·äºå…ˆåœ¨xæ–¹å‘è¿›è¡Œä¸¤æ¬¡çº¿æ€§æ’å€¼ï¼Œå†åœ¨yæ–¹å‘è¿›è¡Œä¸€æ¬¡çº¿æ€§æ’å€¼ï¼š

**åˆ†æ­¥æ’å€¼è¿‡ç¨‹**ï¼š

xæ–¹å‘æ’å€¼ï¼š
$$C_0 = (1-f_x)T_{00} + f_x T_{10}$$
$$C_1 = (1-f_x)T_{01} + f_x T_{11}$$

yæ–¹å‘æ’å€¼ï¼š
$$T_{bilinear} = (1-f_y)C_0 + f_y C_1$$

#### å·¥ç¨‹å®ç°

```cpp
class TextureSampler {
public:
    static Color sample_nearest(const Texture& texture, float u, float v) {
        int x = static_cast<int>(u * texture.width + 0.5f) % texture.width;
        int y = static_cast<int>(v * texture.height + 0.5f) % texture.height;
        return texture.get_pixel(x, y);
    }

    static Color sample_bilinear(const Texture& texture, float u, float v) {
        float x = u * texture.width - 0.5f;
        float y = v * texture.height - 0.5f;

        int x0 = static_cast<int>(std::floor(x));
        int y0 = static_cast<int>(std::floor(y));
        int x1 = x0 + 1;
        int y1 = y0 + 1;

        float fx = x - x0;
        float fy = y - y0;

        // è·å–å››ä¸ªé‚»è¿‘åƒç´ ï¼ˆå¸¦è¾¹ç•Œå¤„ç†ï¼‰
        Color c00 = texture.get_pixel_wrap(x0, y0);
        Color c10 = texture.get_pixel_wrap(x1, y0);
        Color c01 = texture.get_pixel_wrap(x0, y1);
        Color c11 = texture.get_pixel_wrap(x1, y1);

        // åŒçº¿æ€§æ’å€¼
        Color c0 = lerp(c00, c10, fx);
        Color c1 = lerp(c01, c11, fx);
        return lerp(c0, c1, fy);
    }

private:
    static Color lerp(const Color& a, const Color& b, float t) {
        return a * (1.0f - t) + b * t;
    }
};
```

### 11.1.3 çº¹ç†å¯»å€æ¨¡å¼çš„æ•°å­¦å®šä¹‰

#### é‡å¤æ¨¡å¼ï¼ˆRepeat/Wrapï¼‰

**æ•°å­¦å®šä¹‰**ï¼š
$$u_{repeat} = u - \lfloor u \rfloor = u \bmod 1$$

**æ€§è´¨**ï¼š

- å‘¨æœŸæ€§ï¼š$u_{repeat}(u + k) = u_{repeat}(u)$ å¯¹ä»»æ„æ•´æ•° $k$
- å€¼åŸŸï¼š$u_{repeat} \in [0, 1)$

#### é•œåƒæ¨¡å¼ï¼ˆMirror/Reflectï¼‰

**æ•°å­¦å®šä¹‰**ï¼š

é•œåƒæ˜ å°„å‡½æ•°ï¼š

å½“ $t \leq 0.5$ æ—¶ï¼š$u_{mirror} = 2t$

å½“ $t > 0.5$ æ—¶ï¼š$u_{mirror} = 2(1-t)$

å…¶ä¸­ $t = (u/2) \bmod 1$ã€‚

**ç­‰ä»·è¡¨ç¤º**ï¼š
$$u_{mirror} = 1 - \left|2 \cdot \left(\frac{u}{2} - \left\lfloor \frac{u}{2} + 0.5 \right\rfloor\right)\right|$$

#### è¾¹ç¼˜æ‹‰ä¼¸æ¨¡å¼ï¼ˆClamp to Edgeï¼‰

**æ•°å­¦å®šä¹‰**ï¼š
$$u_{clamp} = \max(0, \min(1, u))$$

**åˆ†æ®µå‡½æ•°è¡¨ç¤º**ï¼š

é’³åˆ¶æ˜ å°„å‡½æ•°ï¼š

å½“ $u < 0$ æ—¶ï¼š$u_{clamp} = 0$

å½“ $0 \leq u \leq 1$ æ—¶ï¼š$u_{clamp} = u$

å½“ $u > 1$ æ—¶ï¼š$u_{clamp} = 1$

#### è¾¹ç•Œé¢œè‰²æ¨¡å¼ï¼ˆBorder Colorï¼‰

**æ•°å­¦å®šä¹‰**ï¼š

è¾¹ç•Œçº¹ç†æ˜ å°„å‡½æ•°ï¼š

å½“ $(u, v) \in [0, 1]^2$ æ—¶ï¼š$T_{border}(u, v) = T(u, v)$

å…¶ä»–æƒ…å†µï¼š$T_{border}(u, v) = C_{border}$

å…¶ä¸­ $C_{border}$ æ˜¯é¢„å®šä¹‰çš„è¾¹ç•Œé¢œè‰²ã€‚

#### å·¥ç¨‹å®ç°

```cpp
enum class WrapMode {
    REPEAT,
    MIRROR,
    CLAMP,
    BORDER
};

class TextureAddressing {
public:
    static float apply_wrap_mode(float coord, WrapMode mode) {
        switch (mode) {
            case WrapMode::REPEAT:
                return coord - std::floor(coord);

            case WrapMode::MIRROR: {
                float t = (coord * 0.5f) - std::floor(coord * 0.5f);
                return (t <= 0.5f) ? (2.0f * t) : (2.0f * (1.0f - t));
            }

            case WrapMode::CLAMP:
                return std::max(0.0f, std::min(1.0f, coord));

            case WrapMode::BORDER:
                return coord;  // è¾¹ç•Œæ£€æŸ¥åœ¨é‡‡æ ·æ—¶å¤„ç†

            default:
                return coord;
        }
    }

    static std::pair<float, float> apply_wrap_mode_2d(float u, float v,
                                                     WrapMode u_mode, WrapMode v_mode) {
        return {apply_wrap_mode(u, u_mode), apply_wrap_mode(v, v_mode)};
    }
};
```

## 11.2 é«˜çº§çº¹ç†æŠ€æœ¯

### 11.2.1 MipmapæŠ€æœ¯è¯¦è§£

**Mipmapç”Ÿæˆç®—æ³•**ï¼š

```cpp
void generate_mipmaps(Texture& texture) {
    int width = texture.width;
    int height = texture.height;
    int level = 0;

    while (width > 1 || height > 1) {
        int new_width = std::max(1, width / 2);
        int new_height = std::max(1, height / 2);

        Texture mip_level(new_width, new_height);

        for (int y = 0; y < new_height; ++y) {
            for (int x = 0; x < new_width; ++x) {
                // 2x2åƒç´ åŒºåŸŸå¹³å‡
                Color sum(0, 0, 0, 0);
                int count = 0;

                for (int dy = 0; dy < 2; ++dy) {
                    for (int dx = 0; dx < 2; ++dx) {
                        int src_x = x * 2 + dx;
                        int src_y = y * 2 + dy;

                        if (src_x < width && src_y < height) {
                            sum += texture.get_pixel(src_x, src_y);
                            count++;
                        }
                    }
                }

                mip_level.set_pixel(x, y, sum / count);
            }
        }

        texture.mip_levels[++level] = mip_level;
        width = new_width;
        height = new_height;
    }
}
```

**Mipmapçº§åˆ«è®¡ç®—**ï¼š

```cpp
float calculate_mipmap_level(const Vector2f& duv_dx, const Vector2f& duv_dy,
                            int texture_width, int texture_height) {
    float du_dx = duv_dx.x() * texture_width;
    float dv_dx = duv_dx.y() * texture_height;
    float du_dy = duv_dy.x() * texture_width;
    float dv_dy = duv_dy.y() * texture_height;

    float max_sqr = std::max(du_dx * du_dx + dv_dx * dv_dx,
                            du_dy * du_dy + dv_dy * dv_dy);

    return 0.5f * std::log2(max_sqr);
}
```

### 11.2.2 æ³•çº¿è´´å›¾ï¼ˆNormal Mappingï¼‰

**åˆ‡çº¿ç©ºé—´æ³•å‘é‡**ï¼š

```cpp
Vector3f sample_normal_map(const Texture& normal_map, float u, float v) {
    Color normal_color = sample_bilinear(normal_map, u, v);

    // ä»[0,1]æ˜ å°„åˆ°[-1,1]
    Vector3f normal;
    normal.x() = normal_color.r * 2.0f - 1.0f;
    normal.y() = normal_color.g * 2.0f - 1.0f;
    normal.z() = normal_color.b * 2.0f - 1.0f;

    return normal.normalized();
}
```

**TBNçŸ©é˜µæ„å»º**ï¼š

```cpp
Matrix3f build_tbn_matrix(const Vector3f& normal, const Vector3f& tangent) {
    Vector3f N = normal.normalized();
    Vector3f T = tangent.normalized();

    // Gram-Schmidtæ­£äº¤åŒ–
    T = (T - N.dot(T) * N).normalized();
    Vector3f B = N.cross(T);

    Matrix3f TBN;
    TBN.col(0) = T;  // Tangent
    TBN.col(1) = B;  // Bitangent
    TBN.col(2) = N;  // Normal

    return TBN;
}
```

**åˆ‡çº¿ç©ºé—´åˆ°ä¸–ç•Œç©ºé—´å˜æ¢**ï¼š

```cpp
Vector3f transform_normal(const Vector3f& tangent_normal, const Matrix3f& TBN) {
    return (TBN * tangent_normal).normalized();
}
```

### 11.2.3 ç¯å¢ƒæ˜ å°„

**çƒé¢æ˜ å°„**ï¼š

```cpp
Vector2f sphere_mapping(const Vector3f& direction) {
    Vector3f d = direction.normalized();
    float u = 0.5f + std::atan2(d.z(), d.x()) / (2.0f * M_PI);
    float v = 0.5f - std::asin(d.y()) / M_PI;
    return Vector2f(u, v);
}
```

**ç«‹æ–¹ä½“æ˜ å°„**ï¼š

```cpp
struct CubemapSample {
    int face;
    Vector2f uv;
};

CubemapSample cube_mapping(const Vector3f& direction) {
    Vector3f abs_dir = direction.cwiseAbs();
    CubemapSample sample;

    if (abs_dir.x() >= abs_dir.y() && abs_dir.x() >= abs_dir.z()) {
        // Xé¢
        sample.face = direction.x() > 0 ? 0 : 1;  // +X : -X
        sample.uv.x() = direction.x() > 0 ? -direction.z() : direction.z();
        sample.uv.y() = -direction.y();
        sample.uv /= abs_dir.x();
    } else if (abs_dir.y() >= abs_dir.z()) {
        // Yé¢
        sample.face = direction.y() > 0 ? 2 : 3;  // +Y : -Y
        sample.uv.x() = direction.x();
        sample.uv.y() = direction.y() > 0 ? direction.z() : -direction.z();
        sample.uv /= abs_dir.y();
    } else {
        // Zé¢
        sample.face = direction.z() > 0 ? 4 : 5;  // +Z : -Z
        sample.uv.x() = direction.z() > 0 ? direction.x() : -direction.x();
        sample.uv.y() = -direction.y();
        sample.uv /= abs_dir.z();
    }

    // è½¬æ¢åˆ°[0,1]èŒƒå›´
    sample.uv = (sample.uv + Vector2f(1, 1)) * 0.5f;
    return sample;
}
```

---

## å‚æ•°æ›²çº¿ç†è®º

## 12.1 å‚æ•°æ›²çº¿çš„æ•°å­¦åŸºç¡€

### 12.1.1 å‚æ•°è¡¨ç¤ºçš„æ•°å­¦ä¼˜åŠ¿

#### å‚æ•°æ›²çº¿çš„ä¸€èˆ¬å½¢å¼

**ä¸‰ç»´å‚æ•°æ›²çº¿**ï¼š
$$\mathbf{C}(t) = \begin{pmatrix} x(t) \\ y(t) \\ z(t) \end{pmatrix}, \quad t \in [a, b]$$

å…¶ä¸­ $x(t)$ã€$y(t)$ã€$z(t)$ æ˜¯å…³äºå‚æ•° $t$ çš„è¿ç»­å¯å¾®å‡½æ•°ã€‚

#### å‚æ•°è¡¨ç¤ºç›¸æ¯”éšå¼è¡¨ç¤ºçš„ä¼˜åŠ¿

**1. è®¡ç®—ä¾¿åˆ©æ€§**ï¼š

- **å‚æ•°å½¢å¼**ï¼šç›´æ¥ä»£å…¥å‚æ•°å€¼å³å¯å¾—åˆ°æ›²çº¿ä¸Šçš„ç‚¹
- **éšå¼å½¢å¼**ï¼š$F(x,y,z) = 0$ éœ€è¦æ±‚è§£æ–¹ç¨‹

**2. åŠ¨ç”»æ”¯æŒ**ï¼š
å‚æ•° $t$ å¯ä»¥ç›´æ¥ä½œä¸ºæ—¶é—´å‚æ•°ï¼Œè‡ªç„¶æ”¯æŒåŠ¨ç”»ï¼š
$$\mathbf{position}(t) = \mathbf{C}(t), \quad \mathbf{velocity}(t) = \mathbf{C}'(t)$$

**3. å¤šå€¼å‡½æ•°å¤„ç†**ï¼š
é¿å…äº† $y = f(x)$ å½¢å¼æ— æ³•è¡¨ç¤ºå‚ç›´çº¿å’Œé—­åˆæ›²çº¿çš„é—®é¢˜ã€‚

**4. å¾®åˆ†å‡ ä½•è®¡ç®—**ï¼š
åˆ‡å‘é‡ã€æ³•å‘é‡ã€æ›²ç‡ç­‰å‡ ä½•é‡çš„è®¡ç®—æ›´åŠ ç›´æ¥ã€‚

### 12.1.2 æ›²çº¿çš„å¾®åˆ†å‡ ä½•æ€§è´¨

#### åˆ‡å‘é‡ä¸é€Ÿåº¦

**åˆ‡å‘é‡ï¼ˆé€Ÿåº¦å‘é‡ï¼‰**ï¼š
$$\mathbf{T}(t) = \mathbf{C}'(t) = \begin{pmatrix} x'(t) \\ y'(t) \\ z'(t) \end{pmatrix}$$

**å•ä½åˆ‡å‘é‡**ï¼š
$$\hat{\mathbf{T}}(t) = \frac{\mathbf{T}(t)}{\|\mathbf{T}(t)\|} = \frac{\mathbf{C}'(t)}{\|\mathbf{C}'(t)\|}$$

#### æ›²ç‡çš„æ•°å­¦å®šä¹‰

**æ›²ç‡çš„å‡ ä½•å®šä¹‰**ï¼š
æ›²ç‡ $\kappa(t)$ æè¿°æ›²çº¿åœ¨æŸç‚¹å¤„åç¦»ç›´çº¿çš„ç¨‹åº¦ï¼š
$$\kappa(t) = \frac{\|\mathbf{T}'(t)\|}{\|\mathbf{C}'(t)\|} = \frac{\|\mathbf{C}'(t) \times \mathbf{C}''(t)\|}{\|\mathbf{C}'(t)\|^3}$$

**å¹³é¢æ›²çº¿çš„æ›²ç‡å…¬å¼**ï¼š
å¯¹äºå¹³é¢æ›²çº¿ $\mathbf{C}(t) = (x(t), y(t))$ï¼š
$$\kappa(t) = \frac{|x'(t)y''(t) - y'(t)x''(t)|}{(x'(t)^2 + y'(t)^2)^{3/2}}$$

#### å¼§é•¿å‚æ•°åŒ–

**å¼§é•¿å‡½æ•°**ï¼š
$$s(t) = \int_a^t \|\mathbf{C}'(\tau)\| d\tau$$

**å¼§é•¿å‚æ•°åŒ–çš„ä¼˜åŠ¿**ï¼š
å½“æ›²çº¿ä»¥å¼§é•¿ä¸ºå‚æ•°æ—¶ï¼Œ$\|\mathbf{C}'(s)\| = 1$ï¼Œç®€åŒ–äº†å‡ ä½•è®¡ç®—ï¼š
$$\kappa(s) = \|\mathbf{C}''(s)\|$$

**ä»£ç å®ç°**ï¼š

```cpp
float calculate_curvature_2d(float t,
                            std::function<Vector2f(float)> curve,
                            std::function<Vector2f(float)> first_derivative,
                            std::function<Vector2f(float)> second_derivative) {
    Vector2f first = first_derivative(t);
    Vector2f second = second_derivative(t);

    float numerator = std::abs(first.x() * second.y() - first.y() * second.x());
    float denominator = std::pow(first.squaredNorm(), 1.5f);

    return numerator / denominator;
}
```

## 12.2 å¸¸è§å‚æ•°æ›²çº¿çš„æ•°å­¦åˆ†æ

### 12.2.1 ç›´çº¿çš„å‚æ•°è¡¨ç¤º

#### çº¿æ€§æ’å€¼çš„æ•°å­¦å½¢å¼

**ä¸¤ç‚¹é—´ç›´çº¿çš„å‚æ•°æ–¹ç¨‹**ï¼š
$$\mathbf{L}(t) = \mathbf{P}_0 + t(\mathbf{P}_1 - \mathbf{P}_0) = (1-t)\mathbf{P}_0 + t\mathbf{P}_1, \quad t \in [0, 1]$$

**å‡ ä½•æ„ä¹‰**ï¼š

- $t = 0$ï¼šä½äºç‚¹ $\mathbf{P}_0$
- $t = 1$ï¼šä½äºç‚¹ $\mathbf{P}_1$
- $0 < t < 1$ï¼šä½äºçº¿æ®µ $\mathbf{P}_0\mathbf{P}_1$ å†…éƒ¨

**å¾®åˆ†æ€§è´¨**ï¼š

- **åˆ‡å‘é‡**ï¼š$\mathbf{L}'(t) = \mathbf{P}_1 - \mathbf{P}_0$ï¼ˆå¸¸å‘é‡ï¼‰
- **æ›²ç‡**ï¼š$\kappa(t) = 0$ï¼ˆç›´çº¿æ›²ç‡ä¸ºé›¶ï¼‰

#### å·¥ç¨‹å®ç°

```cpp
class ParametricLine {
private:
    Vector3f p0, p1;

public:
    ParametricLine(const Vector3f& start, const Vector3f& end) : p0(start), p1(end) {}

    Vector3f evaluate(float t) const {
        return (1.0f - t) * p0 + t * p1;
    }

    Vector3f tangent() const {
        return (p1 - p0).normalized();
    }

    float length() const {
        return (p1 - p0).norm();
    }
};
```

### 12.2.2 åœ†ä¸æ¤­åœ†çš„å‚æ•°è¡¨ç¤º

#### åœ†çš„å‚æ•°æ–¹ç¨‹

**æ ‡å‡†åœ†çš„å‚æ•°å½¢å¼**ï¼š
$$\mathbf{C}(t) = \mathbf{center} + r\begin{pmatrix} \cos(t) \\ \sin(t) \end{pmatrix}, \quad t \in [0, 2\pi]$$

**å¾®åˆ†æ€§è´¨**ï¼š

- **åˆ‡å‘é‡**ï¼š$\mathbf{C}'(t) = r\begin{pmatrix} -\sin(t) \\ \cos(t) \end{pmatrix}$
- **é€Ÿåº¦å¤§å°**ï¼š$\|\mathbf{C}'(t)\| = r$
- **æ›²ç‡**ï¼š$\kappa = \frac{1}{r}$ï¼ˆå¸¸æ›²ç‡ï¼‰

#### æ¤­åœ†çš„å‚æ•°æ–¹ç¨‹

**æ ‡å‡†æ¤­åœ†**ï¼š
$$\mathbf{E}(t) = \mathbf{center} + \begin{pmatrix} a\cos(t) \\ b\sin(t) \end{pmatrix}, \quad t \in [0, 2\pi]$$

å…¶ä¸­ $a$ å’Œ $b$ åˆ†åˆ«æ˜¯é•¿è½´å’ŒçŸ­è½´çš„åŠé•¿åº¦ã€‚

**æ¤­åœ†çš„æ›²ç‡**ï¼š
$$\kappa(t) = \frac{ab}{(a^2\sin^2(t) + b^2\cos^2(t))^{3/2}}$$

**ç‰¹æ®Šç‚¹çš„æ›²ç‡**ï¼š

- é•¿è½´ç«¯ç‚¹ï¼š$\kappa = \frac{b^2}{a^3}$
- çŸ­è½´ç«¯ç‚¹ï¼š$\kappa = \frac{a^2}{b^3}$

#### ä¸‰ç»´ç©ºé—´ä¸­çš„åœ†

**ä»»æ„å¹³é¢ä¸Šçš„åœ†**ï¼š
$$\mathbf{C}(t) = \mathbf{center} + r(\cos(t)\mathbf{u} + \sin(t)\mathbf{v})$$

å…¶ä¸­ $\mathbf{u}$ å’Œ $\mathbf{v}$ æ˜¯åœ†æ‰€åœ¨å¹³é¢çš„ä¸¤ä¸ªæ­£äº¤å•ä½å‘é‡ã€‚

### 12.2.3 èºæ—‹çº¿

**å¹³é¢èºæ—‹ï¼ˆé˜¿åŸºç±³å¾·èºçº¿ï¼‰**ï¼š
$$\mathbf{S}(t) = (at\cos(t), at\sin(t)), \quad t \in [0, n \cdot 2\pi]$$

**ç©ºé—´èºæ—‹**ï¼š
$$\mathbf{S}(t) = (a\cos(t), a\sin(t), bt), \quad t \in [0, n \cdot 2\pi]$$

---

## è´å¡å°”æ›²çº¿æ·±åº¦è§£æ

## 13.1 è´å¡å°”æ›²çº¿çš„æ•°å­¦åŸç†

### 13.1.1 ä¼¯æ©æ–¯å¦å¤šé¡¹å¼çš„æ·±åº¦ç†è®º

#### ä¼¯æ©æ–¯å¦å¤šé¡¹å¼çš„æ•°å­¦å®šä¹‰

**ä¸¥æ ¼å®šä¹‰**ï¼š
$n$ æ¬¡ä¼¯æ©æ–¯å¦åŸºå‡½æ•°å®šä¹‰ä¸ºï¼š
$$B_i^n(t) = \binom{n}{i} t^i (1-t)^{n-i}, \quad i = 0, 1, \ldots, n$$

å…¶ä¸­äºŒé¡¹å¼ç³»æ•°ï¼š
$$\binom{n}{i} = \frac{n!}{i!(n-i)!}$$

#### åŸºæœ¬æ€§è´¨çš„æ•°å­¦è¯æ˜

**1. éè´Ÿæ€§**ï¼š$B_i^n(t) \geq 0$ å¯¹æ‰€æœ‰ $t \in [0,1]$

- **è¯æ˜**ï¼š$\binom{n}{i} \geq 0$ï¼Œ$t^i \geq 0$ï¼Œ$(1-t)^{n-i} \geq 0$

**2. å½’ä¸€æ€§ï¼ˆæƒé‡å’Œä¸º1ï¼‰**ï¼š$\sum_{i=0}^{n} B_i^n(t) = 1$

- **è¯æ˜**ï¼šåˆ©ç”¨äºŒé¡¹å¼å®šç†
$$\sum_{i=0}^{n} B_i^n(t) = \sum_{i=0}^{n} \binom{n}{i} t^i (1-t)^{n-i} = (t + (1-t))^n = 1$$

**3. å¯¹ç§°æ€§**ï¼š$B_i^n(t) = B_{n-i}^n(1-t)$

- **è¯æ˜**ï¼š
$$B_{n-i}^n(1-t) = \binom{n}{n-i} (1-t)^{n-i} t^i = \binom{n}{i} t^i (1-t)^{n-i} = B_i^n(t)$$

**4. ç«¯ç‚¹æ€§è´¨**ï¼š

- $B_i^n(0) = \delta_{i0}$ï¼ˆKronecker deltaï¼‰
- $B_i^n(1) = \delta_{in}$

**5. é€’æ¨å…³ç³»**ï¼š
$$B_i^n(t) = (1-t)B_i^{n-1}(t) + tB_{i-1}^{n-1}(t)$$

è¿™ä¸ªé€’æ¨å…³ç³»æ˜¯de Casteljauç®—æ³•çš„æ•°å­¦åŸºç¡€ã€‚

#### ä¼¯æ©æ–¯å¦å¤šé¡¹å¼çš„å‡ ä½•æ„ä¹‰

**æ¦‚ç‡è§£é‡Š**ï¼š
$B_i^n(t)$ å¯ä»¥è§£é‡Šä¸ºåœ¨ $n$ æ¬¡ç‹¬ç«‹ä¼¯åŠªåˆ©è¯•éªŒä¸­ï¼ŒæˆåŠŸæ¦‚ç‡ä¸º $t$ æ—¶ï¼Œæ°å¥½æˆåŠŸ $i$ æ¬¡çš„æ¦‚ç‡ã€‚

**æƒé‡å‡½æ•°æ€§è´¨**ï¼š

- åœ¨ $t = 0$ æ—¶ï¼Œåªæœ‰ $B_0^n(0) = 1$ï¼Œå…¶ä»–ä¸º0
- åœ¨ $t = 1$ æ—¶ï¼Œåªæœ‰ $B_n^n(1) = 1$ï¼Œå…¶ä»–ä¸º0
- åœ¨ $t = i/n$ æ—¶ï¼Œ$B_i^n(t)$ è¾¾åˆ°æœ€å¤§å€¼

### 13.1.2 è´å¡å°”æ›²çº¿å®šä¹‰

**næ¬¡è´å¡å°”æ›²çº¿**ï¼š
$$B(t) = \sum_{i=0}^{n} P_i \cdot B_i^n(t), \quad t \in [0,1]$$

**å¸¸è§æ¬¡æ•°çš„æ˜¾å¼å…¬å¼**ï¼š

**çº¿æ€§ï¼ˆ1æ¬¡ï¼‰**ï¼š
$$B(t) = (1-t)P_0 + tP_1$$

**äºŒæ¬¡**ï¼š
$$B(t) = (1-t)^2P_0 + 2t(1-t)P_1 + t^2P_2$$

**ä¸‰æ¬¡**ï¼š
$$B(t) = (1-t)^3P_0 + 3t(1-t)^2P_1 + 3t^2(1-t)P_2 + t^3P_3$$

### 13.1.3 é¡¹ç›®ä¸­çš„æœ´ç´ å®ç°

**åŸºäºGAMES101 Assignment4çš„å®ç°**ï¼š

```cpp
cv::Point2f naive_bezier(const std::vector<cv::Point2f>& points, float t) {
    // ä¸‰æ¬¡è´å¡å°”æ›²çº¿çš„ç›´æ¥è®¡ç®—
    auto& p0 = points[0], &p1 = points[1], &p2 = points[2], &p3 = points[3];

    float u = 1.0f - t;
    float tt = t * t;
    float uu = u * u;
    float uuu = uu * u;
    float ttt = tt * t;

    cv::Point2f point = uuu * p0;           // $(1-t)^3 \cdot P_0$
    point += 3 * uu * t * p1;               // $3(1-t)^2t \cdot P_1$
    point += 3 * u * tt * p2;               // $3(1-t)t^2 \cdot P_2$
    point += ttt * p3;                      // $t^3 \cdot P_3$

    return point;
}

void draw_bezier_curve(const std::vector<cv::Point2f>& control_points, cv::Mat& window) {
    for (double t = 0.0; t <= 1.0; t += 0.001) {
        auto point = naive_bezier(control_points, t);
        window.at<cv::Vec3b>[point.y, point.x](2) = 255;  // çº¢è‰²é€šé“
    }
}
```

## 13.2 de Casteljauç®—æ³•çš„æ•°å­¦ç†è®º

### 13.2.1 ç®—æ³•çš„æ•°å­¦åŸºç¡€

#### de Casteljauç®—æ³•çš„å‡ ä½•åŸç†

**æ ¸å¿ƒæ€æƒ³**ï¼š
de Casteljauç®—æ³•é€šè¿‡é€’å½’çš„çº¿æ€§æ’å€¼æ¥è®¡ç®—è´å¡å°”æ›²çº¿ä¸Šçš„ç‚¹ï¼Œè¿™ç§æ–¹æ³•åœ¨æ•°å€¼ä¸Šæ¯”ç›´æ¥è®¡ç®—ä¼¯æ©æ–¯å¦å¤šé¡¹å¼æ›´ç¨³å®šã€‚

**æ•°å­¦è¡¨è¿°**ï¼š
è®¾æ§åˆ¶ç‚¹ä¸º $\mathbf{P}_0, \mathbf{P}_1, \ldots, \mathbf{P}_n$ï¼Œå®šä¹‰é€’å½’åºåˆ—ï¼š
$$\mathbf{P}_i^{(0)} = \mathbf{P}_i, \quad i = 0, 1, \ldots, n$$
$$\mathbf{P}_i^{(k)} = (1-t)\mathbf{P}_i^{(k-1)} + t\mathbf{P}_{i+1}^{(k-1)}, \quad k = 1, 2, \ldots, n; \quad i = 0, 1, \ldots, n-k$$

æœ€ç»ˆç»“æœï¼š$\mathbf{B}(t) = \mathbf{P}_0^{(n)}$

#### ç®—æ³•çš„æ•°å­¦è¯æ˜

**å®šç†**ï¼šde Casteljauç®—æ³•è®¡ç®—çš„ç»“æœç­‰äºè´å¡å°”æ›²çº¿çš„å®šä¹‰å¼ã€‚

**è¯æ˜æ€è·¯**ï¼š
åˆ©ç”¨æ•°å­¦å½’çº³æ³•è¯æ˜ï¼š
$$\mathbf{P}_i^{(k)} = \sum_{j=0}^{k} \binom{k}{j} t^j (1-t)^{k-j} \mathbf{P}_{i+j}$$

**åŸºç¡€æ­¥éª¤**ï¼š$k=0$ æ—¶æ˜¾ç„¶æˆç«‹ã€‚

**å½’çº³æ­¥éª¤**ï¼šå‡è®¾å¯¹ $k-1$ æˆç«‹ï¼Œåˆ™ï¼š

é€’æ¨å…³ç³»ï¼š
$$\mathbf{P}_i^{(k)} = (1-t)\mathbf{P}_i^{(k-1)} + t\mathbf{P}_{i+1}^{(k-1)}$$

ä»£å…¥å½’çº³å‡è®¾ï¼š
$$\mathbf{P}_i^{(k)} = (1-t)\sum_{j=0}^{k-1} \binom{k-1}{j} t^j (1-t)^{k-1-j} \mathbf{P}_{i+j} + t\sum_{j=0}^{k-1} \binom{k-1}{j} t^j (1-t)^{k-1-j} \mathbf{P}_{i+1+j}$$

åŒ–ç®€å¾—åˆ°ï¼š
$$\mathbf{P}_i^{(k)} = \sum_{j=0}^{k} \binom{k}{j} t^j (1-t)^{k-j} \mathbf{P}_{i+j}$$

#### ç®—æ³•çš„å‡ ä½•è§£é‡Š

**ä¸‰æ¬¡è´å¡å°”æ›²çº¿ç¤ºä¾‹**ï¼š
å¯¹äºæ§åˆ¶ç‚¹ $\mathbf{P}_0, \mathbf{P}_1, \mathbf{P}_2, \mathbf{P}_3$ï¼š

**ç¬¬ä¸€å±‚æ’å€¼**ï¼š

- $\mathbf{P}_0^{(1)} = (1-t)\mathbf{P}_0 + t\mathbf{P}_1$
- $\mathbf{P}_1^{(1)} = (1-t)\mathbf{P}_1 + t\mathbf{P}_2$
- $\mathbf{P}_2^{(1)} = (1-t)\mathbf{P}_2 + t\mathbf{P}_3$

**ç¬¬äºŒå±‚æ’å€¼**ï¼š

- $\mathbf{P}_0^{(2)} = (1-t)\mathbf{P}_0^{(1)} + t\mathbf{P}_1^{(1)}$
- $\mathbf{P}_1^{(2)} = (1-t)\mathbf{P}_1^{(1)} + t\mathbf{P}_2^{(1)}$

**ç¬¬ä¸‰å±‚æ’å€¼**ï¼š

- $\mathbf{P}_0^{(3)} = (1-t)\mathbf{P}_0^{(2)} + t\mathbf{P}_1^{(2)}$

æœ€ç»ˆ $\mathbf{B}(t) = \mathbf{P}_0^{(3)}$

### 13.2.2 é€’å½’å®ç°

```cpp
cv::Point2f recursive_bezier(const std::vector<cv::Point2f>& control_points, float t) {
    if (control_points.size() == 1) {
        return control_points[0];
    }

    std::vector<cv::Point2f> new_points;

    for (size_t i = 0; i < control_points.size() - 1; ++i) {
        cv::Point2f interpolated = (1.0f - t) * control_points[i] + t * control_points[i + 1];
        new_points.push_back(interpolated);
    }

    return recursive_bezier(new_points, t);
}
```

### 13.2.3 è¿­ä»£å®ç°ï¼ˆæ›´é«˜æ•ˆï¼‰

```cpp
cv::Point2f iterative_bezier(std::vector<cv::Point2f> points, float t) {
    int n = points.size();

    for (int level = 1; level < n; ++level) {
        for (int i = 0; i < n - level; ++i) {
            points[i] = (1.0f - t) * points[i] + t * points[i + 1];
        }
    }

    return points[0];
}
```

## 13.3 è´å¡å°”æ›²çº¿çš„æ€§è´¨ä¸åº”ç”¨

### 13.3.1 é‡è¦å‡ ä½•æ€§è´¨

**ç«¯ç‚¹æ’å€¼æ€§**ï¼š

- $B(0) = P_0$
- $B(1) = P_n$

**ç«¯ç‚¹åˆ‡å‘é‡**ï¼š

- $B'(0) = n(P_1 - P_0)$
- $B'(1) = n(P_n - P_{n-1})$

**å‡¸åŒ…æ€§è´¨**ï¼š
è´å¡å°”æ›²çº¿å®Œå…¨ä½äºæ§åˆ¶ç‚¹çš„å‡¸åŒ…å†…

**ä»¿å°„ä¸å˜æ€§**ï¼š
å…ˆå˜æ¢æ§åˆ¶ç‚¹å†ç”Ÿæˆæ›²çº¿ = å…ˆç”Ÿæˆæ›²çº¿å†å˜æ¢

### 13.3.2 å¯¼æ•°è®¡ç®—

**ä¸€é˜¶å¯¼æ•°**ï¼š

```cpp
cv::Point2f bezier_derivative(const std::vector<cv::Point2f>& points, float t) {
    int n = points.size() - 1;
    std::vector<cv::Point2f> derivative_points;

    for (int i = 0; i < n; ++i) {
        derivative_points.push_back(n * (points[i + 1] - points[i]));
    }

    return recursive_bezier(derivative_points, t);
}
```

**æ›²ç‡è®¡ç®—**ï¼š

```cpp
float bezier_curvature(const std::vector<cv::Point2f>& points, float t) {
    cv::Point2f first = bezier_derivative(points, t);
    cv::Point2f second = bezier_second_derivative(points, t);

    float numerator = std::abs(first.x * second.y - first.y * second.x);
    float denominator = std::pow(first.x * first.x + first.y * first.y, 1.5f);

    return numerator / denominator;
}
```

### 13.3.3 è‡ªé€‚åº”ç»†åˆ†

**åŸºäºæ›²ç‡çš„ç»†åˆ†**ï¼š

```cpp
void adaptive_bezier_subdivision(const std::vector<cv::Point2f>& points,
                                cv::Mat& window, float tolerance = 0.1f) {
    std::function<void(float, float, int)> subdivide =
        [&](float t_start, float t_end, int depth) {
        if (depth > 10) return;  // é˜²æ­¢æ— é™é€’å½’

        float t_mid = (t_start + t_end) * 0.5f;

        cv::Point2f p_start = recursive_bezier(points, t_start);
        cv::Point2f p_mid = recursive_bezier(points, t_mid);
        cv::Point2f p_end = recursive_bezier(points, t_end);

        // æ£€æŸ¥ä¸­ç‚¹æ˜¯å¦åç¦»ç›´çº¿å¤ªè¿œ
        cv::Point2f line_mid = (p_start + p_end) * 0.5f;
        float distance = cv::norm(p_mid - line_mid);

        if (distance > tolerance) {
            subdivide(t_start, t_mid, depth + 1);
            subdivide(t_mid, t_end, depth + 1);
        } else {
            cv::line(window, p_start, p_end, cv::Scalar(0, 255, 0), 2);
        }
    };

    subdivide(0.0f, 1.0f, 0);
}
```

---

## æ ·æ¡æ›²çº¿ä¸æ›²é¢

## 14.1 æ ·æ¡æ›²çº¿ç†è®º

### 14.1.1 æ ·æ¡çš„æ•°å­¦å®šä¹‰

#### æ ·æ¡å‡½æ•°çš„ä¸¥æ ¼å®šä¹‰

**æ ·æ¡å‡½æ•°**ï¼š
è®¾èŠ‚ç‚¹åºåˆ— $t_0 < t_1 < \cdots < t_m$ï¼Œ$p$ æ¬¡æ ·æ¡å‡½æ•° $S(t)$ æ˜¯æ»¡è¶³ä»¥ä¸‹æ¡ä»¶çš„åˆ†æ®µå¤šé¡¹å¼ï¼š

1. åœ¨æ¯ä¸ªåŒºé—´ $[t_i, t_{i+1}]$ ä¸Šï¼Œ$S(t)$ æ˜¯æ¬¡æ•°ä¸è¶…è¿‡ $p$ çš„å¤šé¡¹å¼
2. $S(t)$ åœ¨æ•´ä¸ªå®šä¹‰åŸŸä¸Šå…·æœ‰ $C^{p-1}$ è¿ç»­æ€§

#### Bæ ·æ¡åŸºå‡½æ•°çš„é€’æ¨å®šä¹‰

**0æ¬¡Bæ ·æ¡åŸºå‡½æ•°**ï¼š

åŸºå‡½æ•°å®šä¹‰ï¼š

å½“ $t_i \leq t < t_{i+1}$ æ—¶ï¼š$N_{i,0}(t) = 1$

å…¶ä»–æƒ…å†µï¼š$N_{i,0}(t) = 0$

**é«˜æ¬¡Bæ ·æ¡åŸºå‡½æ•°ï¼ˆCox-de Booré€’æ¨å…¬å¼ï¼‰**ï¼š
$$N_{i,p}(t) = \frac{t - t_i}{t_{i+p} - t_i} N_{i,p-1}(t) + \frac{t_{i+p+1} - t}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t)$$

**çº¦å®š**ï¼šå½“åˆ†æ¯ä¸ºé›¶æ—¶ï¼Œå¯¹åº”é¡¹ä¸ºé›¶ï¼Œå³ $\frac{0}{0} = 0$ã€‚

#### Bæ ·æ¡åŸºå‡½æ•°çš„é‡è¦æ€§è´¨

**1. éè´Ÿæ€§**ï¼š$N_{i,p}(t) \geq 0$ å¯¹æ‰€æœ‰ $t$

**2. å±€éƒ¨æ”¯æ’‘æ€§**ï¼š$N_{i,p}(t) = 0$ å½“ $t \notin [t_i, t_{i+p+1}]$

**3. æƒé‡å’Œä¸º1**ï¼š$\sum_{i} N_{i,p}(t) = 1$ å¯¹æ‰€æœ‰ $t$

**4. è¿ç»­æ€§**ï¼š$N_{i,p}(t)$ åœ¨èŠ‚ç‚¹å¤„å…·æœ‰ $C^{p-1}$ è¿ç»­æ€§

### 14.1.2 Bæ ·æ¡æ›²çº¿çš„æ•°å­¦ç†è®º

#### Bæ ·æ¡æ›²çº¿çš„å®šä¹‰

**æ•°å­¦è¡¨è¾¾å¼**ï¼š
$$\mathbf{C}(t) = \sum_{i=0}^{n} \mathbf{P}_i N_{i,p}(t)$$

å…¶ä¸­ï¼š

- $\mathbf{P}_i$ æ˜¯æ§åˆ¶ç‚¹
- $N_{i,p}(t)$ æ˜¯ $p$ æ¬¡Bæ ·æ¡åŸºå‡½æ•°
- $n+1$ æ˜¯æ§åˆ¶ç‚¹çš„æ•°é‡

#### èŠ‚ç‚¹å‘é‡çš„ä½œç”¨

**èŠ‚ç‚¹å‘é‡**ï¼š$\mathbf{T} = \{t_0, t_1, \ldots, t_{m}\}$ï¼Œå…¶ä¸­ $m = n + p + 1$

**èŠ‚ç‚¹å‘é‡çš„åˆ†ç±»**ï¼š

1. **å‡åŒ€èŠ‚ç‚¹å‘é‡**ï¼šèŠ‚ç‚¹ç­‰é—´è·åˆ†å¸ƒ
2. **éå‡åŒ€èŠ‚ç‚¹å‘é‡**ï¼šèŠ‚ç‚¹é—´è·ä¸ç­‰
3. **å¼€æ”¾èŠ‚ç‚¹å‘é‡**ï¼šé¦–æœ«èŠ‚ç‚¹é‡å¤åº¦ä¸º $p+1$

#### Bæ ·æ¡æ›²çº¿çš„æ€§è´¨

**1. å‡¸åŒ…æ€§è´¨**ï¼šæ›²çº¿ä½äºæ§åˆ¶ç‚¹çš„å‡¸åŒ…å†…

**2. å±€éƒ¨æ§åˆ¶æ€§**ï¼šç§»åŠ¨æ§åˆ¶ç‚¹ $\mathbf{P}_i$ åªå½±å“å‚æ•°åŒºé—´ $[t_i, t_{i+p+1}]$ å†…çš„æ›²çº¿

**3. å˜åˆ†é€’å‡æ€§**ï¼šæ›²çº¿ä¸ä»»æ„ç›´çº¿çš„äº¤ç‚¹æ•°ä¸è¶…è¿‡æ§åˆ¶å¤šè¾¹å½¢ä¸è¯¥ç›´çº¿çš„äº¤ç‚¹æ•°

**4. ä»¿å°„ä¸å˜æ€§**ï¼šä»¿å°„å˜æ¢å¯ç›´æ¥ä½œç”¨äºæ§åˆ¶ç‚¹

**ä»£ç å®ç°**ï¼š

```cpp
class BSpline {
private:
    std::vector<Vector3f> control_points;
    std::vector<float> knot_vector;
    int degree;

public:
    float basis_function(int i, int p, float t) {
        if (p == 0) {
            return (t >= knot_vector[i] && t < knot_vector[i + 1]) ? 1.0f : 0.0f;
        }

        float left_coeff = 0.0f, right_coeff = 0.0f;

        if (knot_vector[i + p] != knot_vector[i]) {
            left_coeff = (t - knot_vector[i]) / (knot_vector[i + p] - knot_vector[i]);
        }

        if (knot_vector[i + p + 1] != knot_vector[i + 1]) {
            right_coeff = (knot_vector[i + p + 1] - t) / (knot_vector[i + p + 1] - knot_vector[i + 1]);
        }

        return left_coeff * basis_function(i, p - 1, t) +
               right_coeff * basis_function(i + 1, p - 1, t);
    }

    Vector3f evaluate(float t) {
        Vector3f point = Vector3f::Zero();

        for (int i = 0; i < control_points.size(); ++i) {
            point += control_points[i] * basis_function(i, degree, t);
        }

        return point;
    }
};
```

### 14.1.3 NURBSæ›²çº¿çš„æ•°å­¦ç†è®º

#### NURBSçš„å®šä¹‰

**éå‡åŒ€æœ‰ç†Bæ ·æ¡ï¼ˆNURBSï¼‰**ï¼š
$$\mathbf{C}(t) = \frac{\sum_{i=0}^{n} w_i \mathbf{P}_i N_{i,p}(t)}{\sum_{i=0}^{n} w_i N_{i,p}(t)}$$

å…¶ä¸­ $w_i$ æ˜¯æ§åˆ¶ç‚¹ $\mathbf{P}_i$ çš„æƒé‡ã€‚

#### æœ‰ç†åŸºå‡½æ•°

**æœ‰ç†åŸºå‡½æ•°å®šä¹‰**ï¼š
$$R_{i,p}(t) = \frac{w_i N_{i,p}(t)}{\sum_{j=0}^{n} w_j N_{j,p}(t)}$$

**NURBSæ›²çº¿çš„ç®€åŒ–è¡¨ç¤º**ï¼š
$$\mathbf{C}(t) = \sum_{i=0}^{n} \mathbf{P}_i R_{i,p}(t)$$

#### NURBSçš„å‡ ä½•æ„ä¹‰

**é½æ¬¡åæ ‡è¡¨ç¤º**ï¼š
NURBSå¯ä»¥çœ‹ä½œæ˜¯å››ç»´ç©ºé—´ä¸­Bæ ·æ¡æ›²çº¿çš„é€è§†æŠ•å½±ï¼š
$$\mathbf{C}^w(t) = \sum_{i=0}^{n} \mathbf{P}_i^w N_{i,p}(t)$$

å…¶ä¸­ $\mathbf{P}_i^w = (w_i x_i, w_i y_i, w_i z_i, w_i)$ æ˜¯é½æ¬¡æ§åˆ¶ç‚¹ã€‚

**é€è§†æŠ•å½±**ï¼š
$$\mathbf{C}(t) = \frac{(\mathbf{C}^w_x(t), \mathbf{C}^w_y(t), \mathbf{C}^w_z(t))}{\mathbf{C}^w_w(t)}$$

#### NURBSçš„ä¼˜åŠ¿

**1. ç²¾ç¡®è¡¨ç¤ºåœ†é”¥æ›²çº¿**ï¼šé€šè¿‡é€‚å½“é€‰æ‹©æƒé‡ï¼Œå¯ä»¥ç²¾ç¡®è¡¨ç¤ºåœ†ã€æ¤­åœ†ã€æŠ›ç‰©çº¿ã€åŒæ›²çº¿

**2. å±€éƒ¨æƒé‡æ§åˆ¶**ï¼šæ”¹å˜æƒé‡ $w_i$ å¯ä»¥å±€éƒ¨è°ƒæ•´æ›²çº¿å½¢çŠ¶

**3. æŠ•å½±ä¸å˜æ€§**ï¼šé€è§†æŠ•å½±ä¸‹NURBSä»ä¸ºNURBS

**ä»£ç å®ç°**ï¼š

```cpp
class NURBS : public BSpline {
private:
    std::vector<float> weights;

public:
    Vector3f evaluate(float t) override {
        Vector3f numerator = Vector3f::Zero();
        float denominator = 0.0f;

        for (int i = 0; i < control_points.size(); ++i) {
            float basis = basis_function(i, degree, t);
            numerator += weights[i] * control_points[i] * basis;
            denominator += weights[i] * basis;
        }

        return numerator / denominator;
    }
};
```

## 14.2 æ›²é¢ç†è®º

### 14.2.1 è´å¡å°”æ›²é¢çš„æ•°å­¦ç†è®º

#### è´å¡å°”æ›²é¢çš„å®šä¹‰

**åŒå‚æ•°è´å¡å°”æ›²é¢**ï¼š
$$\mathbf{S}(u,v) = \sum_{i=0}^{m} \sum_{j=0}^{n} \mathbf{P}_{ij} B_i^m(u) B_j^n(v)$$

å…¶ä¸­ï¼š

- $\mathbf{P}_{ij}$ æ˜¯ $(m+1) \times (n+1)$ æ§åˆ¶ç‚¹ç½‘æ ¼
- $B_i^m(u)$ å’Œ $B_j^n(v)$ æ˜¯ä¼¯æ©æ–¯å¦åŸºå‡½æ•°
- $(u,v) \in [0,1] \times [0,1]$ æ˜¯å‚æ•°åŸŸ

#### æ›²é¢çš„å‡ ä½•æ€§è´¨

**è¾¹ç•Œæ›²çº¿**ï¼š
è´å¡å°”æ›²é¢çš„å››æ¡è¾¹ç•Œéƒ½æ˜¯è´å¡å°”æ›²çº¿ï¼š

**å››æ¡è¾¹ç•Œæ›²çº¿**ï¼š

å·¦è¾¹ç•Œï¼ˆ$u=0$ï¼‰ï¼š
$$\mathbf{S}(0,v) = \sum_{j=0}^{n} \mathbf{P}_{0j} B_j^n(v)$$

å³è¾¹ç•Œï¼ˆ$u=1$ï¼‰ï¼š
$$\mathbf{S}(1,v) = \sum_{j=0}^{n} \mathbf{P}_{mj} B_j^n(v)$$

ä¸‹è¾¹ç•Œï¼ˆ$v=0$ï¼‰ï¼š
$$\mathbf{S}(u,0) = \sum_{i=0}^{m} \mathbf{P}_{i0} B_i^m(u)$$

ä¸Šè¾¹ç•Œï¼ˆ$v=1$ï¼‰ï¼š
$$\mathbf{S}(u,1) = \sum_{i=0}^{m} \mathbf{P}_{in} B_i^m(u)$$

**è§’ç‚¹æ’å€¼**ï¼š
$$\mathbf{S}(0,0) = \mathbf{P}_{00}, \quad \mathbf{S}(1,0) = \mathbf{P}_{m0}, \quad \mathbf{S}(0,1) = \mathbf{P}_{0n}, \quad \mathbf{S}(1,1) = \mathbf{P}_{mn}$$

#### æ›²é¢æ³•å‘é‡è®¡ç®—

**åå¯¼æ•°**ï¼š
$$\frac{\partial \mathbf{S}}{\partial u} = \sum_{i=0}^{m} \sum_{j=0}^{n} \mathbf{P}_{ij} \frac{dB_i^m(u)}{du} B_j^n(v)$$

$$\frac{\partial \mathbf{S}}{\partial v} = \sum_{i=0}^{m} \sum_{j=0}^{n} \mathbf{P}_{ij} B_i^m(u) \frac{dB_j^n(v)}{dv}$$

**æ³•å‘é‡**ï¼š
$$\mathbf{N}(u,v) = \frac{\partial \mathbf{S}}{\partial u} \times \frac{\partial \mathbf{S}}{\partial v}$$

**å•ä½æ³•å‘é‡**ï¼š
$$\hat{\mathbf{N}}(u,v) = \frac{\mathbf{N}(u,v)}{\|\mathbf{N}(u,v)\|}$$

**ä»£ç å®ç°**ï¼š

```cpp
class BezierSurface {
private:
    std::vector<std::vector<Vector3f>> control_points;  // m+1 x n+1 ç½‘æ ¼
    int m, n;  // åº¦æ•°

public:
    Vector3f evaluate(float u, float v) {
        Vector3f point = Vector3f::Zero();

        for (int i = 0; i <= m; ++i) {
            for (int j = 0; j <= n; ++j) {
                float basis_u = bernstein_polynomial(i, m, u);
                float basis_v = bernstein_polynomial(j, n, v);
                point += control_points[i][j] * basis_u * basis_v;
            }
        }

        return point;
    }

    Vector3f normal(float u, float v) {
        Vector3f du = partial_derivative_u(u, v);
        Vector3f dv = partial_derivative_v(u, v);
        return du.cross(dv).normalized();
    }

private:
    float bernstein_polynomial(int i, int n, float t) {
        return binomial_coefficient(n, i) *
               std::pow(t, i) * std::pow(1 - t, n - i);
    }
};
```

### 14.2.2 æ›²é¢ç»†åˆ†

**å‡åŒ€ç»†åˆ†**ï¼š

```cpp
void subdivide_surface(BezierSurface& surface, int subdivisions) {
    float step = 1.0f / subdivisions;

    for (int i = 0; i <= subdivisions; ++i) {
        for (int j = 0; j <= subdivisions; ++j) {
            float u = i * step;
            float v = j * step;

            Vector3f point = surface.evaluate(u, v);
            Vector3f normal = surface.normal(u, v);

            // æ·»åŠ åˆ°ç½‘æ ¼
            add_vertex(point, normal);
        }
    }

    // ç”Ÿæˆä¸‰è§’å½¢ç´¢å¼•
    for (int i = 0; i < subdivisions; ++i) {
        for (int j = 0; j < subdivisions; ++j) {
            int idx = i * (subdivisions + 1) + j;

            // ç¬¬ä¸€ä¸ªä¸‰è§’å½¢
            add_triangle(idx, idx + 1, idx + subdivisions + 1);
            // ç¬¬äºŒä¸ªä¸‰è§’å½¢
            add_triangle(idx + 1, idx + subdivisions + 2, idx + subdivisions + 1);
        }
    }
}
```

---

## ç½‘æ ¼å‡ ä½•å¤„ç†

## 15.1 ç½‘æ ¼æ•°æ®ç»“æ„

### 15.1.1 åŠè¾¹æ•°æ®ç»“æ„

**æ ¸å¿ƒæ¦‚å¿µ**ï¼š

- æ¯æ¡è¾¹åˆ†ä¸ºä¸¤ä¸ªåŠè¾¹
- æ¯ä¸ªåŠè¾¹æŒ‡å‘ä¸€ä¸ªé¡¶ç‚¹
- æ¯ä¸ªåŠè¾¹å±äºä¸€ä¸ªé¢

**æ•°æ®ç»“æ„å®šä¹‰**ï¼š

```cpp
struct HalfEdge {
    int vertex;           // æŒ‡å‘çš„é¡¶ç‚¹
    int face;            // æ‰€å±é¢
    int next;            // åŒä¸€é¢çš„ä¸‹ä¸€æ¡åŠè¾¹
    int prev;            // åŒä¸€é¢çš„å‰ä¸€æ¡åŠè¾¹
    int twin;            // å¯¹å¶åŠè¾¹
};

struct Vertex {
    Vector3f position;
    Vector3f normal;
    int halfedge;        // ä»»æ„ä¸€æ¡å‡ºè¾¹
};

struct Face {
    int halfedge;        // ä»»æ„ä¸€æ¡è¾¹ç•ŒåŠè¾¹
    Vector3f normal;
};

class HalfEdgeMesh {
private:
    std::vector<Vertex> vertices;
    std::vector<HalfEdge> halfedges;
    std::vector<Face> faces;

public:
    // éå†é¡¶ç‚¹çš„æ‰€æœ‰é‚»æ¥é¡¶ç‚¹
    std::vector<int> get_vertex_neighbors(int vertex_id) {
        std::vector<int> neighbors;
        int start_he = vertices[vertex_id].halfedge;
        int current_he = start_he;

        do {
            int twin_he = halfedges[current_he].twin;
            neighbors.push_back(halfedges[twin_he].vertex);
            current_he = halfedges[twin_he].next;
        } while (current_he != start_he);

        return neighbors;
    }
};
```

### 15.1.2 ç½‘æ ¼è´¨é‡è¯„ä¼°çš„æ•°å­¦ç†è®º

#### ä¸‰è§’å½¢è´¨é‡åº¦é‡

**ç­‰å‘¨æ¯”ï¼ˆIsoperimetric Ratioï¼‰**ï¼š
$$Q = \frac{4\sqrt{3} \cdot A}{P^2}$$

å…¶ä¸­ï¼š

- $A$ æ˜¯ä¸‰è§’å½¢é¢ç§¯
- $P$ æ˜¯ä¸‰è§’å½¢å‘¨é•¿

**æ•°å­¦æ€§è´¨**ï¼š

- $Q = 1$ å¯¹äºç­‰è¾¹ä¸‰è§’å½¢ï¼ˆæœ€ä¼˜ï¼‰
- $Q \to 0$ å¯¹äºé€€åŒ–ä¸‰è§’å½¢
- $0 < Q \leq 1$ å¯¹äºæ‰€æœ‰æœ‰æ•ˆä¸‰è§’å½¢

**é¢ç§¯è®¡ç®—**ï¼š
å¯¹äºé¡¶ç‚¹ $\mathbf{v}_1, \mathbf{v}_2, \mathbf{v}_3$ï¼š
$$A = \frac{1}{2}\|(\mathbf{v}_2 - \mathbf{v}_1) \times (\mathbf{v}_3 - \mathbf{v}_1)\|$$

**å‘¨é•¿è®¡ç®—**ï¼š
$$P = \|\mathbf{v}_2 - \mathbf{v}_1\| + \|\mathbf{v}_3 - \mathbf{v}_2\| + \|\mathbf{v}_1 - \mathbf{v}_3\|$$

#### å…¶ä»–è´¨é‡åº¦é‡

**é•¿å®½æ¯”ï¼ˆAspect Ratioï¼‰**ï¼š
$$AR = \frac{a \cdot b \cdot c}{8(s-a)(s-b)(s-c)}$$

å…¶ä¸­ $s = \frac{a+b+c}{2}$ æ˜¯åŠå‘¨é•¿ã€‚

**æœ€å°è§’åº¦**ï¼š
$$\theta_{min} = \min\{\arccos\frac{b^2+c^2-a^2}{2bc}, \arccos\frac{a^2+c^2-b^2}{2ac}, \arccos\frac{a^2+b^2-c^2}{2ab}\}$$

#### å·¥ç¨‹å®ç°

```cpp
class TriangleQuality {
public:
    static float isoperimetric_ratio(const Vector3f& v1, const Vector3f& v2, const Vector3f& v3) {
        Vector3f e1 = v2 - v1;
        Vector3f e2 = v3 - v2;
        Vector3f e3 = v1 - v3;

        float a = e1.norm();
        float b = e2.norm();
        float c = e3.norm();

        float area = 0.5f * e1.cross(-e3).norm();  // ä½¿ç”¨å‰ç§¯è®¡ç®—é¢ç§¯
        float perimeter = a + b + c;

        if (perimeter < 1e-8f) return 0.0f;  // é¿å…é™¤é›¶

        return 4.0f * std::sqrt(3.0f) * area / (perimeter * perimeter);
    }

    static float min_angle(const Vector3f& v1, const Vector3f& v2, const Vector3f& v3) {
        Vector3f e1 = (v2 - v1).normalized();
        Vector3f e2 = (v3 - v2).normalized();
        Vector3f e3 = (v1 - v3).normalized();

        float angle1 = std::acos(std::clamp(e1.dot(-e3), -1.0f, 1.0f));
        float angle2 = std::acos(std::clamp((-e1).dot(e2), -1.0f, 1.0f));
        float angle3 = std::acos(std::clamp((-e2).dot(e3), -1.0f, 1.0f));

        return std::min({angle1, angle2, angle3});
    }
};
```

**ç½‘æ ¼ç»Ÿè®¡ä¿¡æ¯**ï¼š

```cpp
struct MeshStatistics {
    float min_edge_length;
    float max_edge_length;
    float avg_edge_length;
    float min_triangle_quality;
    float avg_triangle_quality;
    int degenerate_triangles;
};

MeshStatistics analyze_mesh(const HalfEdgeMesh& mesh) {
    MeshStatistics stats;
    // å®ç°ç»Ÿè®¡è®¡ç®—...
    return stats;
}
```

## 15.2 ç½‘æ ¼å¤„ç†ç®—æ³•

### 15.2.1 ç½‘æ ¼ç®€åŒ–çš„æ•°å­¦ç†è®º

#### äºŒæ¬¡è¯¯å·®åº¦é‡ï¼ˆQEMï¼‰

**åŸºæœ¬æ€æƒ³**ï¼š
æ¯ä¸ªé¡¶ç‚¹å…³è”ä¸€ä¸ªäºŒæ¬¡è¯¯å·®çŸ©é˜µï¼Œç”¨äºåº¦é‡é¡¶ç‚¹åˆ°å…¶é‚»æ¥å¹³é¢çš„è·ç¦»å¹³æ–¹å’Œã€‚

**å¹³é¢æ–¹ç¨‹**ï¼š
å¯¹äºä¸‰è§’å½¢é¢ $f$ï¼Œå…¶å¹³é¢æ–¹ç¨‹ä¸ºï¼š
$$\pi_f: ax + by + cz + d = 0$$

å…¶ä¸­ $\mathbf{n} = (a, b, c)^T$ æ˜¯å•ä½æ³•å‘é‡ï¼Œ$d$ æ˜¯åˆ°åŸç‚¹çš„è·ç¦»ã€‚

**äºŒæ¬¡è¯¯å·®çŸ©é˜µ**ï¼š
å¯¹äºå¹³é¢ $\pi = (a, b, c, d)^T$ï¼Œå…¶å¯¹åº”çš„äºŒæ¬¡è¯¯å·®çŸ©é˜µä¸ºï¼š

äºŒæ¬¡è¯¯å·®çŸ©é˜µ $\mathbf{Q}_\pi = \pi \pi^T$ çš„ç»“æ„ï¼š

- ç¬¬1è¡Œï¼š$(a^2, ab, ac, ad)$
- ç¬¬2è¡Œï¼š$(ab, b^2, bc, bd)$
- ç¬¬3è¡Œï¼š$(ac, bc, c^2, cd)$
- ç¬¬4è¡Œï¼š$(ad, bd, cd, d^2)$

$$\mathbf{Q}_\pi = \text{quadric error matrix}$$

**é¡¶ç‚¹çš„äºŒæ¬¡è¯¯å·®**ï¼š
é¡¶ç‚¹ $v$ çš„äºŒæ¬¡è¯¯å·®çŸ©é˜µæ˜¯å…¶æ‰€æœ‰é‚»æ¥é¢çš„äºŒæ¬¡è¯¯å·®çŸ©é˜µä¹‹å’Œï¼š
$$\mathbf{Q}_v = \sum_{f \in \text{faces}(v)} \mathbf{Q}_{\pi_f}$$

**ç‚¹åˆ°å¹³é¢è·ç¦»çš„äºŒæ¬¡å½¢å¼**ï¼š
ç‚¹ $\mathbf{p} = (x, y, z, 1)^T$ çš„äºŒæ¬¡è¯¯å·®ä¸ºï¼š
$$\text{error}(\mathbf{p}) = \mathbf{p}^T \mathbf{Q}_v \mathbf{p}$$

#### è¾¹æŠ˜å çš„æœ€ä¼˜ä½ç½®

**é—®é¢˜æè¿°**ï¼š
å½“è¾¹ $(v_1, v_2)$ æŠ˜å ä¸ºæ–°é¡¶ç‚¹ $\bar{v}$ æ—¶ï¼Œæ–°é¡¶ç‚¹çš„äºŒæ¬¡è¯¯å·®çŸ©é˜µä¸ºï¼š
$$\mathbf{Q}_{\bar{v}} = \mathbf{Q}_{v_1} + \mathbf{Q}_{v_2}$$

**æœ€ä¼˜ä½ç½®æ±‚è§£**ï¼š
æœ€å°åŒ–äºŒæ¬¡è¯¯å·® $\mathbf{p}^T \mathbf{Q}_{\bar{v}} \mathbf{p}$ï¼Œå…¶ä¸­ $\mathbf{p} = (x, y, z, 1)^T$ã€‚

å¯¹ $x, y, z$ æ±‚åå¯¼å¹¶ä»¤å…¶ä¸ºé›¶ï¼š
$$\frac{\partial}{\partial x}(\mathbf{p}^T \mathbf{Q}_{\bar{v}} \mathbf{p}) = 0$$

å¾—åˆ°çº¿æ€§æ–¹ç¨‹ç»„ï¼š

ç³»æ•°çŸ©é˜µä¸ºå·¦ä¸Šè§’ $3 \times 3$ å­çŸ©é˜µï¼Œå³ç«¯é¡¹ä¸ºè´Ÿçš„ç¬¬4åˆ—å‰ä¸‰ä¸ªå…ƒç´ ï¼š

$$\mathbf{Q}_{3 \times 3} \cdot (x, y, z)^T = -(q_{14}, q_{24}, q_{34})^T$$

#### å·¥ç¨‹å®ç°

```cpp
class QEMSimplification {
private:
    struct QuadricMatrix {
        float q[10];  // å¯¹ç§°çŸ©é˜µçš„ä¸Šä¸‰è§’éƒ¨åˆ†

        QuadricMatrix() { std::fill(q, q + 10, 0.0f); }

        // ä»å¹³é¢æ„é€ äºŒæ¬¡è¯¯å·®çŸ©é˜µ
        QuadricMatrix(const Vector4f& plane) {
            float a = plane.x(), b = plane.y(), c = plane.z(), d = plane.w();
            q[0] = a*a; q[1] = a*b; q[2] = a*c; q[3] = a*d;
                        q[4] = b*b; q[5] = b*c; q[6] = b*d;
                                    q[7] = c*c; q[8] = c*d;
                                                q[9] = d*d;
        }

        QuadricMatrix operator+(const QuadricMatrix& other) const {
            QuadricMatrix result;
            for (int i = 0; i < 10; ++i) {
                result.q[i] = q[i] + other.q[i];
            }
            return result;
        }

        float evaluate(const Vector3f& point) const {
            Vector4f p(point.x(), point.y(), point.z(), 1.0f);
            return p.x()*p.x()*q[0] + 2*p.x()*p.y()*q[1] + 2*p.x()*p.z()*q[2] + 2*p.x()*p.w()*q[3] +
                   p.y()*p.y()*q[4] + 2*p.y()*p.z()*q[5] + 2*p.y()*p.w()*q[6] +
                   p.z()*p.z()*q[7] + 2*p.z()*p.w()*q[8] +
                   p.w()*p.w()*q[9];
        }
    };

    std::vector<QuadricMatrix> vertex_quadrics;

public:
    float calculate_collapse_cost(const HalfEdgeMesh& mesh, int edge_id, Vector3f& optimal_pos) {
        auto [v1, v2] = mesh.get_edge_vertices(edge_id);
        QuadricMatrix combined = vertex_quadrics[v1] + vertex_quadrics[v2];

        // å°è¯•ä¸‰ä¸ªå€™é€‰ä½ç½®ï¼šv1, v2, æœ€ä¼˜è§£
        Vector3f pos1 = mesh.get_vertex_position(v1);
        Vector3f pos2 = mesh.get_vertex_position(v2);
        Vector3f pos_optimal = solve_optimal_position(combined);

        float cost1 = combined.evaluate(pos1);
        float cost2 = combined.evaluate(pos2);
        float cost_optimal = combined.evaluate(pos_optimal);

        if (cost_optimal <= cost1 && cost_optimal <= cost2) {
            optimal_pos = pos_optimal;
            return cost_optimal;
        } else if (cost1 <= cost2) {
            optimal_pos = pos1;
            return cost1;
        } else {
            optimal_pos = pos2;
            return cost2;
        }
    }
};

### 15.2.2 ç½‘æ ¼ç»†åˆ†çš„æ•°å­¦ç†è®º

#### Loopç»†åˆ†ç®—æ³•

**åŸºæœ¬æ€æƒ³**ï¼š
Loopç»†åˆ†æ˜¯ä¸€ç§é€¼è¿‘ç»†åˆ†æ–¹æ¡ˆï¼Œé€šè¿‡åœ¨æ¯ä¸ªä¸‰è§’å½¢ä¸­æ’å…¥æ–°é¡¶ç‚¹å¹¶é‡æ–°è¿æ¥æ¥ç»†åŒ–ç½‘æ ¼ã€‚

#### é¡¶ç‚¹ä½ç½®æ›´æ–°è§„åˆ™

**åŸæœ‰é¡¶ç‚¹çš„æ–°ä½ç½®**ï¼š
å¯¹äºåº¦æ•°ä¸º $n$ çš„é¡¶ç‚¹ $v$ï¼Œå…¶æ–°ä½ç½®ä¸ºï¼š
$$\mathbf{v}_{new} = (1 - n\beta)\mathbf{v} + \beta\sum_{i=1}^{n}\mathbf{v}_i$$

å…¶ä¸­ $\mathbf{v}_i$ æ˜¯ $v$ çš„é‚»æ¥é¡¶ç‚¹ï¼Œæƒé‡ $\beta$ å®šä¹‰ä¸ºï¼š

æƒé‡è®¡ç®—ï¼š

å½“ $n = 3$ æ—¶ï¼š$\beta = \frac{3}{16}$

å½“ $n > 3$ æ—¶ï¼š$\beta = \frac{3}{8n}$

**æ–°é¡¶ç‚¹ï¼ˆè¾¹ä¸­ç‚¹ï¼‰çš„ä½ç½®**ï¼š
å¯¹äºè¾¹ $e = (v_1, v_2)$ï¼Œè®¾å…¶ä¸¤ä¸ªé‚»æ¥ä¸‰è§’å½¢çš„ç¬¬ä¸‰ä¸ªé¡¶ç‚¹åˆ†åˆ«ä¸º $v_3$ å’Œ $v_4$ï¼Œåˆ™æ–°é¡¶ç‚¹ä½ç½®ä¸ºï¼š
$$\mathbf{v}_{edge} = \frac{3}{8}(\mathbf{v}_1 + \mathbf{v}_2) + \frac{1}{8}(\mathbf{v}_3 + \mathbf{v}_4)$$

#### æ•°å­¦æ€§è´¨

**æ”¶æ•›æ€§**ï¼š
Loopç»†åˆ†åœ¨ $C^2$ è¿ç»­æ€§ä¸‹æ”¶æ•›åˆ°å…‰æ»‘æé™æ›²é¢ï¼Œé™¤äº†ç‰¹æ®Šç‚¹ï¼ˆåº¦æ•°ä¸ä¸º6çš„é¡¶ç‚¹ï¼‰ã€‚

**ç‰¹å¾å€¼åˆ†æ**ï¼š
ç»†åˆ†çŸ©é˜µçš„ç‰¹å¾å€¼å†³å®šäº†æ”¶æ•›æ€§è´¨ï¼š
- ä¸»ç‰¹å¾å€¼ $\lambda_0 = 1$
- æ¬¡ç‰¹å¾å€¼ $\lambda_1 = \lambda_2 = \frac{1}{2} + \frac{1}{4}\cos\frac{2\pi}{n}$

#### å·¥ç¨‹å®ç°

```cpp
class LoopSubdivision {
public:
    static void subdivide(HalfEdgeMesh& mesh) {
        std::vector<Vector3f> new_vertex_positions;
        std::vector<Vector3f> edge_midpoints;

        // 1. è®¡ç®—åŸæœ‰é¡¶ç‚¹çš„æ–°ä½ç½®
        for (int i = 0; i < mesh.vertex_count(); ++i) {
            new_vertex_positions.push_back(compute_vertex_position(mesh, i));
        }

        // 2. è®¡ç®—è¾¹ä¸­ç‚¹ä½ç½®
        for (int i = 0; i < mesh.edge_count(); ++i) {
            edge_midpoints.push_back(compute_edge_midpoint(mesh, i));
        }

        // 3. é‡å»ºç½‘æ ¼æ‹“æ‰‘
        rebuild_subdivided_mesh(mesh, new_vertex_positions, edge_midpoints);
    }

private:
    static Vector3f compute_vertex_position(const HalfEdgeMesh& mesh, int vertex_id) {
        std::vector<int> neighbors = mesh.get_vertex_neighbors(vertex_id);
        int n = neighbors.size();

        float beta = (n == 3) ? 3.0f/16.0f : 3.0f/(8.0f*n);

        Vector3f original_pos = mesh.get_vertex_position(vertex_id);
        Vector3f neighbor_sum = Vector3f::Zero();

        for (int neighbor : neighbors) {
            neighbor_sum += mesh.get_vertex_position(neighbor);
        }

        return (1.0f - n*beta) * original_pos + beta * neighbor_sum;
    }

    static Vector3f compute_edge_midpoint(const HalfEdgeMesh& mesh, int edge_id) {
        auto [v1, v2] = mesh.get_edge_vertices(edge_id);
        auto [v3, v4] = mesh.get_edge_opposite_vertices(edge_id);

        Vector3f pos1 = mesh.get_vertex_position(v1);
        Vector3f pos2 = mesh.get_vertex_position(v2);
        Vector3f pos3 = mesh.get_vertex_position(v3);
        Vector3f pos4 = mesh.get_vertex_position(v4);

        return 0.375f * (pos1 + pos2) + 0.125f * (pos3 + pos4);
    }
};
```

### 15.2.3 ç½‘æ ¼å¹³æ»‘

**æ‹‰æ™®æ‹‰æ–¯å¹³æ»‘**ï¼š

```cpp
void laplacian_smoothing(HalfEdgeMesh& mesh, float lambda = 0.5f, int iterations = 10) {
    for (int iter = 0; iter < iterations; ++iter) {
        std::vector<Vector3f> new_positions(mesh.vertex_count());

        for (int i = 0; i < mesh.vertex_count(); ++i) {
            if (mesh.is_boundary_vertex(i)) {
                new_positions[i] = mesh.get_vertex_position(i);
                continue;
            }

            std::vector<int> neighbors = mesh.get_vertex_neighbors(i);
            Vector3f laplacian = Vector3f::Zero();

            for (int neighbor : neighbors) {
                laplacian += mesh.get_vertex_position(neighbor);
            }
            laplacian /= neighbors.size();
            laplacian -= mesh.get_vertex_position(i);

            new_positions[i] = mesh.get_vertex_position(i) + lambda * laplacian;
        }

        mesh.update_vertex_positions(new_positions);
    }
}
```

## å…‰çº¿è¿½è¸ªåŸºç¡€ç†è®º

## 16.1 å…‰çº¿è¿½è¸ªçš„ç‰©ç†ä¸æ•°å­¦åŸºç¡€

### 16.1.1 å‡ ä½•å…‰å­¦çš„æ•°å­¦æ¡†æ¶

#### å‡ ä½•å…‰å­¦çš„åŸºæœ¬å‡è®¾

**1. ç›´çº¿ä¼ æ’­å‡è®¾**ï¼š
åœ¨å‡åŒ€ä»‹è´¨ä¸­ï¼Œå…‰æ²¿ç›´çº¿ä¼ æ’­ã€‚è¿™æ˜¯å…‰çº¿è¿½è¸ªç®—æ³•çš„æ ¸å¿ƒå‡è®¾ã€‚

**2. ç‹¬ç«‹æ€§å‡è®¾**ï¼š
ä¸åŒå…‰çº¿ä¹‹é—´ä¸å‘ç”Ÿç›¸äº’ä½œç”¨ï¼Œå¯ä»¥ç‹¬ç«‹è®¡ç®—æ¯æ¡å…‰çº¿çš„è´¡çŒ®ã€‚

**3. å‡ ä½•å°ºåº¦å‡è®¾**ï¼š
å…‰çš„æ³¢é•¿ $\lambda$ è¿œå°äºåœºæ™¯ä¸­ç‰©ä½“çš„ç‰¹å¾å°ºåº¦ $L$ï¼Œå³ $\lambda \ll L$ã€‚

#### å…‰çº¿çš„å‚æ•°åŒ–è¡¨ç¤º

**æ•°å­¦å®šä¹‰**ï¼š
ä¸‰ç»´ç©ºé—´ä¸­çš„å…‰çº¿å¯ä»¥ç”¨å‚æ•°æ–¹ç¨‹è¡¨ç¤ºï¼š
$$\mathbf{r}(t) = \mathbf{o} + t\mathbf{d}$$

å…¶ä¸­ï¼š

- $\mathbf{o} \in \mathbb{R}^3$ï¼šå…‰çº¿èµ·ç‚¹ï¼ˆoriginï¼‰
- $\mathbf{d} \in \mathbb{R}^3$ï¼šå…‰çº¿æ–¹å‘å‘é‡ï¼ˆdirectionï¼‰ï¼Œé€šå¸¸ä¸ºå•ä½å‘é‡
- $t \in [t_{min}, t_{max}]$ï¼šå‚æ•°èŒƒå›´

**å·¥ç¨‹å®ç°**ï¼š

```cpp
struct Ray {
    Vector3f origin;        // èµ·ç‚¹ o
    Vector3f direction;     // æ–¹å‘ dï¼ˆå•ä½å‘é‡ï¼‰
    float t_min = 1e-4f;    // æœ€å°å‚æ•°ï¼ˆé¿å…è‡ªç›¸äº¤ï¼‰
    float t_max = 1e30f;    // æœ€å¤§å‚æ•°

    // è®¡ç®—å…‰çº¿ä¸Šçš„ç‚¹
    Vector3f at(float t) const {
        return origin + t * direction;
    }

    // æ£€æŸ¥å‚æ•°æ˜¯å¦åœ¨æœ‰æ•ˆèŒƒå›´å†…
    bool is_valid_t(float t) const {
        return t >= t_min && t <= t_max;
    }
};
```

### 16.1.2 æ¸²æŸ“æ–¹ç¨‹çš„é€’å½’å½¢å¼

#### æ¸²æŸ“æ–¹ç¨‹çš„æ•°å­¦æ¨å¯¼

**ç§¯åˆ†å½¢å¼çš„æ¸²æŸ“æ–¹ç¨‹**ï¼š
$$L_o(\mathbf{p}, \omega_o) = L_e(\mathbf{p}, \omega_o) + \int_{\Omega} f_r(\mathbf{p}, \omega_i, \omega_o) L_i(\mathbf{p}, \omega_i) \cos\theta_i \, d\omega_i$$

**é€’å½’å½¢å¼çš„æ¨å¯¼**ï¼š
å…¥å°„è¾å°„åº¦ $L_i(\mathbf{p}, \omega_i)$ å®é™…ä¸Šæ˜¯ä»æ–¹å‘ $\omega_i$ å°„å‘ç‚¹ $\mathbf{p}$ çš„å…‰çº¿åœ¨å…¶èµ·å§‹ç‚¹çš„å‡ºå°„è¾å°„åº¦ã€‚

è®¾å…‰çº¿ä¸åœºæ™¯çš„ä¸‹ä¸€ä¸ªäº¤ç‚¹ä¸º $\mathbf{p}'$ï¼Œåˆ™ï¼š
$$L_i(\mathbf{p}, \omega_i) = L_o(\mathbf{p}', -\omega_i)$$

ä»£å…¥æ¸²æŸ“æ–¹ç¨‹å¾—åˆ°é€’å½’å½¢å¼ï¼š
$$L_o(\mathbf{p}, \omega_o) = L_e(\mathbf{p}, \omega_o) + \int_{\Omega} f_r(\mathbf{p}, \omega_i, \omega_o) L_o(\mathbf{p}', -\omega_i) \cos\theta_i \, d\omega_i$$

#### å…‰çº¿è¿½è¸ªçš„æ•°å­¦æœ¬è´¨

**ç§¯åˆ†æ–¹ç¨‹çš„æ±‚è§£**ï¼š
æ¸²æŸ“æ–¹ç¨‹æ˜¯ä¸€ä¸ªFredholmç§¯åˆ†æ–¹ç¨‹ï¼Œå…‰çº¿è¿½è¸ªé€šè¿‡é€’å½’æ±‚è§£è¿™ä¸ªç§¯åˆ†æ–¹ç¨‹ã€‚

**Neumannçº§æ•°å±•å¼€**ï¼š
æ¸²æŸ“æ–¹ç¨‹å¯ä»¥å±•å¼€ä¸ºæ— ç©·çº§æ•°ï¼š
$$L = L_e + TL_e + T^2L_e + T^3L_e + \cdots$$

å…¶ä¸­ $T$ æ˜¯ä¼ è¾“ç®—å­ï¼š
$$[TL](\mathbf{p}, \omega_o) = \int_{\Omega} f_r(\mathbf{p}, \omega_i, \omega_o) L(\mathbf{p}', -\omega_i) \cos\theta_i \, d\omega_i$$

**ç‰©ç†è§£é‡Š**ï¼š

- $L_e$ï¼šç›´æ¥å…‰ç…§ï¼ˆ0æ¬¡åå°„ï¼‰
- $TL_e$ï¼šä¸€æ¬¡åå°„å…‰ç…§
- $T^2L_e$ï¼šäºŒæ¬¡åå°„å…‰ç…§
- $\vdots$

#### å…‰çº¿è¿½è¸ªçš„æ”¶æ•›æ€§

**æ”¶æ•›æ¡ä»¶**ï¼š
å½“ä¼ è¾“ç®—å­ $T$ çš„è°±åŠå¾„å°äº1æ—¶ï¼ŒNeumannçº§æ•°æ”¶æ•›ï¼š
$$\rho(T) < 1$$

è¿™åœ¨ç‰©ç†ä¸Šå¯¹åº”äºèƒ½é‡å®ˆæ’æ¡ä»¶ï¼šåå°„çš„æ€»èƒ½é‡å°äºå…¥å°„èƒ½é‡ã€‚

## 16.2 Whittedå…‰çº¿è¿½è¸ªç®—æ³•

### 16.2.1 Whittedç®—æ³•çš„æ•°å­¦æ¨¡å‹

#### ç®—æ³•çš„ç†è®ºåŸºç¡€

**Whittedæ¨¡å‹çš„ç®€åŒ–å‡è®¾**ï¼š

1. **å®Œç¾é•œé¢åå°„**ï¼šåªè€ƒè™‘é•œé¢æ–¹å‘çš„åå°„
2. **å®Œç¾é€å°„**ï¼šåªè€ƒè™‘æŠ˜å°„æ–¹å‘çš„é€å°„
3. **ç‚¹å…‰æº**ï¼šå…‰æºè¢«å»ºæ¨¡ä¸ºç‚¹å…‰æº
4. **é€’å½’ç»ˆæ­¢**ï¼šé€šè¿‡æ·±åº¦é™åˆ¶ç»ˆæ­¢é€’å½’

#### åå°„å®šå¾‹çš„æ•°å­¦æ¨å¯¼

**åå°„å‘é‡è®¡ç®—**ï¼š
ç»™å®šå…¥å°„å‘é‡ $\mathbf{d}$ å’Œè¡¨é¢æ³•å‘é‡ $\mathbf{n}$ï¼Œåå°„å‘é‡ $\mathbf{r}$ ä¸ºï¼š
$$\mathbf{r} = \mathbf{d} - 2(\mathbf{d} \cdot \mathbf{n})\mathbf{n}$$

**æ¨å¯¼è¿‡ç¨‹**ï¼š
è®¾å…¥å°„å‘é‡ä¸º $\mathbf{d}$ï¼Œåˆ†è§£ä¸ºæ³•å‘åˆ†é‡å’Œåˆ‡å‘åˆ†é‡ï¼š

- æ³•å‘åˆ†é‡ï¼š$\mathbf{d}_{\parallel} = (\mathbf{d} \cdot \mathbf{n})\mathbf{n}$
- åˆ‡å‘åˆ†é‡ï¼š$\mathbf{d}_{\perp} = \mathbf{d} - \mathbf{d}_{\parallel}$

åå°„æ—¶åˆ‡å‘åˆ†é‡ä¸å˜ï¼Œæ³•å‘åˆ†é‡åå‘ï¼š
$$\mathbf{r} = \mathbf{d}_{\perp} - \mathbf{d}_{\parallel} = \mathbf{d} - 2\mathbf{d}_{\parallel} = \mathbf{d} - 2(\mathbf{d} \cdot \mathbf{n})\mathbf{n}$$

#### Snellå®šå¾‹ä¸æŠ˜å°„

**Snellå®šå¾‹**ï¼š
$$n_1 \sin\theta_1 = n_2 \sin\theta_2$$

å…¶ä¸­ $n_1, n_2$ æ˜¯ä¸¤ç§ä»‹è´¨çš„æŠ˜å°„ç‡ï¼Œ$\theta_1, \theta_2$ æ˜¯å…¥å°„è§’å’ŒæŠ˜å°„è§’ã€‚

**æŠ˜å°„å‘é‡çš„å‘é‡å½¢å¼**ï¼š
$$\mathbf{t} = \frac{n_1}{n_2}\mathbf{d} + \left(\frac{n_1}{n_2}\cos\theta_1 - \cos\theta_2\right)\mathbf{n}$$

å…¶ä¸­ï¼š
$$\cos\theta_1 = -\mathbf{d} \cdot \mathbf{n}$$
$$\cos\theta_2 = \sqrt{1 - \left(\frac{n_1}{n_2}\right)^2(1 - \cos^2\theta_1)}$$

**å…¨å†…åå°„æ¡ä»¶**ï¼š
å½“ $\left(\frac{n_1}{n_2}\right)^2(1 - \cos^2\theta_1) > 1$ æ—¶å‘ç”Ÿå…¨å†…åå°„ã€‚

#### Whittedç®—æ³•çš„å®Œæ•´å®ç°

```cpp
Vector3f whitted_ray_tracing(const Ray& ray, const Scene& scene, int depth) {
    // é€’å½’ç»ˆæ­¢æ¡ä»¶
    if (depth <= 0) return Vector3f::Zero();

    // å…‰çº¿ä¸åœºæ™¯æ±‚äº¤
    Intersection hit = scene.intersect(ray);
    if (!hit.happened) return scene.background_color;

    // åˆå§‹åŒ–é¢œè‰²ä¸ºè‡ªå‘å…‰
    Vector3f color = hit.material->emission;

    // ç›´æ¥å…‰ç…§è®¡ç®—
    for (const auto& light : scene.lights) {
        Vector3f light_dir = light->sample_direction(hit.position);

        // é˜´å½±æµ‹è¯•
        Ray shadow_ray(hit.position + EPSILON * hit.normal, light_dir);
        if (!scene.is_occluded(shadow_ray, light->distance(hit.position))) {
            // è®¡ç®—ç›´æ¥å…‰ç…§è´¡çŒ®
            Vector3f light_color = light->intensity / light->distance_squared(hit.position);
            Vector3f brdf_value = hit.material->evaluate_brdf(-ray.direction, light_dir, hit.normal);
            float cos_theta = std::max(0.0f, hit.normal.dot(light_dir));

            color += brdf_value * light_color * cos_theta;
        }
    }

    // é•œé¢åå°„
    if (hit.material->is_reflective() && depth > 0) {
        Vector3f reflect_dir = reflect(ray.direction, hit.normal);
        Ray reflect_ray(hit.position + EPSILON * hit.normal, reflect_dir);

        Vector3f reflected_color = whitted_ray_tracing(reflect_ray, scene, depth - 1);
        color += hit.material->reflectance * reflected_color;
    }

    // æŠ˜å°„/é€å°„
    if (hit.material->is_transparent() && depth > 0) {
        float eta = hit.front_face ? (1.0f / hit.material->ior) : hit.material->ior;
        Vector3f refract_dir = refract(ray.direction, hit.normal, eta);

        if (refract_dir.squaredNorm() > 0) {  // æ£€æŸ¥æ˜¯å¦å‘ç”Ÿå…¨å†…åå°„
            Vector3f offset = hit.front_face ? (-EPSILON * hit.normal) : (EPSILON * hit.normal);
            Ray refract_ray(hit.position + offset, refract_dir);

            Vector3f refracted_color = whitted_ray_tracing(refract_ray, scene, depth - 1);
            color += hit.material->transmittance * refracted_color;
        }
    }

    return color;
}

// åå°„å‘é‡è®¡ç®—
Vector3f reflect(const Vector3f& incident, const Vector3f& normal) {
    return incident - 2.0f * incident.dot(normal) * normal;
}

// æŠ˜å°„å‘é‡è®¡ç®—
Vector3f refract(const Vector3f& incident, const Vector3f& normal, float eta) {
    float cos_i = -incident.dot(normal);
    float sin_t2 = eta * eta * (1.0f - cos_i * cos_i);

    if (sin_t2 >= 1.0f) {
        return Vector3f::Zero();  // å…¨å†…åå°„
    }

    float cos_t = std::sqrt(1.0f - sin_t2);
    return eta * incident + (eta * cos_i - cos_t) * normal;
}
```

```

### 16.2.2 é¡¹ç›®ä¸­çš„å®ç°æ¡†æ¶

**åŸºäºGAMES101 Assignment5-6çš„ç»“æ„**ï¼š
```cpp
Vector3f Scene::castRay(const Ray &ray, int depth) const {
    if (depth > this->maxDepth) {
        return Vector3f(0.0, 0.0, 0.0);
    }

    Intersection intersection = Scene::intersect(ray);
    if (!intersection.happened) {
        return this->backgroundColor;
    }

    Material *m = intersection.m;
    Object *hitObject = intersection.obj;
    Vector3f hitColor = this->backgroundColor;
    Vector3f hitPoint = intersection.coords;
    Vector3f N = intersection.normal;
    Vector2f uv = intersection.uv;

    switch (m->getType()) {
        case REFLECTION_AND_REFRACTION: {
            Vector3f reflectionDirection = reflect(ray.direction, N);
            Vector3f refractionDirection = refract(ray.direction, N, m->ior);

            Vector3f reflectionRayOrig = (dotProduct(reflectionDirection, N) < 0) ?
                hitPoint - N * EPSILON : hitPoint + N * EPSILON;
            Vector3f refractionRayOrig = (dotProduct(refractionDirection, N) < 0) ?
                hitPoint - N * EPSILON : hitPoint + N * EPSILON;

            Vector3f reflectionColor = castRay(Ray(reflectionRayOrig, reflectionDirection), depth + 1);
            Vector3f refractionColor = castRay(Ray(refractionRayOrig, refractionDirection), depth + 1);

            float kr = fresnel(ray.direction, N, m->ior);
            hitColor = reflectionColor * kr + refractionColor * (1 - kr);
            break;
        }
        case REFLECTION: {
            float kr = fresnel(ray.direction, N, m->ior);
            Vector3f reflectionDirection = reflect(ray.direction, N);
            Vector3f reflectionRayOrig = (dotProduct(reflectionDirection, N) < 0) ?
                hitPoint - N * EPSILON : hitPoint + N * EPSILON;
            hitColor = castRay(Ray(reflectionRayOrig, reflectionDirection), depth + 1) * kr;
            break;
        }
        default: {
            // æ¼«åå°„æè´¨çš„ç›´æ¥å…‰ç…§è®¡ç®—
            Vector3f lightAmt = 0, specularColor = 0;
            Vector3f shadowPointOrig = (dotProduct(ray.direction, N) < 0) ?
                hitPoint + N * EPSILON : hitPoint - N * EPSILON;

            for (auto& light : this->get_lights()) {
                Vector3f lightDir = light->position - hitPoint;
                float lightDistance2 = dotProduct(lightDir, lightDir);
                lightDir = normalize(lightDir);
                float LdotN = std::max(0.f, dotProduct(lightDir, N));

                // é˜´å½±æµ‹è¯•
                auto shadow_res = trace(Ray(shadowPointOrig, lightDir), this->get_objects());
                bool inShadow = shadow_res && (shadow_res->t * shadow_res->t < lightDistance2);

                lightAmt += inShadow ? 0 : light->intensity * LdotN;
                Vector3f reflectionDirection = reflect(-lightDir, N);
                specularColor += powf(std::max(0.f, -dotProduct(reflectionDirection, ray.direction)),
                    m->specularExponent) * light->intensity;
            }

            hitColor = lightAmt * m->Kd * m->diffuseColor + specularColor * m->Ks;
            break;
        }
    }

    return hitColor;
}
```

## 16.3 å…‰çº¿-ç‰©ä½“ç›¸äº¤ç®—æ³•

### 16.3.1 å…‰çº¿-çƒä½“ç›¸äº¤

**æ•°å­¦æ¨å¯¼**ï¼š
çƒä½“æ–¹ç¨‹ï¼š$||p - c||^2 = r^2$
å…‰çº¿æ–¹ç¨‹ï¼š$p = o + td$

ä»£å…¥å¾—åˆ°ï¼š$||o + td - c||^2 = r^2$

å±•å¼€ï¼š$(o - c + td) \cdot (o - c + td) = r^2$

æ•´ç†å¾—åˆ°äºŒæ¬¡æ–¹ç¨‹ï¼š$at^2 + bt + c = 0$

å…¶ä¸­ï¼š

- $a = d \cdot d = 1$ï¼ˆå‡è®¾dæ˜¯å•ä½å‘é‡ï¼‰
- $b = 2d \cdot (o - c)$
- $c = (o - c) \cdot (o - c) - r^2$

**ä»£ç å®ç°**ï¼š

```cpp
bool intersect_sphere(const Ray& ray, const Vector3f& center, float radius,
                     float& t_near, float& t_far) {
    Vector3f oc = ray.origin - center;
    float a = ray.direction.dot(ray.direction);
    float b = 2.0f * oc.dot(ray.direction);
    float c = oc.dot(oc) - radius * radius;

    float discriminant = b * b - 4 * a * c;
    if (discriminant < 0) return false;

    float sqrt_discriminant = std::sqrt(discriminant);
    t_near = (-b - sqrt_discriminant) / (2.0f * a);
    t_far = (-b + sqrt_discriminant) / (2.0f * a);

    if (t_near > t_far) std::swap(t_near, t_far);

    return t_near >= ray.t_min && t_near <= ray.t_max;
}
```

### 16.3.2 å…‰çº¿-ä¸‰è§’å½¢ç›¸äº¤

**MÃ¶ller-Trumboreç®—æ³•**ï¼š

```cpp
bool intersect_triangle(const Ray& ray, const Vector3f& v0, const Vector3f& v1, const Vector3f& v2,
                       float& t, float& u, float& v) {
    Vector3f edge1 = v1 - v0;
    Vector3f edge2 = v2 - v0;
    Vector3f h = ray.direction.cross(edge2);
    float a = edge1.dot(h);

    if (a > -EPSILON && a < EPSILON) return false;  // å…‰çº¿å¹³è¡Œäºä¸‰è§’å½¢

    float f = 1.0f / a;
    Vector3f s = ray.origin - v0;
    u = f * s.dot(h);

    if (u < 0.0f || u > 1.0f) return false;

    Vector3f q = s.cross(edge1);
    v = f * ray.direction.dot(q);

    if (v < 0.0f || u + v > 1.0f) return false;

    t = f * edge2.dot(q);

    return t > EPSILON && t >= ray.t_min && t <= ray.t_max;
}
```

### 16.3.3 å…‰çº¿-å¹³é¢ç›¸äº¤

**æ•°å­¦æ¨å¯¼**ï¼š
å¹³é¢æ–¹ç¨‹ï¼š$\mathbf{n} \cdot (\mathbf{p} - \mathbf{p}_0) = 0$
å…‰çº¿æ–¹ç¨‹ï¼š$\mathbf{p} = \mathbf{o} + t\mathbf{d}$

ä»£å…¥ï¼š$\mathbf{n} \cdot (\mathbf{o} + t\mathbf{d} - \mathbf{p}_0) = 0$
è§£å¾—ï¼š$t = \frac{\mathbf{n} \cdot (\mathbf{p}_0 - \mathbf{o})}{\mathbf{n} \cdot \mathbf{d}}$

**ä»£ç å®ç°**ï¼š

```cpp
bool intersect_plane(const Ray& ray, const Vector3f& point, const Vector3f& normal,
                    float& t) {
    float denom = normal.dot(ray.direction);
    if (std::abs(denom) < EPSILON) return false;  // å…‰çº¿å¹³è¡Œäºå¹³é¢

    t = normal.dot(point - ray.origin) / denom;
    return t >= ray.t_min && t <= ray.t_max;
}
```

---

## å…‰çº¿-å‡ ä½•ä½“ç›¸äº¤ç®—æ³•

## 17.1 åŒ…å›´ç›’ç›¸äº¤ç®—æ³•

### 17.1.1 è½´å¯¹é½åŒ…å›´ç›’ï¼ˆAABBï¼‰çš„æ•°å­¦ç†è®º

#### AABBçš„æ•°å­¦å®šä¹‰

**è½´å¯¹é½åŒ…å›´ç›’**ï¼š
AABBæ˜¯ä¸€ä¸ªä¸åæ ‡è½´å¹³è¡Œçš„é•¿æ–¹ä½“ï¼Œå¯ä»¥ç”¨ä¸¤ä¸ªå¯¹è§’é¡¶ç‚¹å®šä¹‰ï¼š
$$\text{AABB} = \{(x,y,z) : x_{min} \leq x \leq x_{max}, y_{min} \leq y \leq y_{max}, z_{min} \leq z \leq z_{max}\}$$

#### å…‰çº¿-AABBç›¸äº¤çš„æ•°å­¦æ¨å¯¼

**å…‰çº¿å‚æ•°æ–¹ç¨‹**ï¼š
$$\mathbf{r}(t) = \mathbf{o} + t\mathbf{d}$$

**å¹³é¢ç›¸äº¤è®¡ç®—**ï¼š
å¯¹äºæ¯ä¸ªåæ ‡è½´ $i$ï¼Œå…‰çº¿ä¸ä¸¤ä¸ªå¹³é¢ $x_i = x_{min}$ å’Œ $x_i = x_{max}$ çš„ç›¸äº¤å‚æ•°ä¸ºï¼š
$$t_{1i} = \frac{x_{min} - o_i}{d_i}, \quad t_{2i} = \frac{x_{max} - o_i}{d_i}$$

**è¿‘è¿œå¹³é¢ç¡®å®š**ï¼š
$$t_{near,i} = \min(t_{1i}, t_{2i}), \quad t_{far,i} = \max(t_{1i}, t_{2i})$$

**ç›¸äº¤æ¡ä»¶**ï¼š
å…‰çº¿ä¸AABBç›¸äº¤å½“ä¸”ä»…å½“ï¼š
$$t_{enter} = \max(t_{near,x}, t_{near,y}, t_{near,z}) \leq t_{exit} = \min(t_{far,x}, t_{far,y}, t_{far,z})$$

#### æ•°å€¼ç¨³å®šæ€§è€ƒè™‘

**é™¤é›¶å¤„ç†**ï¼š
å½“ $d_i = 0$ æ—¶ï¼Œå…‰çº¿å¹³è¡Œäºç¬¬ $i$ è½´ï¼š

- å¦‚æœ $o_i < x_{min}$ æˆ– $o_i > x_{max}$ï¼Œåˆ™æ— ç›¸äº¤
- å¦åˆ™ï¼Œ$t_{near,i} = -\infty$ï¼Œ$t_{far,i} = +\infty$

#### ä¼˜åŒ–çš„AABBç›¸äº¤å®ç°

```cpp
struct AABB {
    Vector3f min_point, max_point;

    AABB() : min_point(Vector3f::Constant(INFINITY)),
             max_point(Vector3f::Constant(-INFINITY)) {}

    AABB(const Vector3f& min_p, const Vector3f& max_p)
        : min_point(min_p), max_point(max_p) {}

    // è®¡ç®—è¡¨é¢ç§¯ï¼ˆç”¨äºSAHï¼‰
    float surface_area() const {
        Vector3f extent = max_point - min_point;
        return 2.0f * (extent.x() * extent.y() +
                      extent.y() * extent.z() +
                      extent.z() * extent.x());
    }

    // è®¡ç®—ä½“ç§¯
    float volume() const {
        Vector3f extent = max_point - min_point;
        return extent.x() * extent.y() * extent.z();
    }

    void expand(const Vector3f& point) {
        min_point = min_point.cwiseMin(point);
        max_point = max_point.cwiseMax(point);
    }
};

bool intersect_aabb_robust(const Ray& ray, const AABB& box, float& t_min, float& t_max) {
    t_min = ray.t_min;
    t_max = ray.t_max;

    for (int i = 0; i < 3; ++i) {
        if (std::abs(ray.direction[i]) < 1e-8f) {
            // å…‰çº¿å¹³è¡Œäºç¬¬iè½´
            if (ray.origin[i] < box.min_point[i] || ray.origin[i] > box.max_point[i]) {
                return false;
            }
        } else {
            float inv_dir = 1.0f / ray.direction[i];
            float t1 = (box.min_point[i] - ray.origin[i]) * inv_dir;
            float t2 = (box.max_point[i] - ray.origin[i]) * inv_dir;

            if (t1 > t2) std::swap(t1, t2);

            t_min = std::max(t_min, t1);
            t_max = std::min(t_max, t2);

            if (t_min > t_max) return false;
        }
    }

    return true;
}
```

### 17.1.2 æœ‰å‘åŒ…å›´ç›’ï¼ˆOBBï¼‰

**OBBå®šä¹‰**ï¼š

```cpp
struct OBB {
    Vector3f center;
    Vector3f axes[3];      // ä¸‰ä¸ªæ­£äº¤è½´
    Vector3f half_extents; // æ²¿å„è½´çš„åŠé•¿åº¦

    AABB to_aabb() const {
        Vector3f extent = Vector3f::Zero();
        for (int i = 0; i < 3; ++i) {
            extent += axes[i].cwiseAbs() * half_extents[i];
        }
        return AABB(center - extent, center + extent);
    }
};
```

## 17.2 å¤æ‚å‡ ä½•ä½“ç›¸äº¤

### 17.2.1 å…‰çº¿-ç½‘æ ¼ç›¸äº¤

**ç½‘æ ¼ç›¸äº¤ç®—æ³•**ï¼š

```cpp
class TriangleMesh {
private:
    std::vector<Vector3f> vertices;
    std::vector<Vector3i> triangles;
    AABB bounding_box;

public:
    bool intersect(const Ray& ray, Intersection& hit) {
        if (!intersect_aabb(ray, bounding_box)) return false;

        bool hit_found = false;
        float closest_t = ray.t_max;

        for (const auto& triangle : triangles) {
            Vector3f v0 = vertices[triangle[0]];
            Vector3f v1 = vertices[triangle[1]];
            Vector3f v2 = vertices[triangle[2]];

            float t, u, v;
            if (intersect_triangle(ray, v0, v1, v2, t, u, v) && t < closest_t) {
                closest_t = t;
                hit.t = t;
                hit.position = ray.at(t);
                hit.normal = (v1 - v0).cross(v2 - v0).normalized();
                hit.uv = Vector2f(u, v);
                hit_found = true;
            }
        }

        return hit_found;
    }
};
```

### 17.2.2 å…‰çº¿-éšå¼æ›²é¢ç›¸äº¤

**éšå¼æ›²é¢å®šä¹‰**ï¼šf(x, y, z) = 0

**ç‰›é¡¿è¿­ä»£æ³•æ±‚äº¤**ï¼š

```cpp
bool intersect_implicit_surface(const Ray& ray,
                               std::function<float(Vector3f)> f,
                               std::function<Vector3f(Vector3f)> gradient,
                               float& t) {
    float t_current = ray.t_min;
    const int max_iterations = 100;
    const float tolerance = 1e-6f;

    for (int i = 0; i < max_iterations; ++i) {
        Vector3f point = ray.at(t_current);
        float value = f(point);

        if (std::abs(value) < tolerance) {
            t = t_current;
            return true;
        }

        Vector3f grad = gradient(point);
        float denominator = grad.dot(ray.direction);

        if (std::abs(denominator) < tolerance) break;

        t_current -= value / denominator;

        if (t_current < ray.t_min || t_current > ray.t_max) break;
    }

    return false;
}
```

---

## ç©ºé—´åŠ é€Ÿæ•°æ®ç»“æ„

## 18.1 BVHï¼ˆå±‚æ¬¡åŒ…å›´ç›’ï¼‰

### 18.1.1 BVHçš„æ•°å­¦ç†è®ºåŸºç¡€

#### å±‚æ¬¡åŒ…å›´ç›’çš„æ•°å­¦åŸç†

**æ ¸å¿ƒæ€æƒ³**ï¼š
BVHï¼ˆBounding Volume Hierarchyï¼‰é€šè¿‡é€’å½’åœ°å°†å‡ ä½•å¯¹è±¡åˆ†ç»„å¹¶ç”¨åŒ…å›´ç›’åŒ…å›´ï¼Œæ„å»ºä¸€ä¸ªäºŒå‰æ ‘ç»“æ„ï¼Œä»è€Œå®ç°å¯¹å…‰çº¿-åœºæ™¯ç›¸äº¤æµ‹è¯•çš„åŠ é€Ÿã€‚

**æ•°å­¦åŸºç¡€**ï¼š
è®¾åœºæ™¯ä¸­æœ‰ $n$ ä¸ªå‡ ä½•å¯¹è±¡ $\{O_1, O_2, \ldots, O_n\}$ï¼ŒBVHå°†å…¶ç»„ç»‡æˆä¸€ä¸ªäºŒå‰æ ‘ $T$ï¼Œæ»¡è¶³ï¼š

1. **åŒ…å›´æ€§è´¨**ï¼šæ¯ä¸ªå†…éƒ¨èŠ‚ç‚¹çš„åŒ…å›´ç›’åŒ…å«å…¶æ‰€æœ‰å­èŠ‚ç‚¹çš„åŒ…å›´ç›’
2. **åˆ†ç¦»æ€§è´¨**ï¼šå¶å­èŠ‚ç‚¹åŒ…å«çš„å‡ ä½•å¯¹è±¡åœ¨ç©ºé—´ä¸Šç›¸å¯¹é›†ä¸­
3. **å¹³è¡¡æ€§è´¨**ï¼šæ ‘çš„æ·±åº¦å°½å¯èƒ½å°ï¼Œç†æƒ³æƒ…å†µä¸‹ä¸º $O(\log n)$

#### ç›¸äº¤æµ‹è¯•çš„å¤æ‚åº¦åˆ†æ

**æœ´ç´ æ–¹æ³•**ï¼š
å¯¹äºæ¯æ¡å…‰çº¿ï¼Œéœ€è¦ä¸æ‰€æœ‰ $n$ ä¸ªå¯¹è±¡è¿›è¡Œç›¸äº¤æµ‹è¯•ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ã€‚

**BVHåŠ é€Ÿ**ï¼š
åˆ©ç”¨åŒ…å›´ç›’çš„å±‚æ¬¡ç»“æ„ï¼Œå¹³å‡æ—¶é—´å¤æ‚åº¦é™ä½åˆ° $O(\log n)$ï¼š

- å¦‚æœå…‰çº¿ä¸èŠ‚ç‚¹çš„åŒ…å›´ç›’ä¸ç›¸äº¤ï¼Œåˆ™å¯ä»¥è·³è¿‡æ•´ä¸ªå­æ ‘
- åªæœ‰å½“å…‰çº¿ä¸åŒ…å›´ç›’ç›¸äº¤æ—¶ï¼Œæ‰éœ€è¦é€’å½’æµ‹è¯•å­èŠ‚ç‚¹

**BVHèŠ‚ç‚¹å®šä¹‰**ï¼š

```cpp
struct BVHBuildNode {
    AABB bounds;
    BVHBuildNode* left;
    BVHBuildNode* right;
    Object* object;        // å¶å­èŠ‚ç‚¹å­˜å‚¨å¯¹è±¡
    int split_axis;        // åˆ†å‰²è½´
    int first_prim_offset; // ç¬¬ä¸€ä¸ªå›¾å…ƒçš„åç§»
    int n_primitives;      // å›¾å…ƒæ•°é‡

    void init_leaf(int first, int n, const AABB& b) {
        first_prim_offset = first;
        n_primitives = n;
        bounds = b;
        left = right = nullptr;
    }

    void init_interior(int axis, BVHBuildNode* c0, BVHBuildNode* c1) {
        left = c0;
        right = c1;
        bounds = AABB();
        bounds.expand(c0->bounds);
        bounds.expand(c1->bounds);
        split_axis = axis;
        n_primitives = 0;
    }
};
```

### 18.1.2 BVHæ„å»ºç®—æ³•çš„æ•°å­¦ç†è®º

#### åˆ†å‰²ç­–ç•¥çš„æ•°å­¦åˆ†æ

**1. ä¸­ç‚¹åˆ†å‰²ï¼ˆMidpoint Splitï¼‰**ï¼š
é€‰æ‹©æœ€é•¿è½´çš„ä¸­ç‚¹è¿›è¡Œåˆ†å‰²ï¼š
$$x_{split} = \frac{x_{min} + x_{max}}{2}$$

**ä¼˜ç‚¹**ï¼šç®€å•å¿«é€Ÿï¼Œä¿è¯æ ‘çš„å¹³è¡¡æ€§
**ç¼ºç‚¹**ï¼šå¯èƒ½äº§ç”Ÿç©ºçš„å­æ ‘æˆ–ä¸å‡åŒ€çš„åˆ†å¸ƒ

**2. è¡¨é¢ç§¯å¯å‘å¼ï¼ˆSAH - Surface Area Heuristicï¼‰**ï¼š
åŸºäºæœŸæœ›ç›¸äº¤æµ‹è¯•æ¬¡æ•°çš„æœ€ä¼˜åŒ–åˆ†å‰²ç­–ç•¥ã€‚

#### SAHçš„æ•°å­¦æ¨å¯¼

**æœŸæœ›ç›¸äº¤æµ‹è¯•æ¬¡æ•°**ï¼š
å¯¹äºä¸€ä¸ªåŒ…å›´ç›’ $B$ï¼Œå…¶å­èŠ‚ç‚¹ $B_L$ å’Œ $B_R$ï¼Œå…‰çº¿ä¸è¯¥èŠ‚ç‚¹ç›¸äº¤çš„æœŸæœ›æµ‹è¯•æ¬¡æ•°ä¸ºï¼š
$$C(B) = C_{traversal} + P(B_L|B) \cdot C(B_L) + P(B_R|B) \cdot C(B_R)$$

å…¶ä¸­ï¼š

- $C_{traversal}$ æ˜¯éå†èŠ‚ç‚¹çš„å›ºå®šå¼€é”€
- $P(B_L|B)$ æ˜¯å…‰çº¿ä¸ $B$ ç›¸äº¤æ—¶ä¹Ÿä¸ $B_L$ ç›¸äº¤çš„æ¡ä»¶æ¦‚ç‡
- $C(B_L)$ æ˜¯å·¦å­æ ‘çš„æœŸæœ›æµ‹è¯•æ¬¡æ•°

**å‡ ä½•æ¦‚ç‡å‡è®¾**ï¼š
å‡è®¾å…‰çº¿æ–¹å‘å‡åŒ€åˆ†å¸ƒï¼Œåˆ™ï¼š
$$P(B_L|B) = \frac{SA(B_L)}{SA(B)}$$

å…¶ä¸­ $SA(B)$ æ˜¯åŒ…å›´ç›’ $B$ çš„è¡¨é¢ç§¯ã€‚

**SAHä»£ä»·å‡½æ•°**ï¼š
$$SAH(split) = C_{traversal} + \frac{SA(B_L)}{SA(B)} \cdot N_L \cdot C_{intersect} + \frac{SA(B_R)}{SA(B)} \cdot N_R \cdot C_{intersect}$$

å…¶ä¸­ $N_L$ å’Œ $N_R$ åˆ†åˆ«æ˜¯å·¦å³å­æ ‘çš„å›¾å…ƒæ•°é‡ã€‚

#### åŸºäºGAMES101é¡¹ç›®çš„å®ç°

```cpp
BVHBuildNode* BVHAccel::recursiveBuild(std::vector<Object*> objects) {
    BVHBuildNode* node = new BVHBuildNode();

    // è®¡ç®—æ‰€æœ‰å¯¹è±¡çš„åŒ…å›´ç›’
    AABB bounds;
    for (int i = 0; i < objects.size(); ++i) {
        bounds.expand(objects[i]->getBounds());
    }

    if (objects.size() == 1) {
        // åˆ›å»ºå¶å­èŠ‚ç‚¹
        node->bounds = objects[0]->getBounds();
        node->object = objects[0];
        node->left = nullptr;
        node->right = nullptr;
        return node;
    } else if (objects.size() == 2) {
        node->left = recursiveBuild(std::vector{objects[0]});
        node->right = recursiveBuild(std::vector{objects[1]});
        node->bounds = AABB();
        node->bounds.expand(node->left->bounds);
        node->bounds.expand(node->right->bounds);
        return node;
    } else {
        // é€‰æ‹©åˆ†å‰²è½´ï¼ˆæœ€é•¿è½´ï¼‰
        AABB centroid_bounds;
        for (int i = 0; i < objects.size(); ++i) {
            centroid_bounds.expand(objects[i]->getBounds().centroid());
        }

        int dim = centroid_bounds.max_extent();

        switch (splitMethod) {
            case SplitMethod::NAIVE: {
                // ä¸­ç‚¹åˆ†å‰²
                std::sort(objects.begin(), objects.end(), [dim](const auto& a, const auto& b) {
                    return a->getBounds().centroid()[dim] < b->getBounds().centroid()[dim];
                });

                auto beginning = objects.begin();
                auto middling = objects.begin() + (objects.size() / 2);
                auto ending = objects.end();

                auto leftshapes = std::vector<Object*>(beginning, middling);
                auto rightshapes = std::vector<Object*>(middling, ending);

                assert(objects.size() == (leftshapes.size() + rightshapes.size()));

                node->left = recursiveBuild(leftshapes);
                node->right = recursiveBuild(rightshapes);
                break;
            }
            case SplitMethod::SAH: {
                // SAHåˆ†å‰²ï¼ˆè¡¨é¢ç§¯å¯å‘å¼ï¼‰
                // å®ç°SAHç®—æ³•...
                break;
            }
        }

        node->bounds = AABB();
        node->bounds.expand(node->left->bounds);
        node->bounds.expand(node->right->bounds);
    }

    return node;
}
```

### 18.1.3 BVHéå†ç®—æ³•

```cpp
Intersection BVHAccel::getIntersection(BVHBuildNode* node, const Ray& ray) const {
    Intersection isect;
    if (!node) return isect;

    // æ£€æŸ¥å…‰çº¿æ˜¯å¦ä¸èŠ‚ç‚¹åŒ…å›´ç›’ç›¸äº¤
    Vector3f inv_dir = Vector3f(1.0f / ray.direction.x(),
                               1.0f / ray.direction.y(),
                               1.0f / ray.direction.z());
    std::array<int, 3> dir_is_neg = {
        ray.direction.x() > 0 ? 0 : 1,
        ray.direction.y() > 0 ? 0 : 1,
        ray.direction.z() > 0 ? 0 : 1
    };

    if (!node->bounds.intersect_p(ray, inv_dir, dir_is_neg)) {
        return isect;
    }

    // å¶å­èŠ‚ç‚¹ï¼šä¸å¯¹è±¡æ±‚äº¤
    if (node->left == nullptr && node->right == nullptr) {
        return node->object->getIntersection(ray);
    }

    // å†…éƒ¨èŠ‚ç‚¹ï¼šé€’å½’éå†å­èŠ‚ç‚¹
    Intersection hit1 = getIntersection(node->left, ray);
    Intersection hit2 = getIntersection(node->right, ray);

    return hit1.distance < hit2.distance ? hit1 : hit2;
}
```

## 18.2 SAHï¼ˆè¡¨é¢ç§¯å¯å‘å¼ï¼‰

### 18.2.1 SAHç†è®ºåŸºç¡€

**æˆæœ¬å‡½æ•°**ï¼š

```
Cost = C_trav + P_left Ã— N_left Ã— C_isect + P_right Ã— N_right Ã— C_isect
```

å…¶ä¸­ï¼š

- C_travï¼šéå†æˆæœ¬
- P_left/P_rightï¼šå…‰çº¿å‡»ä¸­å·¦/å³å­æ ‘çš„æ¦‚ç‡
- N_left/N_rightï¼šå·¦/å³å­æ ‘çš„å›¾å…ƒæ•°é‡
- C_isectï¼šç›¸äº¤æµ‹è¯•æˆæœ¬

**æ¦‚ç‡è®¡ç®—**ï¼š

```
P_left = SA_left / SA_parent
P_right = SA_right / SA_parent
```

### 18.2.2 SAHå®ç°

```cpp
struct SAHBucket {
    int count = 0;
    AABB bounds;
};

float evaluate_sah(const std::vector<Object*>& objects, int split_axis, float split_pos) {
    AABB left_bounds, right_bounds;
    int left_count = 0, right_count = 0;

    for (const auto& obj : objects) {
        Vector3f centroid = obj->getBounds().centroid();
        if (centroid[split_axis] < split_pos) {
            left_bounds.expand(obj->getBounds());
            left_count++;
        } else {
            right_bounds.expand(obj->getBounds());
            right_count++;
        }
    }

    float cost = 1.0f + // éå†æˆæœ¬
                (left_count * left_bounds.surface_area() +
                 right_count * right_bounds.surface_area()) /
                parent_bounds.surface_area();

    return cost;
}

int find_best_split_sah(const std::vector<Object*>& objects) {
    const int n_buckets = 12;
    float min_cost = INFINITY;
    int best_split = -1;

    for (int dim = 0; dim < 3; ++dim) {
        // åˆ›å»ºæ¡¶
        std::vector<SAHBucket> buckets(n_buckets);

        // å°†å¯¹è±¡åˆ†é…åˆ°æ¡¶ä¸­
        for (const auto& obj : objects) {
            int bucket = n_buckets * centroid_bounds.offset(obj->getBounds().centroid())[dim];
            bucket = std::min(bucket, n_buckets - 1);
            buckets[bucket].count++;
            buckets[bucket].bounds.expand(obj->getBounds());
        }

        // è®¡ç®—æ¯ä¸ªåˆ†å‰²ä½ç½®çš„æˆæœ¬
        for (int i = 0; i < n_buckets - 1; ++i) {
            AABB b0, b1;
            int count0 = 0, count1 = 0;

            for (int j = 0; j <= i; ++j) {
                b0.expand(buckets[j].bounds);
                count0 += buckets[j].count;
            }

            for (int j = i + 1; j < n_buckets; ++j) {
                b1.expand(buckets[j].bounds);
                count1 += buckets[j].count;
            }

            float cost = 1.0f + (count0 * b0.surface_area() + count1 * b1.surface_area()) /
                         bounds.surface_area();

            if (cost < min_cost) {
                min_cost = cost;
                best_split = i;
            }
        }
    }

    return best_split;
}
```

## 18.3 å…¶ä»–åŠ é€Ÿç»“æ„

### 18.3.1 å…«å‰æ ‘ï¼ˆOctreeï¼‰

**åŸºæœ¬åŸç†**ï¼šé€’å½’åœ°å°†3Dç©ºé—´åˆ†å‰²ä¸º8ä¸ªå­ç«‹æ–¹ä½“

**æ•°æ®ç»“æ„å®šä¹‰**ï¼š

```cpp
class Octree {
private:
    struct OctreeNode {
        AABB bounds;
        std::vector<Object*> objects;
        std::array<std::unique_ptr<OctreeNode>, 8> children;
        bool is_leaf;

        OctreeNode(const AABB& b) : bounds(b), is_leaf(true) {}
    };

    std::unique_ptr<OctreeNode> root;
    int max_depth;
    int max_objects_per_node;

public:
    void build(const std::vector<Object*>& objects, const AABB& scene_bounds) {
        root = std::make_unique<OctreeNode>(scene_bounds);
        build_recursive(root.get(), objects, 0);
    }

private:
    void build_recursive(OctreeNode* node, const std::vector<Object*>& objects, int depth) {
        if (depth >= max_depth || objects.size() <= max_objects_per_node) {
            node->objects = objects;
            return;
        }

        // åˆ›å»º8ä¸ªå­èŠ‚ç‚¹
        Vector3f center = node->bounds.center();
        Vector3f min_pt = node->bounds.min_point;
        Vector3f max_pt = node->bounds.max_point;

        // 8ä¸ªå­ç«‹æ–¹ä½“çš„åŒ…å›´ç›’
        std::array<AABB, 8> child_bounds = {
            AABB(Vector3f(min_pt.x(), min_pt.y(), min_pt.z()),
                 Vector3f(center.x(), center.y(), center.z())),  // 000
            AABB(Vector3f(center.x(), min_pt.y(), min_pt.z()),
                 Vector3f(max_pt.x(), center.y(), center.z())),  // 100
            AABB(Vector3f(min_pt.x(), center.y(), min_pt.z()),
                 Vector3f(center.x(), max_pt.y(), center.z())),  // 010
            AABB(Vector3f(center.x(), center.y(), min_pt.z()),
                 Vector3f(max_pt.x(), max_pt.y(), center.z())),  // 110
            AABB(Vector3f(min_pt.x(), min_pt.y(), center.z()),
                 Vector3f(center.x(), center.y(), max_pt.z())),  // 001
            AABB(Vector3f(center.x(), min_pt.y(), center.z()),
                 Vector3f(max_pt.x(), center.y(), max_pt.z())),  // 101
            AABB(Vector3f(min_pt.x(), center.y(), center.z()),
                 Vector3f(center.x(), max_pt.y(), max_pt.z())),  // 011
            AABB(Vector3f(center.x(), center.y(), center.z()),
                 Vector3f(max_pt.x(), max_pt.y(), max_pt.z()))   // 111
        };

        // å°†å¯¹è±¡åˆ†é…åˆ°å­èŠ‚ç‚¹
        std::array<std::vector<Object*>, 8> child_objects;
        for (const auto& obj : objects) {
            for (int i = 0; i < 8; ++i) {
                if (child_bounds[i].intersects(obj->getBounds())) {
                    child_objects[i].push_back(obj);
                }
            }
        }

        // é€’å½’æ„å»ºéç©ºå­èŠ‚ç‚¹
        node->is_leaf = false;
        for (int i = 0; i < 8; ++i) {
            if (!child_objects[i].empty()) {
                node->children[i] = std::make_unique<OctreeNode>(child_bounds[i]);
                build_recursive(node->children[i].get(), child_objects[i], depth + 1);
            }
        }
    }

public:
    Intersection intersect(const Ray& ray) const {
        return intersect_recursive(root.get(), ray);
    }

private:
    Intersection intersect_recursive(OctreeNode* node, const Ray& ray) const {
        if (!node || !node->bounds.intersect(ray)) {
            return Intersection();
        }

        if (node->is_leaf) {
            Intersection closest_hit;
            float closest_t = INFINITY;

            for (const auto& obj : node->objects) {
                Intersection hit = obj->getIntersection(ray);
                if (hit.happened && hit.distance < closest_t) {
                    closest_hit = hit;
                    closest_t = hit.distance;
                }
            }
            return closest_hit;
        }

        // éå†å­èŠ‚ç‚¹
        Intersection closest_hit;
        float closest_t = INFINITY;

        for (const auto& child : node->children) {
            if (child) {
                Intersection hit = intersect_recursive(child.get(), ray);
                if (hit.happened && hit.distance < closest_t) {
                    closest_hit = hit;
                    closest_t = hit.distance;
                }
            }
        }

        return closest_hit;
    }
};
```

**ä¼˜ç¼ºç‚¹åˆ†æ**ï¼š

- âœ… **ä¼˜ç‚¹**ï¼šç©ºé—´åˆ†å‰²å‡åŒ€ï¼Œæ˜“äºç†è§£å’Œå®ç°
- âŒ **ç¼ºç‚¹**ï¼šå¯¹è±¡å¯èƒ½è·¨è¶Šå¤šä¸ªèŠ‚ç‚¹ï¼Œå­˜å‚¨å†—ä½™

### 18.3.2 kDæ ‘ï¼ˆk-Dimensional Treeï¼‰

**åŸºæœ¬åŸç†**ï¼šæ²¿åæ ‡è½´äº¤æ›¿åˆ†å‰²ç©ºé—´

**æ•°æ®ç»“æ„**ï¼š

```cpp
struct KDNode {
    AABB bounds;
    int split_axis;        // åˆ†å‰²è½´ï¼š0=x, 1=y, 2=z
    float split_value;     // åˆ†å‰²ä½ç½®

    std::unique_ptr<KDNode> left;   // å°äºsplit_valueçš„å­æ ‘
    std::unique_ptr<KDNode> right;  // å¤§äºç­‰äºsplit_valueçš„å­æ ‘

    std::vector<Object*> objects;   // å¶å­èŠ‚ç‚¹å­˜å‚¨çš„å¯¹è±¡
    bool is_leaf;
};

class KDTree {
private:
    std::unique_ptr<KDNode> root;
    int max_depth;
    int max_objects_per_leaf;

public:
    void build(const std::vector<Object*>& objects, const AABB& bounds) {
        root = build_recursive(objects, bounds, 0);
    }

private:
    std::unique_ptr<KDNode> build_recursive(const std::vector<Object*>& objects,
                                           const AABB& bounds, int depth) {
        auto node = std::make_unique<KDNode>();
        node->bounds = bounds;

        // ç»ˆæ­¢æ¡ä»¶
        if (depth >= max_depth || objects.size() <= max_objects_per_leaf) {
            node->is_leaf = true;
            node->objects = objects;
            return node;
        }

        // é€‰æ‹©åˆ†å‰²è½´ï¼ˆå¾ªç¯é€‰æ‹©æˆ–åŸºäºæœ€é•¿è½´ï¼‰
        int axis = depth % 3;  // æˆ–è€…é€‰æ‹©boundsçš„æœ€é•¿è½´

        // è®¡ç®—åˆ†å‰²ä½ç½®ï¼ˆä¸­ä½æ•°æˆ–ä¸­ç‚¹ï¼‰
        std::vector<float> centroids;
        for (const auto& obj : objects) {
            centroids.push_back(obj->getBounds().center()[axis]);
        }

        std::sort(centroids.begin(), centroids.end());
        float split_pos = centroids[centroids.size() / 2];  // ä¸­ä½æ•°

        node->split_axis = axis;
        node->split_value = split_pos;
        node->is_leaf = false;

        // åˆ†å‰²å¯¹è±¡
        std::vector<Object*> left_objects, right_objects;
        for (const auto& obj : objects) {
            float centroid = obj->getBounds().center()[axis];
            if (centroid < split_pos) {
                left_objects.push_back(obj);
            } else {
                right_objects.push_back(obj);
            }
        }

        // è®¡ç®—å­èŠ‚ç‚¹åŒ…å›´ç›’
        AABB left_bounds = bounds, right_bounds = bounds;
        left_bounds.max_point[axis] = split_pos;
        right_bounds.min_point[axis] = split_pos;

        // é€’å½’æ„å»ºå­æ ‘
        if (!left_objects.empty()) {
            node->left = build_recursive(left_objects, left_bounds, depth + 1);
        }
        if (!right_objects.empty()) {
            node->right = build_recursive(right_objects, right_bounds, depth + 1);
        }

        return node;
    }
};
```

**éå†ç®—æ³•**ï¼š

```cpp
Intersection traverse_kd_tree(KDNode* node, const Ray& ray) {
    if (!node || !node->bounds.intersect(ray)) {
        return Intersection();
    }

    if (node->is_leaf) {
        // ä¸å¶å­èŠ‚ç‚¹ä¸­çš„æ‰€æœ‰å¯¹è±¡æ±‚äº¤
        Intersection closest_hit;
        float closest_t = INFINITY;

        for (const auto& obj : node->objects) {
            Intersection hit = obj->getIntersection(ray);
            if (hit.happened && hit.distance < closest_t) {
                closest_hit = hit;
                closest_t = hit.distance;
            }
        }
        return closest_hit;
    }

    // ç¡®å®šå…‰çº¿ä¸åˆ†å‰²å¹³é¢çš„å…³ç³»
    float t_split = (node->split_value - ray.origin[node->split_axis]) /
                    ray.direction[node->split_axis];

    KDNode* first_child, *second_child;
    if (ray.origin[node->split_axis] < node->split_value) {
        first_child = node->left.get();
        second_child = node->right.get();
    } else {
        first_child = node->right.get();
        second_child = node->left.get();
    }

    // éå†ç¬¬ä¸€ä¸ªå­èŠ‚ç‚¹
    Intersection hit = traverse_kd_tree(first_child, ray);

    // å¦‚æœæ‰¾åˆ°äº¤ç‚¹ä¸”åœ¨åˆ†å‰²å¹³é¢ä¹‹å‰ï¼Œç›´æ¥è¿”å›
    if (hit.happened && hit.distance < t_split) {
        return hit;
    }

    // å¦åˆ™éå†ç¬¬äºŒä¸ªå­èŠ‚ç‚¹
    Intersection hit2 = traverse_kd_tree(second_child, ray);

    // è¿”å›æœ€è¿‘çš„äº¤ç‚¹
    if (hit2.happened && (!hit.happened || hit2.distance < hit.distance)) {
        return hit2;
    }
    return hit;
}
```

### 18.3.3 åŠ é€Ÿç»“æ„æ€§èƒ½å¯¹æ¯”

**ç†è®ºå¤æ‚åº¦**ï¼š

| ç»“æ„    | æ„å»ºæ—¶é—´   | å†…å­˜æ¶ˆè€—     | æŸ¥è¯¢æ—¶é—´ | é€‚ç”¨åœºæ™¯         |
| ------- | ---------- | ------------ | -------- | ---------------- |
| BVH     | O(n log n) | O(n)         | O(log n) | é€šç”¨ï¼ŒåŠ¨æ€åœºæ™¯   |
| Octree  | O(n log n) | O(n)         | O(log n) | å‡åŒ€åˆ†å¸ƒçš„åœºæ™¯   |
| kD-Tree | O(n log n) | O(n)         | O(log n) | é™æ€åœºæ™¯ï¼Œç‚¹æŸ¥è¯¢ |
| Grid    | O(n)       | O(n + cells) | O(1)     | å‡åŒ€å¯†åº¦åœºæ™¯     |

**å®é™…æ€§èƒ½æµ‹è¯•**ï¼š

```cpp
struct PerformanceTest {
    std::string structure_name;
    double build_time;
    double query_time;
    size_t memory_usage;
    int ray_count;

    void print_results() const {
        std::cout << structure_name << ":\n";
        std::cout << "  æ„å»ºæ—¶é—´: " << build_time << "ms\n";
        std::cout << "  å¹³å‡æŸ¥è¯¢æ—¶é—´: " << query_time / ray_count << "ms\n";
        std::cout << "  å†…å­˜ä½¿ç”¨: " << memory_usage / 1024.0 / 1024.0 << "MB\n";
    }
};

void benchmark_acceleration_structures(const std::vector<Object*>& objects,
                                     const std::vector<Ray>& test_rays) {
    std::vector<PerformanceTest> results;

    // æµ‹è¯•BVH
    {
        auto start = std::chrono::high_resolution_clock::now();
        BVHAccel bvh(objects);
        auto build_end = std::chrono::high_resolution_clock::now();

        auto query_start = std::chrono::high_resolution_clock::now();
        for (const auto& ray : test_rays) {
            bvh.Intersect(ray);
        }
        auto query_end = std::chrono::high_resolution_clock::now();

        PerformanceTest test;
        test.structure_name = "BVH";
        test.build_time = std::chrono::duration<double, std::milli>(build_end - start).count();
        test.query_time = std::chrono::duration<double, std::milli>(query_end - query_start).count();
        test.ray_count = test_rays.size();
        results.push_back(test);
    }

    // ç±»ä¼¼åœ°æµ‹è¯•å…¶ä»–ç»“æ„...

    // è¾“å‡ºç»“æœ
    for (const auto& result : results) {
        result.print_results();
    }
}
```

---

## è’™ç‰¹å¡æ´›æ–¹æ³•ä¸ç§¯åˆ†

## 19.1 è’™ç‰¹å¡æ´›ç§¯åˆ†ç†è®º

### 19.1.1 è’™ç‰¹å¡æ´›ç§¯åˆ†çš„æ•°å­¦åŸºç¡€

#### åŸºæœ¬è’™ç‰¹å¡æ´›ä¼°è®¡

**ç§¯åˆ†ä¼°è®¡å…¬å¼**ï¼š
å¯¹äºä¸€ç»´ç§¯åˆ† $\int_a^b f(x) dx$ï¼Œè’™ç‰¹å¡æ´›ä¼°è®¡ä¸ºï¼š
$$\int_a^b f(x) dx \approx \frac{b-a}{N} \sum_{i=1}^N f(X_i)$$

å…¶ä¸­ $X_i$ æ˜¯åœ¨åŒºé—´ $[a,b]$ ä¸Šå‡åŒ€åˆ†å¸ƒçš„éšæœºæ ·æœ¬ã€‚

**å¤šç»´ç§¯åˆ†æ¨å¹¿**ï¼š
å¯¹äº $d$ ç»´ç§¯åˆ†ï¼š
$$\int_{\Omega} f(\mathbf{x}) d\mathbf{x} \approx \frac{|\Omega|}{N} \sum_{i=1}^N f(\mathbf{X}_i)$$

å…¶ä¸­ $|\Omega|$ æ˜¯ç§¯åˆ†åŸŸçš„ä½“ç§¯ã€‚

#### ç†è®ºä¿è¯

**å¼ºå¤§æ•°å®šå¾‹**ï¼š
$$\lim_{N \to \infty} \frac{1}{N} \sum_{i=1}^N f(X_i) = E[f(X)] = \int f(x) p(x) dx \quad \text{a.s.}$$

**ä¸­å¿ƒæé™å®šç†**ï¼š
$$\sqrt{N}\left(\frac{1}{N} \sum_{i=1}^N f(X_i) - E[f(X)]\right) \xrightarrow{d} \mathcal{N}(0, \sigma^2)$$

å…¶ä¸­ $\sigma^2 = \text{Var}[f(X)]$ã€‚

**æ”¶æ•›é€Ÿåº¦**ï¼š
æ ‡å‡†è¯¯å·®ä¸º $O(N^{-1/2})$ï¼Œ**ä¸ç»´åº¦æ— å…³**ï¼Œè¿™æ˜¯è’™ç‰¹å¡æ´›æ–¹æ³•çš„é‡è¦ä¼˜åŠ¿ã€‚

### 19.1.2 é‡è¦æ€§é‡‡æ ·ç†è®º

#### é‡è¦æ€§é‡‡æ ·çš„æ•°å­¦æ¨å¯¼

**åŸºæœ¬å˜æ¢**ï¼š
$$\int f(\mathbf{x}) d\mathbf{x} = \int \frac{f(\mathbf{x})}{p(\mathbf{x})} p(\mathbf{x}) d\mathbf{x} = E\left[\frac{f(\mathbf{X})}{p(\mathbf{X})}\right]$$

å…¶ä¸­ $p(\mathbf{x})$ æ˜¯æ¦‚ç‡å¯†åº¦å‡½æ•°ï¼Œ$\mathbf{X} \sim p(\mathbf{x})$ã€‚

**è’™ç‰¹å¡æ´›ä¼°è®¡**ï¼š
$$\int f(\mathbf{x}) d\mathbf{x} \approx \frac{1}{N} \sum_{i=1}^N \frac{f(\mathbf{X}_i)}{p(\mathbf{X}_i)}$$

#### æ–¹å·®åˆ†æä¸æœ€ä¼˜é‡‡æ ·

**ä¼°è®¡é‡çš„æ–¹å·®**ï¼š
$$\text{Var}\left[\frac{f(\mathbf{X})}{p(\mathbf{X})}\right] = \int \frac{f^2(\mathbf{x})}{p(\mathbf{x})} d\mathbf{x} - \left(\int f(\mathbf{x}) d\mathbf{x}\right)^2$$

**æœ€ä¼˜æ¦‚ç‡å¯†åº¦å‡½æ•°**ï¼š
ä½¿æ–¹å·®æœ€å°çš„æœ€ä¼˜é‡‡æ ·å¯†åº¦ä¸ºï¼š
$$p^*(\mathbf{x}) = \frac{|f(\mathbf{x})|}{\int |f(\mathbf{y})| d\mathbf{y}}$$

æ­¤æ—¶æ–¹å·®ä¸ºï¼š
$$\text{Var}^* = \left(\int |f(\mathbf{x})| d\mathbf{x}\right)^2 - \left(\int f(\mathbf{x}) d\mathbf{x}\right)^2$$

**å®ç”¨é‡‡æ ·ç­–ç•¥**ï¼š
åœ¨å®é™…åº”ç”¨ä¸­ï¼Œé€‰æ‹© $p(\mathbf{x}) \propto |f(\mathbf{x})|$ å¯ä»¥æ˜¾è‘—å‡å°‘æ–¹å·®ã€‚

**ä»£ç å®ç°**ï¼š

```cpp
class ImportanceSampler {
private:
    std::function<float(float)> pdf;           // æ¦‚ç‡å¯†åº¦å‡½æ•°
    std::function<float(float)> inverse_cdf;   // ç´¯ç§¯åˆ†å¸ƒå‡½æ•°çš„é€†

public:
    float sample() {
        float u = random_float();  // [0,1)å‡åŒ€éšæœºæ•°
        return inverse_cdf(u);
    }

    float evaluate_pdf(float x) {
        return pdf(x);
    }
};

// ä½™å¼¦åŠ æƒåŠçƒé‡‡æ ·ï¼ˆç”¨äºæ¼«åå°„ï¼‰
Vector3f cosine_weighted_hemisphere_sample() {
    float u1 = random_float();
    float u2 = random_float();

    float cos_theta = std::sqrt(u1);
    float sin_theta = std::sqrt(1.0f - u1);
    float phi = 2.0f * M_PI * u2;

    return Vector3f(sin_theta * std::cos(phi),
                   sin_theta * std::sin(phi),
                   cos_theta);
}

float cosine_hemisphere_pdf(float cos_theta) {
    return cos_theta / M_PI;
}
```

### 19.1.3 æ–¹å·®å‡å°‘æŠ€æœ¯çš„æ•°å­¦ç†è®º

#### åˆ†å±‚é‡‡æ ·ï¼ˆStratified Samplingï¼‰

**åŸºæœ¬åŸç†**ï¼š
å°†ç§¯åˆ†åŸŸåˆ†å‰²æˆ $M$ ä¸ªä¸ç›¸äº¤çš„å­åŸŸ $\Omega_j$ï¼Œåœ¨æ¯ä¸ªå­åŸŸå†…ç‹¬ç«‹é‡‡æ ·ï¼š
$$\int_{\Omega} f(\mathbf{x}) d\mathbf{x} = \sum_{j=1}^M \int_{\Omega_j} f(\mathbf{x}) d\mathbf{x}$$

**æ–¹å·®å‡å°‘æ•ˆæœ**ï¼š
åˆ†å±‚é‡‡æ ·çš„æ–¹å·®ä¸ºï¼š
$$\text{Var}_{strat} = \sum_{j=1}^M \frac{|\Omega_j|^2}{n_j} \sigma_j^2$$

å…¶ä¸­ $\sigma_j^2$ æ˜¯ç¬¬ $j$ å±‚å†…çš„æ–¹å·®ï¼Œé€šå¸¸ $\text{Var}_{strat} \leq \text{Var}_{uniform}$ã€‚

#### å¤šé‡é‡è¦æ€§é‡‡æ ·ï¼ˆMISï¼‰

**é—®é¢˜èƒŒæ™¯**ï¼š
å½“æœ‰å¤šä¸ªé‡‡æ ·ç­–ç•¥æ—¶ï¼Œå¦‚ä½•ç»„åˆå®ƒä»¬ä»¥è·å¾—æœ€ä¼˜ç»“æœï¼Ÿ

**å¹³è¡¡å¯å‘å¼ï¼ˆBalance Heuristicï¼‰**ï¼š
å¯¹äº $n$ ä¸ªé‡‡æ ·ç­–ç•¥ï¼Œæƒé‡å‡½æ•°ä¸ºï¼š
$$w_i(\mathbf{x}) = \frac{n_i p_i(\mathbf{x})}{\sum_{j=1}^n n_j p_j(\mathbf{x})}$$

å…¶ä¸­ $n_i$ æ˜¯ç­–ç•¥ $i$ çš„æ ·æœ¬æ•°ï¼Œ$p_i(\mathbf{x})$ æ˜¯å¯¹åº”çš„æ¦‚ç‡å¯†åº¦å‡½æ•°ã€‚

**å¹‚å¯å‘å¼ï¼ˆPower Heuristicï¼‰**ï¼š
$$w_i(\mathbf{x}) = \frac{(n_i p_i(\mathbf{x}))^\beta}{\sum_{j=1}^n (n_j p_j(\mathbf{x}))^\beta}$$

é€šå¸¸å– $\beta = 2$ã€‚

**MISä¼°è®¡é‡**ï¼š
$$\hat{I}_{MIS} = \sum_{i=1}^n \frac{1}{n_i} \sum_{j=1}^{n_i} w_i(\mathbf{X}_{i,j}) \frac{f(\mathbf{X}_{i,j})}{p_i(\mathbf{X}_{i,j})}$$

#### å·¥ç¨‹å®ç°

```cpp
// åˆ†å±‚é‡‡æ ·å®ç°
class StratifiedSampler {
public:
    std::vector<Vector2f> generate_2d_samples(int sqrt_samples) {
        std::vector<Vector2f> samples;
        float inv_sqrt = 1.0f / sqrt_samples;

        for (int i = 0; i < sqrt_samples; ++i) {
            for (int j = 0; j < sqrt_samples; ++j) {
                float jitter_x = random_float();
                float jitter_y = random_float();

                float x = (i + jitter_x) * inv_sqrt;
                float y = (j + jitter_y) * inv_sqrt;

                samples.emplace_back(x, y);
            }
        }

        // éšæœºæ‰“ä¹±ä»¥é¿å…ç›¸å…³æ€§
        std::shuffle(samples.begin(), samples.end(), rng);
        return samples;
    }
};

// å¤šé‡é‡è¦æ€§é‡‡æ ·å®ç°
class MISIntegrator {
public:
    static float power_heuristic(float pdf_a, float pdf_b, int beta = 2) {
        float weight_a = std::pow(pdf_a, beta);
        float weight_b = std::pow(pdf_b, beta);
        return weight_a / (weight_a + weight_b);
    }

    Vector3f estimate_direct_lighting(const Intersection& hit) {
        Vector3f L(0, 0, 0);

        // ç­–ç•¥1ï¼šBRDFé‡‡æ ·
        Vector3f brdf_dir = sample_brdf(hit);
        float brdf_pdf = evaluate_brdf_pdf(hit, brdf_dir);
        float light_pdf = evaluate_light_pdf(hit, brdf_dir);

        if (brdf_pdf > 0) {
            float weight = power_heuristic(brdf_pdf, light_pdf);
            Vector3f brdf_value = evaluate_brdf(hit, brdf_dir);
            Vector3f incoming = trace_ray(hit.position, brdf_dir);
            L += weight * brdf_value * incoming / brdf_pdf;
        }

        // ç­–ç•¥2ï¼šå…‰æºé‡‡æ ·
        Vector3f light_dir = sample_light(hit);
        light_pdf = evaluate_light_pdf(hit, light_dir);
        brdf_pdf = evaluate_brdf_pdf(hit, light_dir);

        if (light_pdf > 0) {
            float weight = power_heuristic(light_pdf, brdf_pdf);
            Vector3f brdf_value = evaluate_brdf(hit, light_dir);
            Vector3f incoming = trace_ray(hit.position, light_dir);
            L += weight * brdf_value * incoming / light_pdf;
        }

        return L;
    }
};
                                trace_ray(hit.position, brdf_dir) *
                                weight_brdf / brdf_pdf;

    // å…‰æºé‡‡æ ·
    Vector3f light_dir = sample_light(hit);
    light_pdf = evaluate_light_pdf(hit, light_dir);
    brdf_pdf = evaluate_brdf_pdf(hit, light_dir);
    float weight_light = mis_weight(light_pdf, brdf_pdf);

    Vector3f light_contribution = evaluate_brdf(hit, light_dir) *
                                 trace_ray(hit.position, light_dir) *
                                 weight_light / light_pdf;

    return brdf_contribution + light_contribution;
}
```

## 19.2 æ¸²æŸ“ä¸­çš„è’™ç‰¹å¡æ´›åº”ç”¨

### 19.2.1 ç›´æ¥å…‰ç…§çš„è’™ç‰¹å¡æ´›ä¼°è®¡

**æ¸²æŸ“æ–¹ç¨‹çš„ç›´æ¥å…‰ç…§éƒ¨åˆ†**ï¼š

```
$$L_{direct} = \int_\Omega f_r(\omega_i, \omega_o) L_i(\omega_i) \cos \theta_i d\omega_i$$
```

**è’™ç‰¹å¡æ´›ä¼°è®¡**ï¼š

```cpp
Vector3f estimate_direct_lighting(const Intersection& hit, const Vector3f& wo) {
    Vector3f direct_lighting(0, 0, 0);
    int samples = 64;

    for (int i = 0; i < samples; ++i) {
        // é‡‡æ ·å…‰æº
        Intersection light_sample;
        float light_pdf;
        scene.sample_light(light_sample, light_pdf);

        Vector3f light_dir = (light_sample.coords - hit.coords).normalized();
        float distance = (light_sample.coords - hit.coords).norm();

        // é˜´å½±æµ‹è¯•
        Ray shadow_ray(hit.coords + EPSILON * hit.normal, light_dir);
        shadow_ray.t_max = distance - EPSILON;

        if (!scene.intersect(shadow_ray).happened) {
            // è®¡ç®—BRDF
            Vector3f brdf = hit.m->eval(light_dir, wo, hit.normal);

            // è®¡ç®—è´¡çŒ®
            float cos_theta = std::max(0.0f, hit.normal.dot(light_dir));
            Vector3f contribution = brdf * light_sample.emit * cos_theta / light_pdf;

            direct_lighting += contribution;
        }
    }

    return direct_lighting / samples;
}
```

### 19.2.2 å…¨å±€å…‰ç…§çš„è·¯å¾„è¿½è¸ª

**è·¯å¾„è¿½è¸ªç®—æ³•**ï¼š

```cpp
Vector3f path_tracing(const Ray& ray, int depth) {
    if (depth <= 0) return Vector3f(0, 0, 0);

    Intersection hit = scene.intersect(ray);
    if (!hit.happened) return scene.background_color;

    Vector3f color(0, 0, 0);

    // è‡ªå‘å…‰
    color += hit.m->getEmission();

    // ç›´æ¥å…‰ç…§
    color += estimate_direct_lighting(hit, -ray.direction);

    // é—´æ¥å…‰ç…§ï¼ˆä¿„ç½—æ–¯è½®ç›˜èµŒï¼‰
    float russian_roulette = 0.8f;
    if (random_float() < russian_roulette) {
        // é‡‡æ ·BRDF
        Vector3f wi = sample_hemisphere(hit.normal);
        float pdf = 1.0f / (2.0f * M_PI);  // å‡åŒ€åŠçƒé‡‡æ ·

        Vector3f brdf = hit.m->eval(wi, -ray.direction, hit.normal);
        float cos_theta = std::max(0.0f, hit.normal.dot(wi));

        Ray indirect_ray(hit.coords + EPSILON * hit.normal, wi);
        Vector3f indirect = path_tracing(indirect_ray, depth - 1);

        color += brdf * indirect * cos_theta / (pdf * russian_roulette);
    }

    return color;
}
```

### 19.2.3 åŒå‘è·¯å¾„è¿½è¸ª

**åŸºæœ¬æ€æƒ³**ï¼šåŒæ—¶ä»å…‰æºå’Œæ‘„åƒæœºè¿½è¸ªè·¯å¾„ï¼Œåœ¨ä¸­é—´è¿æ¥

**ç®—æ³•æ¡†æ¶**ï¼š

```cpp
Vector3f bidirectional_path_tracing(const Ray& camera_ray) {
    // ä»æ‘„åƒæœºè¿½è¸ªè·¯å¾„
    std::vector<PathVertex> camera_path;
    trace_path_from_camera(camera_ray, camera_path);

    // ä»å…‰æºè¿½è¸ªè·¯å¾„
    std::vector<PathVertex> light_path;
    trace_path_from_light(light_path);

    Vector3f color(0, 0, 0);

    // å°è¯•æ‰€æœ‰å¯èƒ½çš„è¿æ¥
    for (int i = 0; i < camera_path.size(); ++i) {
        for (int j = 0; j < light_path.size(); ++j) {
            Vector3f contribution = connect_paths(camera_path, i, light_path, j);
            color += contribution;
        }
    }

    return color;
}

struct PathVertex {
    Vector3f position;
    Vector3f normal;
    Vector3f wi, wo;  // å…¥å°„å’Œå‡ºå°„æ–¹å‘
    Material* material;
    float pdf_forward, pdf_backward;
    Vector3f throughput;  // è·¯å¾„æƒé‡
};

Vector3f connect_paths(const std::vector<PathVertex>& camera_path, int cam_idx,
                      const std::vector<PathVertex>& light_path, int light_idx) {
    if (cam_idx >= camera_path.size() || light_idx >= light_path.size()) {
        return Vector3f(0, 0, 0);
    }

    const PathVertex& cam_vertex = camera_path[cam_idx];
    const PathVertex& light_vertex = light_path[light_idx];

    // æ£€æŸ¥è¿æ¥çš„å¯è§æ€§
    Vector3f connection_dir = (light_vertex.position - cam_vertex.position).normalized();
    float distance = (light_vertex.position - cam_vertex.position).norm();

    Ray visibility_ray(cam_vertex.position + EPSILON * cam_vertex.normal, connection_dir);
    visibility_ray.t_max = distance - EPSILON;

    if (scene.intersect(visibility_ray).happened) {
        return Vector3f(0, 0, 0);  // è¢«é®æŒ¡
    }

    // è®¡ç®—è¿æ¥çš„è´¡çŒ®
    Vector3f brdf_cam = cam_vertex.material->eval(connection_dir, cam_vertex.wo, cam_vertex.normal);
    Vector3f brdf_light = light_vertex.material->eval(-connection_dir, light_vertex.wi, light_vertex.normal);

    float cos_cam = std::max(0.0f, cam_vertex.normal.dot(connection_dir));
    float cos_light = std::max(0.0f, light_vertex.normal.dot(-connection_dir));

    Vector3f geometry_term = Vector3f(cos_cam * cos_light / (distance * distance));

    return cam_vertex.throughput * brdf_cam * geometry_term * brdf_light * light_vertex.throughput;
}
```

---

## å…¨å±€å…‰ç…§ä¸è·¯å¾„è¿½è¸ª

## 20.1 æ¸²æŸ“æ–¹ç¨‹æ·±åº¦è§£æ

### 20.1.1 æ¸²æŸ“æ–¹ç¨‹çš„æ•°å­¦æ¨å¯¼ä¸ç‰©ç†æ„ä¹‰

#### æ¸²æŸ“æ–¹ç¨‹çš„å®Œæ•´æ•°å­¦å½¢å¼

**ç§¯åˆ†å½¢å¼çš„æ¸²æŸ“æ–¹ç¨‹**ï¼š
$$L_o(\mathbf{p}, \omega_o) = L_e(\mathbf{p}, \omega_o) + \int_{\Omega} f_r(\mathbf{p}, \omega_i, \omega_o) L_i(\mathbf{p}, \omega_i) \cos \theta_i \, d\omega_i$$

#### å„é¡¹çš„ç‰©ç†æ„ä¹‰ä¸æ•°å­¦å®šä¹‰

**1. å‡ºå°„è¾å°„åº¦ $L_o(\mathbf{p}, \omega_o)$**ï¼š
ä»è¡¨é¢ç‚¹ $\mathbf{p}$ æ²¿æ–¹å‘ $\omega_o$ çš„å‡ºå°„è¾å°„åº¦ï¼Œå•ä½ä¸º $\text{W} \cdot \text{m}^{-2} \cdot \text{sr}^{-1}$

**2. è‡ªå‘å…‰é¡¹ $L_e(\mathbf{p}, \omega_o)$**ï¼š
è¡¨é¢ç‚¹ $\mathbf{p}$ è‡ªèº«å‘å‡ºçš„è¾å°„åº¦ï¼ˆå¯¹äºå…‰æºï¼‰

**3. BRDF $f_r(\mathbf{p}, \omega_i, \omega_o)$**ï¼š
åŒå‘åå°„åˆ†å¸ƒå‡½æ•°ï¼Œå®šä¹‰ä¸ºï¼š
$$f_r(\mathbf{p}, \omega_i, \omega_o) = \frac{dL_o(\mathbf{p}, \omega_o)}{dE_i(\mathbf{p}, \omega_i)} = \frac{dL_o(\mathbf{p}, \omega_o)}{L_i(\mathbf{p}, \omega_i) \cos \theta_i \, d\omega_i}$$

**4. å…¥å°„è¾å°„åº¦ $L_i(\mathbf{p}, \omega_i)$**ï¼š
ä»æ–¹å‘ $\omega_i$ å…¥å°„åˆ°ç‚¹ $\mathbf{p}$ çš„è¾å°„åº¦

**5. ä½™å¼¦é¡¹ $\cos \theta_i$**ï¼š
Lambertä½™å¼¦å®šå¾‹ï¼Œå…¶ä¸­ $\theta_i$ æ˜¯å…¥å°„æ–¹å‘ä¸è¡¨é¢æ³•å‘é‡çš„å¤¹è§’

**6. ç«‹ä½“è§’ç§¯åˆ†åŸŸ $\Omega$**ï¼š
ä»¥ç‚¹ $\mathbf{p}$ ä¸ºä¸­å¿ƒçš„ä¸ŠåŠçƒé¢ï¼Œ$\Omega = 2\pi$ ç«‹ä½“è§’

#### é€’å½’å½¢å¼ä¸å…‰ä¼ è¾“

**é€’å½’æ¸²æŸ“æ–¹ç¨‹**ï¼š
$$L_o(\mathbf{p}, \omega_o) = L_e(\mathbf{p}, \omega_o) + \int_{\Omega} f_r(\mathbf{p}, \omega_i, \omega_o) L_o(\mathbf{p}', -\omega_i) \cos \theta_i \, d\omega_i$$

å…¶ä¸­ $\mathbf{p}'$ æ˜¯æ²¿æ–¹å‘ $\omega_i$ çš„å…‰çº¿ä¸åœºæ™¯çš„ä¸‹ä¸€ä¸ªäº¤ç‚¹ï¼š
$$\mathbf{p}' = \mathbf{p} + t \omega_i$$

è¿™ä¸ªé€’å½’å½¢å¼ä½“ç°äº†å…‰åœ¨åœºæ™¯ä¸­çš„å¤šæ¬¡å¼¹å°„ä¼ æ’­ã€‚

### 20.1.2 å…‰ä¼ è¾“ç®—å­çš„æ•°å­¦ç†è®º

#### ç®—å­å½¢å¼çš„æ¸²æŸ“æ–¹ç¨‹

**çº¿æ€§ç®—å­è¡¨ç¤º**ï¼š
$$\mathbf{L} = \mathbf{E} + \mathbf{T}\mathbf{L}$$

å…¶ä¸­ï¼š

- $\mathbf{L}$ï¼šè¾å°„åº¦å‡½æ•°ï¼ˆåœ¨æ‰€æœ‰è¡¨é¢ç‚¹å’Œæ–¹å‘ä¸Šçš„åˆ†å¸ƒï¼‰
- $\mathbf{E}$ï¼šè‡ªå‘å…‰é¡¹
- $\mathbf{T}$ï¼šå…‰ä¼ è¾“ç®—å­

**å…‰ä¼ è¾“ç®—å­çš„å®šä¹‰**ï¼š
$$(\mathbf{T}\mathbf{L})(\mathbf{p}, \omega_o) = \int_{\Omega} f_r(\mathbf{p}, \omega_i, \omega_o) \mathbf{L}(\mathbf{p}', -\omega_i) \cos \theta_i \, d\omega_i$$

#### Neumannçº§æ•°å±•å¼€

**çº§æ•°è§£**ï¼š
ä»ç®—å­æ–¹ç¨‹ $\mathbf{L} = \mathbf{E} + \mathbf{T}\mathbf{L}$ å¯å¾—ï¼š
$$\mathbf{L} = (\mathbf{I} - \mathbf{T})^{-1}\mathbf{E} = \sum_{n=0}^{\infty} \mathbf{T}^n \mathbf{E}$$

**å„é¡¹çš„ç‰©ç†æ„ä¹‰**ï¼š

å…‰çº¿å¼¹å°„æ¬¡æ•°ä¸å…‰ç…§è´¡çŒ®ï¼š

ç›´æ¥å…‰ç…§ï¼ˆ0æ¬¡å¼¹å°„ï¼‰ï¼š
$$\mathbf{T}^0\mathbf{E} = \mathbf{E}$$

ä¸€æ¬¡é—´æ¥å…‰ç…§ï¼ˆ1æ¬¡å¼¹å°„ï¼‰ï¼š
$$\mathbf{T}^1\mathbf{E} = \mathbf{T}\mathbf{E}$$

äºŒæ¬¡é—´æ¥å…‰ç…§ï¼ˆ2æ¬¡å¼¹å°„ï¼‰ï¼š
$$\mathbf{T}^2\mathbf{E} = \mathbf{T}^2\mathbf{E}$$

næ¬¡é—´æ¥å…‰ç…§ï¼ˆnæ¬¡å¼¹å°„ï¼‰ï¼š
$$\mathbf{T}^n\mathbf{E}$$

#### æ”¶æ•›æ€§åˆ†æ

**æ”¶æ•›æ¡ä»¶**ï¼š
çº§æ•°æ”¶æ•›å½“ä¸”ä»…å½“ $\|\mathbf{T}\| < 1$ï¼Œå³å…‰ä¼ è¾“ç®—å­çš„è°±åŠå¾„å°äº1ã€‚

**ç‰©ç†æ„ä¹‰**ï¼š
è¿™å¯¹åº”äºèƒ½é‡å®ˆæ’å®šå¾‹â€”â€”æ¯æ¬¡åå°„éƒ½ä¼šæŸå¤±ä¸€éƒ¨åˆ†èƒ½é‡ï¼Œå› æ­¤æ— é™æ¬¡å¼¹å°„åæ€»èƒ½é‡æ”¶æ•›ã€‚

**å®é™…åº”ç”¨**ï¼š
åœ¨è·¯å¾„è¿½è¸ªä¸­ï¼Œé€šè¿‡ä¿„ç½—æ–¯è½®ç›˜èµŒï¼ˆRussian Rouletteï¼‰æ¥æ— ååœ°æˆªæ–­æ— é™çº§æ•°ã€‚

## 20.2 è·¯å¾„è¿½è¸ªç®—æ³•è¯¦è§£

### 20.2.1 åŸºç¡€è·¯å¾„è¿½è¸ª

**ç®—æ³•åŸç†**ï¼šä»æ‘„åƒæœºå‘å°„å…‰çº¿ï¼Œåœ¨æ¯ä¸ªäº¤ç‚¹éšæœºé€‰æ‹©ä¸€ä¸ªæ–¹å‘ç»§ç»­è¿½è¸ª

**åŸºäºGAMES101 Assignment7çš„å®ç°**ï¼š

```cpp
Vector3f Scene::castRay(const Ray &ray, int depth) const {
    if (depth > this->maxDepth) {
        return Vector3f(0.0, 0.0, 0.0);
    }

    Intersection intersection = Scene::intersect(ray);
    if (!intersection.happened) {
        return this->backgroundColor;
    }

    Material *m = intersection.m;
    Object *hitObject = intersection.obj;
    Vector3f hitColor = this->backgroundColor;
    Vector3f hitPoint = intersection.coords;
    Vector3f N = intersection.normal;
    Vector2f uv = intersection.uv;

    switch (m->getType()) {
        case DIFFUSE: {
            // ç›´æ¥å…‰ç…§é‡‡æ ·
            Vector3f L_dir(0, 0, 0);

            // å¯¹å…‰æºè¿›è¡Œé‡‡æ ·
            Intersection light_pos;
            float light_pdf = 0.0f;
            sampleLight(light_pos, light_pdf);

            Vector3f obj2light = light_pos.coords - hitPoint;
            Vector3f obj2lightdir = obj2light.normalized();
            float distance = obj2light.norm();

            // å‘å°„é˜´å½±å…‰çº¿
            Ray shadowRay(hitPoint, obj2lightdir);
            Intersection shadowIntersection = intersect(shadowRay);

            // æ£€æŸ¥æ˜¯å¦è¢«é®æŒ¡
            if (shadowIntersection.distance - distance > -EPSILON) {
                Vector3f f_r = m->eval(obj2lightdir, -ray.direction, N);
                L_dir = light_pos.emit * f_r * dotProduct(obj2lightdir, N) / light_pdf / distance / distance;
            }

            // é—´æ¥å…‰ç…§é‡‡æ ·ï¼ˆä¿„ç½—æ–¯è½®ç›˜èµŒï¼‰
            Vector3f L_indir(0, 0, 0);
            float ksi = get_random_float();
            if (ksi < RussianRoulette) {
                Vector3f wi = toWorld(sampleHemisphere(uv), N);
                Ray indirectRay(hitPoint, wi);
                Intersection indirectIntersection = intersect(indirectRay);

                if (indirectIntersection.happened && !indirectIntersection.obj->hasEmit()) {
                    Vector3f f_r = m->eval(wi, -ray.direction, N);
                    float pdf = 1.0f / (2.0f * M_PI);  // å‡åŒ€åŠçƒé‡‡æ ·
                    L_indir = castRay(indirectRay, depth + 1) * f_r * dotProduct(wi, N) / pdf / RussianRoulette;
                }
            }

            hitColor = L_dir + L_indir;
            break;
        }
    }

    return hitColor;
}
```

### 20.2.2 é‡è¦æ€§é‡‡æ ·ä¼˜åŒ–

**BRDFé‡è¦æ€§é‡‡æ ·**ï¼š

```cpp
// ä½™å¼¦åŠ æƒé‡‡æ ·ï¼ˆé€‚ç”¨äºLambertæè´¨ï¼‰
Vector3f cosine_sample_hemisphere(const Vector2f& u) {
    float cos_theta = std::sqrt(u[0]);
    float sin_theta = std::sqrt(1.0f - u[0]);
    float phi = 2.0f * M_PI * u[1];

    return Vector3f(sin_theta * std::cos(phi),
                   sin_theta * std::sin(phi),
                   cos_theta);
}

float cosine_hemisphere_pdf(float cos_theta) {
    return cos_theta / M_PI;
}

// é•œé¢åå°„é‡‡æ ·
Vector3f sample_specular_reflection(const Vector3f& wi, const Vector3f& normal) {
    return wi - 2.0f * wi.dot(normal) * normal;
}

// å¾®è¡¨é¢æ¨¡å‹é‡‡æ ·ï¼ˆGGXåˆ†å¸ƒï¼‰
Vector3f sample_ggx_distribution(const Vector2f& u, float alpha) {
    float cos_theta = std::sqrt((1.0f - u[0]) / (1.0f + (alpha * alpha - 1.0f) * u[0]));
    float sin_theta = std::sqrt(1.0f - cos_theta * cos_theta);
    float phi = 2.0f * M_PI * u[1];

    return Vector3f(sin_theta * std::cos(phi),
                   sin_theta * std::sin(phi),
                   cos_theta);
}
```

### 20.2.3 å¤šé‡é‡è¦æ€§é‡‡æ ·

**ç»“åˆBRDFé‡‡æ ·å’Œå…‰æºé‡‡æ ·**ï¼š

```cpp
Vector3f estimate_direct_lighting_mis(const Intersection& hit, const Vector3f& wo) {
    Vector3f L(0, 0, 0);

    // å…‰æºé‡‡æ ·
    Intersection light_sample;
    float light_pdf;
    scene.sample_light(light_sample, light_pdf);

    if (light_pdf > 0) {
        Vector3f wi = (light_sample.coords - hit.coords).normalized();

        // æ£€æŸ¥å¯è§æ€§
        if (!scene.occluded(hit.coords, light_sample.coords)) {
            Vector3f f = hit.material->eval(wi, wo, hit.normal);
            float brdf_pdf = hit.material->pdf(wi, wo, hit.normal);

            if (brdf_pdf > 0) {
                float weight = power_heuristic(light_pdf, brdf_pdf);
                float cos_theta = std::max(0.0f, hit.normal.dot(wi));
                L += f * light_sample.emit * cos_theta * weight / light_pdf;
            }
        }
    }

    // BRDFé‡‡æ ·
    Vector3f wi;
    float brdf_pdf;
    Vector3f f = hit.material->sample_f(wo, wi, hit.normal, brdf_pdf);

    if (brdf_pdf > 0) {
        Ray ray(hit.coords + EPSILON * hit.normal, wi);
        Intersection light_hit = scene.intersect(ray);

        if (light_hit.happened && light_hit.obj->hasEmit()) {
            float light_pdf_value = scene.pdf_light(hit.coords, light_hit.coords);
            float weight = power_heuristic(brdf_pdf, light_pdf_value);
            float cos_theta = std::max(0.0f, hit.normal.dot(wi));
            L += f * light_hit.obj->getEmission() * cos_theta * weight / brdf_pdf;
        }
    }

    return L;
}

// Powerå¯å‘å¼æƒé‡å‡½æ•°
float power_heuristic(float pdf_a, float pdf_b, int beta = 2) {
    float a = std::pow(pdf_a, beta);
    float b = std::pow(pdf_b, beta);
    return a / (a + b);
}
```

## 20.3 é«˜çº§å…¨å±€å…‰ç…§æŠ€æœ¯

### 20.3.1 å…‰å­æ˜ å°„

**åŸºæœ¬æ€æƒ³**ï¼š

1. **å…‰å­å‘å°„**ï¼šä»å…‰æºå‘å°„å…‰å­ï¼Œè®°å½•å…¶åœ¨åœºæ™¯ä¸­çš„äº¤äº’
2. **å…‰å­å­˜å‚¨**ï¼šå°†å…‰å­å­˜å‚¨åœ¨ç©ºé—´æ•°æ®ç»“æ„ä¸­
3. **å¯†åº¦ä¼°è®¡**ï¼šåœ¨æ¸²æŸ“æ—¶æŸ¥è¯¢é™„è¿‘å…‰å­ä¼°è®¡è¾å°„åº¦

**å…‰å­ç»“æ„**ï¼š

```cpp
struct Photon {
    Vector3f position;     // å…‰å­ä½ç½®
    Vector3f direction;    // å…¥å°„æ–¹å‘
    Vector3f power;        // å…‰å­èƒ½é‡
    short plane;           // kDæ ‘åˆ†å‰²å¹³é¢
};

class PhotonMap {
private:
    std::vector<Photon> photons;
    int stored_photons;
    int max_photons;

public:
    void store(const Photon& photon) {
        if (stored_photons < max_photons) {
            photons[stored_photons] = photon;
            stored_photons++;
        }
    }

    Vector3f irradiance_estimate(const Vector3f& position, const Vector3f& normal,
                                float max_distance, int max_photons) {
        // æŸ¥æ‰¾æœ€è¿‘çš„å…‰å­
        std::vector<std::pair<float, int>> nearest_photons;
        find_nearest_photons(position, max_distance, max_photons, nearest_photons);

        if (nearest_photons.empty()) return Vector3f(0, 0, 0);

        Vector3f irradiance(0, 0, 0);
        float max_dist_sqr = nearest_photons.back().first;

        for (const auto& [dist_sqr, idx] : nearest_photons) {
            const Photon& photon = photons[idx];

            // æ£€æŸ¥å…‰å­æ–¹å‘ä¸è¡¨é¢æ³•å‘é‡çš„å…³ç³»
            if (photon.direction.dot(normal) < 0) {
                irradiance += photon.power;
            }
        }

        // å¯†åº¦ä¼°è®¡ï¼š$irradiance = \frac{power}{area}$
        return irradiance / (M_PI * max_dist_sqr);
    }
};
```

**å…‰å­è¿½è¸ªè¿‡ç¨‹**ï¼š

```cpp
void trace_photon(const Ray& ray, const Vector3f& power, int depth) {
    if (depth <= 0 || power.norm() < EPSILON) return;

    Intersection hit = scene.intersect(ray);
    if (!hit.happened) return;

    // å­˜å‚¨å…‰å­ï¼ˆé™¤äº†ç¬¬ä¸€æ¬¡äº¤äº’ï¼‰
    if (depth < max_depth) {
        Photon photon;
        photon.position = hit.coords;
        photon.direction = ray.direction;
        photon.power = power;
        photon_map.store(photon);
    }

    // ä¿„ç½—æ–¯è½®ç›˜èµŒå†³å®šæ˜¯å¦ç»§ç»­
    float survival_prob = std::min(0.9f, power.maxCoeff());
    if (random_float() > survival_prob) return;

    // é‡‡æ ·æ–°æ–¹å‘
    Vector3f new_direction;
    Vector3f brdf = hit.material->sample_f(-ray.direction, new_direction, hit.normal);

    Vector3f new_power = power * brdf * hit.normal.dot(new_direction) / survival_prob;
    Ray new_ray(hit.coords + EPSILON * hit.normal, new_direction);

    trace_photon(new_ray, new_power, depth - 1);
}
```

### 20.3.2 å®æ—¶å…¨å±€å…‰ç…§è¿‘ä¼¼

**å±å¹•ç©ºé—´ç¯å¢ƒå…‰é®è”½ï¼ˆSSAOï¼‰**ï¼š

```cpp
float calculate_ssao(const Vector2f& screen_pos, const Vector3f& position,
                    const Vector3f& normal, const Texture& depth_buffer) {
    float occlusion = 0.0f;
    int samples = 64;
    float radius = 0.5f;

    for (int i = 0; i < samples; ++i) {
        // åœ¨æ³•å‘é‡åŠçƒå†…é‡‡æ ·
        Vector3f sample_dir = generate_hemisphere_sample(normal);
        Vector3f sample_pos = position + radius * sample_dir;

        // æŠ•å½±åˆ°å±å¹•ç©ºé—´
        Vector2f sample_screen = world_to_screen(sample_pos);

        // é‡‡æ ·æ·±åº¦ç¼“å†²
        float sample_depth = depth_buffer.sample(sample_screen);
        float actual_depth = world_to_depth(sample_pos);

        // æ¯”è¾ƒæ·±åº¦
        if (actual_depth > sample_depth + bias) {
            occlusion += 1.0f;
        }
    }

    return 1.0f - (occlusion / samples);
}
```

**å…‰ä¼ æ’­ä½“ç§¯ï¼ˆLight Propagation Volumesï¼‰**ï¼š

```cpp
class LightPropagationVolume {
private:
    struct VoxelGrid {
        std::vector<Vector3f> red_coeffs;    // çº¢è‰²é€šé“çƒè°ç³»æ•°
        std::vector<Vector3f> green_coeffs;  // ç»¿è‰²é€šé“çƒè°ç³»æ•°
        std::vector<Vector3f> blue_coeffs;   // è“è‰²é€šé“çƒè°ç³»æ•°
        int resolution;
    };

    VoxelGrid grid;

public:
    void inject_light(const std::vector<VirtualPointLight>& vpls) {
        // å°†è™šæ‹Ÿç‚¹å…‰æºæ³¨å…¥ä½“ç´ ç½‘æ ¼
        for (const auto& vpl : vpls) {
            Vector3i voxel_coord = world_to_voxel(vpl.position);

            // è®¡ç®—çƒè°ç³»æ•°
            Vector3f sh_coeffs = compute_spherical_harmonics(vpl.direction, vpl.intensity);

            grid.red_coeffs[voxel_index(voxel_coord)] += sh_coeffs * vpl.color.r;
            grid.green_coeffs[voxel_index(voxel_coord)] += sh_coeffs * vpl.color.g;
            grid.blue_coeffs[voxel_index(voxel_coord)] += sh_coeffs * vpl.color.b;
        }
    }

    void propagate_light() {
        // è¿­ä»£ä¼ æ’­å…‰ç…§
        for (int iteration = 0; iteration < 4; ++iteration) {
            VoxelGrid new_grid = grid;

            for (int z = 0; z < grid.resolution; ++z) {
                for (int y = 0; y < grid.resolution; ++y) {
                    for (int x = 0; x < grid.resolution; ++x) {
                        Vector3i coord(x, y, z);

                        // ä»6ä¸ªé‚»å±…ä¼ æ’­å…‰ç…§
                        propagate_from_neighbors(coord, new_grid);
                    }
                }
            }

            grid = new_grid;
        }
    }

    Vector3f sample_indirect_lighting(const Vector3f& position, const Vector3f& normal) {
        Vector3i voxel_coord = world_to_voxel(position);

        // ä¸‰çº¿æ€§æ’å€¼é‡‡æ ·çƒè°ç³»æ•°
        Vector3f red_sh = trilinear_sample(grid.red_coeffs, voxel_coord);
        Vector3f green_sh = trilinear_sample(grid.green_coeffs, voxel_coord);
        Vector3f blue_sh = trilinear_sample(grid.blue_coeffs, voxel_coord);

        // è®¡ç®—æ³•å‘é‡æ–¹å‘çš„è¾å°„åº¦
        float sh_basis = evaluate_spherical_harmonics(normal);

        return Vector3f(red_sh.dot(Vector3f(sh_basis)),
                       green_sh.dot(Vector3f(sh_basis)),
                       blue_sh.dot(Vector3f(sh_basis)));
    }
};
```

---

## åŠ¨ç”»åŸºç¡€ç†è®º

## 21.1 åŠ¨ç”»çš„æ•°å­¦åŸºç¡€

### 21.1.1 æ’å€¼ç†è®ºçš„æ•°å­¦åŸºç¡€

#### çº¿æ€§æ’å€¼çš„æ•°å­¦å®šä¹‰

**ä¸€ç»´çº¿æ€§æ’å€¼**ï¼š
ç»™å®šä¸¤ä¸ªæ•°æ®ç‚¹ $(t_0, f_0)$ å’Œ $(t_1, f_1)$ï¼Œçº¿æ€§æ’å€¼å‡½æ•°ä¸ºï¼š
$$f(t) = f_0 + \frac{t - t_0}{t_1 - t_0}(f_1 - f_0) = (1-u)f_0 + uf_1$$

å…¶ä¸­ $u = \frac{t - t_0}{t_1 - t_0} \in [0,1]$ æ˜¯æ ‡å‡†åŒ–å‚æ•°ã€‚

**å‡ ä½•æ„ä¹‰**ï¼š
çº¿æ€§æ’å€¼åœ¨å‡ ä½•ä¸Šè¡¨ç¤ºè¿æ¥ä¸¤ç‚¹çš„ç›´çº¿æ®µï¼Œæ»¡è¶³ï¼š

- **ç«¯ç‚¹æ’å€¼æ€§**ï¼š$f(t_0) = f_0$ï¼Œ$f(t_1) = f_1$
- **çº¿æ€§æ€§**ï¼š$f(\alpha t_0 + (1-\alpha)t_1) = \alpha f_0 + (1-\alpha)f_1$

#### å¤šç»´çº¿æ€§æ’å€¼

**å‘é‡æ’å€¼**ï¼š
å¯¹äºå‘é‡ $\mathbf{v}_0, \mathbf{v}_1 \in \mathbb{R}^n$ï¼š
$$\mathbf{v}(t) = (1-t)\mathbf{v}_0 + t\mathbf{v}_1$$

**æ€§è´¨**ï¼š

- **åˆ†é‡ç‹¬ç«‹æ€§**ï¼šæ¯ä¸ªåˆ†é‡ç‹¬ç«‹è¿›è¡Œçº¿æ€§æ’å€¼
- **ä»¿å°„ä¸å˜æ€§**ï¼šä»¿å°„å˜æ¢ä¸æ’å€¼å¯äº¤æ¢

**ä»£ç å®ç°**ï¼š

```cpp
template<typename T>
T lerp(const T& a, const T& b, float t) {
    return a + t * (b - a);
}

// å‘é‡æ’å€¼
Vector3f lerp_vector(const Vector3f& v1, const Vector3f& v2, float t) {
    return Vector3f(lerp(v1.x(), v2.x(), t),
                   lerp(v1.y(), v2.y(), t),
                   lerp(v1.z(), v2.z(), t));
}

// é¢œè‰²æ’å€¼
Color lerp_color(const Color& c1, const Color& c2, float t) {
    return Color(lerp(c1.r, c2.r, t),
                lerp(c1.g, c2.g, t),
                lerp(c1.b, c2.b, t),
                lerp(c1.a, c2.a, t));
}
```

#### çƒé¢çº¿æ€§æ’å€¼ï¼ˆSLERPï¼‰çš„æ•°å­¦ç†è®º

**é—®é¢˜èƒŒæ™¯**ï¼š
å¯¹äºå•ä½çƒé¢ä¸Šçš„ç‚¹ï¼ˆå¦‚å•ä½å››å…ƒæ•°ï¼‰ï¼Œçº¿æ€§æ’å€¼çš„ç»“æœä¸åœ¨çƒé¢ä¸Šï¼Œéœ€è¦ç‰¹æ®Šçš„æ’å€¼æ–¹æ³•ã€‚

**SLERPçš„æ•°å­¦å®šä¹‰**ï¼š
å¯¹äºå•ä½çƒé¢ä¸Šçš„ä¸¤ç‚¹ $\mathbf{q}_1$ å’Œ $\mathbf{q}_2$ï¼Œçƒé¢çº¿æ€§æ’å€¼ä¸ºï¼š
$$\text{slerp}(\mathbf{q}_1, \mathbf{q}_2, t) = \frac{\sin((1-t)\theta)}{\sin\theta}\mathbf{q}_1 + \frac{\sin(t\theta)}{\sin\theta}\mathbf{q}_2$$

å…¶ä¸­ $\theta = \arccos(\mathbf{q}_1 \cdot \mathbf{q}_2)$ æ˜¯ä¸¤ä¸ªå››å…ƒæ•°ä¹‹é—´çš„è§’åº¦ã€‚

**å‡ ä½•æ„ä¹‰**ï¼š
SLERPæ²¿ç€è¿æ¥ä¸¤ç‚¹çš„å¤§åœ†å¼§è¿›è¡Œæ’å€¼ï¼Œä¿æŒï¼š

- **å•ä½é•¿åº¦**ï¼šæ’å€¼ç»“æœå§‹ç»ˆåœ¨å•ä½çƒé¢ä¸Š
- **ç­‰è§’é€Ÿåº¦**ï¼šè§’é€Ÿåº¦æ’å®š
- **æœ€çŸ­è·¯å¾„**ï¼šæ²¿æœ€çŸ­çš„å¤§åœ†å¼§è·¯å¾„

**æ•°å­¦æ¨å¯¼**ï¼š
è®¾ $\mathbf{q}(t) = a(t)\mathbf{q}_1 + b(t)\mathbf{q}_2$ï¼Œè¦æ±‚ï¼š

1. $\|\mathbf{q}(t)\| = 1$ï¼ˆå•ä½é•¿åº¦ï¼‰
2. $\mathbf{q}(0) = \mathbf{q}_1$ï¼Œ$\mathbf{q}(1) = \mathbf{q}_2$ï¼ˆç«¯ç‚¹æ¡ä»¶ï¼‰
3. ç­‰è§’é€Ÿåº¦æ¡ä»¶

è§£å¾—ï¼š$a(t) = \frac{\sin((1-t)\theta)}{\sin\theta}$ï¼Œ$b(t) = \frac{\sin(t\theta)}{\sin\theta}$

```cpp
Quaternionf slerp(const Quaternionf& q1, const Quaternionf& q2, float t) {
    float dot = q1.dot(q2);

    // é€‰æ‹©æœ€çŸ­è·¯å¾„
    Quaternionf q2_corrected = (dot < 0) ? Quaternionf(-q2.coeffs()) : q2;
    dot = std::abs(dot);

    // å¦‚æœå››å…ƒæ•°éå¸¸æ¥è¿‘ï¼Œä½¿ç”¨çº¿æ€§æ’å€¼
    if (dot > 0.9995f) {
        Quaternionf result = Quaternionf(q1.coeffs() + t * (q2_corrected.coeffs() - q1.coeffs()));
        result.normalize();
        return result;
    }

    // çƒé¢çº¿æ€§æ’å€¼
    float theta = std::acos(dot);
    float sin_theta = std::sin(theta);

    float w1 = std::sin((1.0f - t) * theta) / sin_theta;
    float w2 = std::sin(t * theta) / sin_theta;

    return Quaternionf(w1 * q1.coeffs() + w2 * q2_corrected.coeffs());
}
```

### 21.1.2 æ ·æ¡æ’å€¼

**Catmull-Romæ ·æ¡**ï¼š
é€šè¿‡æ§åˆ¶ç‚¹çš„å¹³æ»‘æ›²çº¿
$$f(t) = \frac{1}{2}[2P_1 + (-P_0 + P_2)t + (2P_0 - 5P_1 + 4P_2 - P_3)t^2 + (-P_0 + 3P_1 - 3P_2 + P_3)t^3]$$

```cpp
Vector3f catmull_rom_spline(const Vector3f& p0, const Vector3f& p1,
                           const Vector3f& p2, const Vector3f& p3, float t) {
    float t2 = t * t;
    float t3 = t2 * t;

    Vector3f a = -0.5f * p0 + 1.5f * p1 - 1.5f * p2 + 0.5f * p3;
    Vector3f b = p0 - 2.5f * p1 + 2.0f * p2 - 0.5f * p3;
    Vector3f c = -0.5f * p0 + 0.5f * p2;
    Vector3f d = p1;

    return a * t3 + b * t2 + c * t + d;
}
```

**Bæ ·æ¡åŸºå‡½æ•°**ï¼š

```cpp
float b_spline_basis(int i, int k, float t, const std::vector<float>& knots) {
    if (k == 0) {
        return (t >= knots[i] && t < knots[i + 1]) ? 1.0f : 0.0f;
    }

    float left_coeff = 0.0f, right_coeff = 0.0f;

    if (knots[i + k] != knots[i]) {
        left_coeff = (t - knots[i]) / (knots[i + k] - knots[i]);
    }

    if (knots[i + k + 1] != knots[i + 1]) {
        right_coeff = (knots[i + k + 1] - t) / (knots[i + k + 1] - knots[i + 1]);
    }

    return left_coeff * b_spline_basis(i, k - 1, t, knots) +
           right_coeff * b_spline_basis(i + 1, k - 1, t, knots);
}
```

## 21.2 å…³é”®å¸§åŠ¨ç”»

### 21.2.1 å…³é”®å¸§ç³»ç»Ÿè®¾è®¡

**å…³é”®å¸§æ•°æ®ç»“æ„**ï¼š

```cpp
template<typename T>
struct Keyframe {
    float time;
    T value;

    // åˆ‡çº¿ä¿¡æ¯ï¼ˆç”¨äºHermiteæ’å€¼ï¼‰
    T in_tangent;
    T out_tangent;

    // æ’å€¼ç±»å‹
    enum InterpolationType {
        LINEAR,
        CUBIC,
        BEZIER,
        STEP
    } interpolation;
};

template<typename T>
class AnimationCurve {
private:
    std::vector<Keyframe<T>> keyframes;

public:
    void add_keyframe(float time, const T& value,
                     typename Keyframe<T>::InterpolationType interp = Keyframe<T>::LINEAR) {
        Keyframe<T> kf;
        kf.time = time;
        kf.value = value;
        kf.interpolation = interp;

        // ä¿æŒæ—¶é—´é¡ºåº
        auto it = std::lower_bound(keyframes.begin(), keyframes.end(), kf,
                                  [](const Keyframe<T>& a, const Keyframe<T>& b) {
                                      return a.time < b.time;
                                  });
        keyframes.insert(it, kf);
    }

    T evaluate(float time) const {
        if (keyframes.empty()) return T();
        if (keyframes.size() == 1) return keyframes[0].value;

        // è¾¹ç•Œæƒ…å†µ
        if (time <= keyframes.front().time) return keyframes.front().value;
        if (time >= keyframes.back().time) return keyframes.back().value;

        // æ‰¾åˆ°ç›¸é‚»çš„å…³é”®å¸§
        auto it = std::lower_bound(keyframes.begin(), keyframes.end(), time,
                                  [](const Keyframe<T>& kf, float t) {
                                      return kf.time < t;
                                  });

        const Keyframe<T>& kf1 = *(it - 1);
        const Keyframe<T>& kf2 = *it;

        float t = (time - kf1.time) / (kf2.time - kf1.time);

        switch (kf1.interpolation) {
            case Keyframe<T>::LINEAR:
                return lerp(kf1.value, kf2.value, t);

            case Keyframe<T>::CUBIC:
                return cubic_interpolate(kf1.value, kf1.out_tangent,
                                       kf2.value, kf2.in_tangent, t);

            case Keyframe<T>::STEP:
                return kf1.value;

            default:
                return lerp(kf1.value, kf2.value, t);
        }
    }
};
```

### 21.2.2 åŠ¨ç”»æ··åˆ

**çº¿æ€§æ··åˆ**ï¼š

```cpp
class AnimationBlender {
private:
    struct AnimationLayer {
        AnimationCurve<Vector3f> position;
        AnimationCurve<Quaternionf> rotation;
        AnimationCurve<Vector3f> scale;
        float weight;
        bool additive;
    };

    std::vector<AnimationLayer> layers;

public:
    void add_layer(const AnimationLayer& layer) {
        layers.push_back(layer);
    }

    Transform evaluate(float time) const {
        Transform result;
        result.position = Vector3f::Zero();
        result.rotation = Quaternionf::Identity();
        result.scale = Vector3f::Ones();

        float total_weight = 0.0f;

        for (const auto& layer : layers) {
            if (layer.weight <= 0.0f) continue;

            Transform layer_transform;
            layer_transform.position = layer.position.evaluate(time);
            layer_transform.rotation = layer.rotation.evaluate(time);
            layer_transform.scale = layer.scale.evaluate(time);

            if (layer.additive) {
                // åŠ æ€§æ··åˆ
                result.position += layer_transform.position * layer.weight;
                result.rotation = result.rotation *
                    Quaternionf::Identity().slerp(layer.weight, layer_transform.rotation);
                result.scale += (layer_transform.scale - Vector3f::Ones()) * layer.weight;
            } else {
                // çº¿æ€§æ··åˆ
                float normalized_weight = layer.weight;
                if (total_weight > 0) {
                    normalized_weight = layer.weight / (total_weight + layer.weight);
                }

                result.position = lerp(result.position, layer_transform.position, normalized_weight);
                result.rotation = result.rotation.slerp(normalized_weight, layer_transform.rotation);
                result.scale = lerp(result.scale, layer_transform.scale, normalized_weight);

                total_weight += layer.weight;
            }
        }

        return result;
    }
};
```

## 21.3 éª¨éª¼åŠ¨ç”»

### 21.3.1 éª¨éª¼å±‚æ¬¡ç»“æ„

**éª¨éª¼æ•°æ®ç»“æ„**ï¼š

```cpp
struct Bone {
    std::string name;
    int parent_index;
    std::vector<int> children_indices;

    // ç»‘å®šå§¿æ€ï¼ˆT-poseï¼‰
    Transform bind_pose;
    Matrix4f inverse_bind_matrix;

    // å½“å‰å˜æ¢
    Transform local_transform;
    Transform world_transform;
};

class Skeleton {
private:
    std::vector<Bone> bones;
    std::unordered_map<std::string, int> bone_name_to_index;

public:
    void add_bone(const std::string& name, int parent_index, const Transform& bind_pose) {
        Bone bone;
        bone.name = name;
        bone.parent_index = parent_index;
        bone.bind_pose = bind_pose;
        bone.local_transform = bind_pose;
        bone.inverse_bind_matrix = bind_pose.to_matrix().inverse();

        int bone_index = bones.size();
        bones.push_back(bone);
        bone_name_to_index[name] = bone_index;

        // æ›´æ–°çˆ¶éª¨éª¼çš„å­éª¨éª¼åˆ—è¡¨
        if (parent_index >= 0) {
            bones[parent_index].children_indices.push_back(bone_index);
        }
    }

    void update_world_transforms() {
        for (int i = 0; i < bones.size(); ++i) {
            update_bone_world_transform(i);
        }
    }

private:
    void update_bone_world_transform(int bone_index) {
        Bone& bone = bones[bone_index];

        if (bone.parent_index >= 0) {
            const Bone& parent = bones[bone.parent_index];
            bone.world_transform = parent.world_transform * bone.local_transform;
        } else {
            bone.world_transform = bone.local_transform;
        }
    }

public:
    std::vector<Matrix4f> get_bone_matrices() const {
        std::vector<Matrix4f> matrices;
        matrices.reserve(bones.size());

        for (const auto& bone : bones) {
            Matrix4f bone_matrix = bone.world_transform.to_matrix() * bone.inverse_bind_matrix;
            matrices.push_back(bone_matrix);
        }

        return matrices;
    }
};
```

### 21.3.2 è’™çš®ç®—æ³•

**çº¿æ€§æ··åˆè’™çš®ï¼ˆLinear Blend Skinningï¼‰**ï¼š

```cpp
struct VertexWeight {
    int bone_indices[4];
    float weights[4];

    void normalize() {
        float sum = weights[0] + weights[1] + weights[2] + weights[3];
        if (sum > 0.0f) {
            weights[0] /= sum;
            weights[1] /= sum;
            weights[2] /= sum;
            weights[3] /= sum;
        }
    }
};

class SkinnedMesh {
private:
    std::vector<Vector3f> bind_positions;
    std::vector<Vector3f> bind_normals;
    std::vector<VertexWeight> vertex_weights;

    std::vector<Vector3f> deformed_positions;
    std::vector<Vector3f> deformed_normals;

public:
    void deform(const std::vector<Matrix4f>& bone_matrices) {
        deformed_positions.resize(bind_positions.size());
        deformed_normals.resize(bind_normals.size());

        for (int i = 0; i < bind_positions.size(); ++i) {
            const Vector3f& bind_pos = bind_positions[i];
            const Vector3f& bind_normal = bind_normals[i];
            const VertexWeight& weight = vertex_weights[i];

            Vector3f deformed_pos = Vector3f::Zero();
            Vector3f deformed_normal = Vector3f::Zero();

            for (int j = 0; j < 4; ++j) {
                if (weight.weights[j] > 0.0f) {
                    int bone_index = weight.bone_indices[j];
                    const Matrix4f& bone_matrix = bone_matrices[bone_index];

                    // å˜æ¢ä½ç½®
                    Vector4f pos_homogeneous(bind_pos.x(), bind_pos.y(), bind_pos.z(), 1.0f);
                    Vector4f transformed_pos = bone_matrix * pos_homogeneous;
                    deformed_pos += weight.weights[j] * transformed_pos.head<3>();

                    // å˜æ¢æ³•å‘é‡
                    Matrix3f normal_matrix = bone_matrix.block<3,3>(0,0);
                    deformed_normal += weight.weights[j] * (normal_matrix * bind_normal);
                }
            }

            deformed_positions[i] = deformed_pos;
            deformed_normals[i] = deformed_normal.normalized();
        }
    }
};
```

**åŒå››å…ƒæ•°è’™çš®ï¼ˆDual Quaternion Skinningï¼‰**ï¼š
è§£å†³çº¿æ€§æ··åˆè’™çš®çš„ä½“ç§¯æŸå¤±é—®é¢˜

```cpp
struct DualQuaternion {
    Quaternionf real;
    Quaternionf dual;

    DualQuaternion() : real(Quaternionf::Identity()), dual(Quaternionf(0,0,0,0)) {}

    DualQuaternion(const Matrix4f& transform) {
        // æå–æ—‹è½¬å’Œå¹³ç§»
        Matrix3f rotation = transform.block<3,3>(0,0);
        Vector3f translation = transform.block<3,1>(0,3);

        real = Quaternionf(rotation);

        // $dual = 0.5 \times translation \times real$
        Quaternionf trans_quat(0, translation.x(), translation.y(), translation.z());
        dual = Quaternionf(0.5f * (trans_quat * real).coeffs());
    }

    DualQuaternion operator+(const DualQuaternion& other) const {
        DualQuaternion result;
        result.real = Quaternionf(real.coeffs() + other.real.coeffs());
        result.dual = Quaternionf(dual.coeffs() + other.dual.coeffs());
        return result;
    }

    DualQuaternion operator*(float scalar) const {
        DualQuaternion result;
        result.real = Quaternionf(scalar * real.coeffs());
        result.dual = Quaternionf(scalar * dual.coeffs());
        return result;
    }

    void normalize() {
        float norm = real.norm();
        real = Quaternionf(real.coeffs() / norm);
        dual = Quaternionf(dual.coeffs() / norm);
    }

    Vector3f transform_point(const Vector3f& point) const {
        // ä»åŒå››å…ƒæ•°æ¢å¤å˜æ¢å¹¶åº”ç”¨
        Vector3f translation = 2.0f * (dual * real.conjugate()).vec();
        return real * point + translation;
    }
};

void deform_with_dual_quaternions(const std::vector<Matrix4f>& bone_matrices) {
    for (int i = 0; i < bind_positions.size(); ++i) {
        const VertexWeight& weight = vertex_weights[i];

        DualQuaternion blended_dq;

        for (int j = 0; j < 4; ++j) {
            if (weight.weights[j] > 0.0f) {
                int bone_index = weight.bone_indices[j];
                DualQuaternion bone_dq(bone_matrices[bone_index]);

                // ç¡®ä¿å››å…ƒæ•°åœ¨åŒä¸€åŠçƒ
                if (j > 0 && blended_dq.real.dot(bone_dq.real) < 0) {
                    bone_dq = bone_dq * (-1.0f);
                }

                blended_dq = blended_dq + bone_dq * weight.weights[j];
            }
        }

        blended_dq.normalize();
        deformed_positions[i] = blended_dq.transform_point(bind_positions[i]);
    }
}
```

## ç‰©ç†ä»¿çœŸæ•°å­¦åŸºç¡€

## 22.1 ç‰›é¡¿åŠ›å­¦åŸºç¡€

### 22.1.1 è¿åŠ¨å­¦æ–¹ç¨‹çš„æ•°å­¦åŸºç¡€

#### åŸºæœ¬è¿åŠ¨é‡çš„å®šä¹‰

**ä½ç½®ã€é€Ÿåº¦ã€åŠ é€Ÿåº¦çš„æ•°å­¦å…³ç³»**ï¼š

åŸºæœ¬ç‰©ç†é‡å®šä¹‰ï¼š

ä½ç½®ï¼š
$$\mathbf{x}(t) \in \mathbb{R}^3$$

é€Ÿåº¦ï¼š
$$\mathbf{v}(t) = \frac{d\mathbf{x}}{dt}$$

åŠ é€Ÿåº¦ï¼š
$$\mathbf{a}(t) = \frac{d\mathbf{v}}{dt} = \frac{d^2\mathbf{x}}{dt^2}$$

#### åŒ€åŠ é€Ÿè¿åŠ¨çš„è§£æè§£

**å¸¸åŠ é€Ÿåº¦è¿åŠ¨æ–¹ç¨‹**ï¼š
å½“åŠ é€Ÿåº¦ $\mathbf{a}$ ä¸ºå¸¸æ•°æ—¶ï¼Œè¿åŠ¨æ–¹ç¨‹çš„è§£æè§£ä¸ºï¼š

**å¸¸åŠ é€Ÿåº¦è¿åŠ¨æ–¹ç¨‹**ï¼š

é€Ÿåº¦æ–¹ç¨‹ï¼š
$$\mathbf{v}(t) = \mathbf{v}_0 + \mathbf{a}t$$

ä½ç½®æ–¹ç¨‹ï¼š
$$\mathbf{x}(t) = \mathbf{x}_0 + \mathbf{v}_0 t + \frac{1}{2}\mathbf{a}t^2$$

**æ¨å¯¼è¿‡ç¨‹**ï¼š
ä»åŠ é€Ÿåº¦çš„å®šä¹‰å‡ºå‘ï¼š
$$\frac{d\mathbf{v}}{dt} = \mathbf{a}$$

ç§¯åˆ†å¾—åˆ°ï¼š
$$\mathbf{v}(t) = \int_0^t \mathbf{a} \, d\tau + \mathbf{v}_0 = \mathbf{a}t + \mathbf{v}_0$$

å†æ¬¡ç§¯åˆ†ï¼š
$$\mathbf{x}(t) = \int_0^t \mathbf{v}(\tau) \, d\tau + \mathbf{x}_0 = \int_0^t (\mathbf{a}\tau + \mathbf{v}_0) \, d\tau + \mathbf{x}_0 = \frac{1}{2}\mathbf{a}t^2 + \mathbf{v}_0 t + \mathbf{x}_0$$

**ä»£ç å®ç°**ï¼š

```cpp
struct Particle {
    Vector2D position;
    Vector2D velocity;
    Vector2D acceleration;
    Vector2D forces;
    float mass;
    bool pinned;

    void update_euler(float dt) {
        if (pinned) return;

        acceleration = forces / mass;
        velocity += acceleration * dt;
        position += velocity * dt;

        // æ¸…é™¤åŠ›
        forces = Vector2D(0, 0);
    }

    void update_verlet(float dt, Vector2D gravity) {
        if (pinned) return;

        Vector2D new_position = position + (position - last_position) + acceleration * dt * dt;
        last_position = position;
        position = new_position;
    }

private:
    Vector2D last_position;  // Verletç§¯åˆ†éœ€è¦
};
```

### 22.1.2 ç‰›é¡¿ç¬¬äºŒå®šå¾‹çš„æ•°å­¦è¡¨è¿°

#### ç‰›é¡¿ç¬¬äºŒå®šå¾‹çš„å‘é‡å½¢å¼

**åŸºæœ¬å½¢å¼**ï¼š
$$\mathbf{F} = m\mathbf{a}$$

å…¶ä¸­ $\mathbf{F}$ æ˜¯ä½œç”¨åœ¨è´¨é‡ä¸º $m$ çš„ç‰©ä½“ä¸Šçš„åˆå¤–åŠ›ï¼Œ$\mathbf{a}$ æ˜¯ç‰©ä½“çš„åŠ é€Ÿåº¦ã€‚

**å¾®åˆ†æ–¹ç¨‹å½¢å¼**ï¼š
$$\mathbf{F} = m\frac{d^2\mathbf{x}}{dt^2}$$

è¿™æ˜¯ä¸€ä¸ªäºŒé˜¶å¸¸å¾®åˆ†æ–¹ç¨‹ï¼Œæè¿°äº†åŠ›ä¸è¿åŠ¨çš„å…³ç³»ã€‚

#### å¤šåŠ›ä½œç”¨çš„å åŠ åŸç†

**åŠ›çš„å åŠ **ï¼š
å½“å¤šä¸ªåŠ›åŒæ—¶ä½œç”¨åœ¨ç‰©ä½“ä¸Šæ—¶ï¼Œæ ¹æ®åŠ›çš„å åŠ åŸç†ï¼š
$$\sum_{i=1}^{n} \mathbf{F}_i = m\mathbf{a}$$

å› æ­¤åŠ é€Ÿåº¦ä¸ºï¼š
$$\mathbf{a} = \frac{1}{m}\sum_{i=1}^{n} \mathbf{F}_i = \frac{\mathbf{F}_1 + \mathbf{F}_2 + \cdots + \mathbf{F}_n}{m}$$

#### å¸¸è§åŠ›çš„æ•°å­¦æ¨¡å‹

**é‡åŠ›**ï¼š
$$\mathbf{F}_{gravity} = m\mathbf{g}$$

**å¼¹æ€§åŠ›ï¼ˆèƒ¡å…‹å®šå¾‹ï¼‰**ï¼š
$$\mathbf{F}_{spring} = -k(\|\mathbf{x} - \mathbf{x}_0\| - L_0)\frac{\mathbf{x} - \mathbf{x}_0}{\|\mathbf{x} - \mathbf{x}_0\|}$$

**é˜»å°¼åŠ›**ï¼š
$$\mathbf{F}_{damping} = -\gamma\mathbf{v}$$

å…¶ä¸­ $\gamma$ æ˜¯é˜»å°¼ç³»æ•°ã€‚

**åœ¨ä»¿çœŸä¸­çš„åº”ç”¨**ï¼š

```cpp
class ForceAccumulator {
private:
    Vector2D total_force;

public:
    void clear() {
        total_force = Vector2D(0, 0);
    }

    void add_force(const Vector2D& force) {
        total_force += force;
    }

    void add_gravity(float mass, const Vector2D& gravity) {
        total_force += mass * gravity;
    }

    void add_spring_force(const Vector2D& position, const Vector2D& other_position,
                         float rest_length, float spring_constant) {
        Vector2D displacement = other_position - position;
        float current_length = displacement.norm();

        if (current_length > 0) {
            Vector2D direction = displacement / current_length;
            float extension = current_length - rest_length;
            Vector2D spring_force = spring_constant * extension * direction;
            total_force += spring_force;
        }
    }

    void add_damping_force(const Vector2D& velocity, float damping_coefficient) {
        total_force -= damping_coefficient * velocity;
    }

    Vector2D get_total_force() const {
        return total_force;
    }
};
```

### 22.1.3 èƒ½é‡å®ˆæ’

**æœºæ¢°èƒ½**ï¼š
$$E = K + U = \frac{1}{2}mv^2 + U(x)$$

**åŠ¨èƒ½**ï¼š
$$K = \frac{1}{2}mv^2$$

**åŠ¿èƒ½ç¤ºä¾‹**ï¼š

- **é‡åŠ›åŠ¿èƒ½**ï¼š$U = mgh$
- **å¼¹æ€§åŠ¿èƒ½**ï¼š$U = \frac{1}{2}kx^2$

**èƒ½é‡å®ˆæ’éªŒè¯**ï¼š

```cpp
class EnergyMonitor {
public:
    float calculate_kinetic_energy(const std::vector<Mass*>& masses) {
        float total_ke = 0.0f;
        for (const auto& mass : masses) {
            if (!mass->pinned) {
                float speed_squared = mass->velocity.norm2();
                total_ke += 0.5f * mass->mass * speed_squared;
            }
        }
        return total_ke;
    }

    float calculate_gravitational_potential(const std::vector<Mass*>& masses,
                                          const Vector2D& gravity) {
        float total_pe = 0.0f;
        for (const auto& mass : masses) {
            // å‡è®¾é‡åŠ›å‘ä¸‹ï¼Œyåæ ‡è¶Šé«˜åŠ¿èƒ½è¶Šå¤§
            total_pe += mass->mass * (-gravity.y) * mass->position.y;
        }
        return total_pe;
    }

    float calculate_elastic_potential(const std::vector<Spring*>& springs) {
        float total_pe = 0.0f;
        for (const auto& spring : springs) {
            Vector2D displacement = spring->m2->position - spring->m1->position;
            float current_length = displacement.norm();
            float extension = current_length - spring->rest_length;
            total_pe += 0.5f * spring->k * extension * extension;
        }
        return total_pe;
    }

    float calculate_total_energy(const std::vector<Mass*>& masses,
                               const std::vector<Spring*>& springs,
                               const Vector2D& gravity) {
        return calculate_kinetic_energy(masses) +
               calculate_gravitational_potential(masses, gravity) +
               calculate_elastic_potential(springs);
    }
};
```

## 22.2 å¼¹ç°§-è´¨ç‚¹ç³»ç»Ÿ

### 22.2.1 èƒ¡å…‹å®šå¾‹

**åŸºæœ¬å½¢å¼**ï¼š
$$F = -kx$$
å…¶ä¸­kæ˜¯å¼¹ç°§å¸¸æ•°ï¼Œxæ˜¯å½¢å˜é‡

**å‘é‡å½¢å¼**ï¼š

```cpp
Vector2D calculate_spring_force(const Vector2D& pos1, const Vector2D& pos2,
                               float rest_length, float spring_constant) {
    Vector2D displacement = pos2 - pos1;
    float current_length = displacement.norm();

    if (current_length < EPSILON) {
        return Vector2D(0, 0);  // é¿å…é™¤é›¶
    }

    Vector2D direction = displacement / current_length;
    float extension = current_length - rest_length;

    // èƒ¡å…‹å®šå¾‹ï¼š$F = k \times å½¢å˜é‡ \times æ–¹å‘$
    return spring_constant * extension * direction;
}
```

### 22.2.2 é˜»å°¼åŠ›

**çº¿æ€§é˜»å°¼**ï¼š
$$F_{damping} = -\gamma v$$

**å¼¹ç°§é˜»å°¼**ï¼š

```cpp
Vector2D calculate_spring_damping(const Vector2D& vel1, const Vector2D& vel2,
                                 const Vector2D& spring_direction,
                                 float damping_coefficient) {
    // ç›¸å¯¹é€Ÿåº¦
    Vector2D relative_velocity = vel2 - vel1;

    // æ²¿å¼¹ç°§æ–¹å‘çš„é€Ÿåº¦åˆ†é‡
    float velocity_along_spring = relative_velocity.dot(spring_direction);

    // é˜»å°¼åŠ›åªä½œç”¨äºå¼¹ç°§æ–¹å‘
    return -damping_coefficient * velocity_along_spring * spring_direction;
}
```

### 22.2.3 å®Œæ•´çš„å¼¹ç°§-è´¨ç‚¹ç³»ç»Ÿ

**åŸºäºGAMES101 Assignment8çš„å®ç°**ï¼š

```cpp
class Mass {
public:
    Vector2D position;
    Vector2D last_position;  // Verletç§¯åˆ†ç”¨
    Vector2D velocity;
    Vector2D forces;
    float mass;
    bool pinned;

    Mass(Vector2D pos, float m, bool pin = false)
        : position(pos), last_position(pos), velocity(0, 0),
          forces(0, 0), mass(m), pinned(pin) {}
};

class Spring {
public:
    Mass* m1;
    Mass* m2;
    float rest_length;
    float k;  // å¼¹ç°§å¸¸æ•°

    Spring(Mass* mass1, Mass* mass2, float spring_constant)
        : m1(mass1), m2(mass2), k(spring_constant) {
        Vector2D displacement = m2->position - m1->position;
        rest_length = displacement.norm();
    }

    void apply_force() {
        Vector2D displacement = m2->position - m1->position;
        float current_length = displacement.norm();

        if (current_length < EPSILON) return;

        Vector2D direction = displacement / current_length;
        float extension = current_length - rest_length;
        Vector2D spring_force = k * extension * direction;

        // ç‰›é¡¿ç¬¬ä¸‰å®šå¾‹ï¼šä½œç”¨åŠ›ä¸åä½œç”¨åŠ›
        m1->forces += spring_force;
        m2->forces -= spring_force;
    }
};

class Rope {
private:
    std::vector<Mass*> masses;
    std::vector<Spring*> springs;

public:
    Rope(Vector2D start, Vector2D end, int num_nodes, float node_mass,
         float spring_k, std::vector<int> pinned_nodes) {

        // åˆ›å»ºè´¨ç‚¹
        for (int i = 0; i å…‰çº¿ä¼ è¾“çš„ç‰©ç†æ„ä¹‰ num_nodes; ++i) {
            float t = static_cast<float>(i) / (num_nodes - 1);
            Vector2D position = start + t * (end - start);
            bool is_pinned = std::find(pinned_nodes.begin(), pinned_nodes.end(), i)
                           != pinned_nodes.end();
            masses.push_back(new Mass(position, node_mass, is_pinned));
        }

        // åˆ›å»ºå¼¹ç°§
        for (int i = 0; i < num_nodes - 1; ++i) {
            springs.push_back(new Spring(masses[i], masses[i + 1], spring_k));
        }
    }

    void simulate_euler(float delta_t, Vector2D gravity) {
        // 1. è®¡ç®—å¼¹ç°§åŠ›
        for (auto& spring : springs) {
            spring->apply_force();
        }

        // 2. æ›´æ–°è´¨ç‚¹
        for (auto& mass : masses) {
            if (!mass->pinned) {
                // æ·»åŠ é‡åŠ›
                mass->forces += mass->mass * gravity;

                // æ¬§æ‹‰ç§¯åˆ†
                Vector2D acceleration = mass->forces / mass->mass;
                mass->velocity += acceleration * delta_t;
                mass->position += mass->velocity * delta_t;

                // å…¨å±€é˜»å°¼
                mass->velocity *= 0.99f;
            }

            // æ¸…é™¤åŠ›
            mass->forces = Vector2D(0, 0);
        }
    }

    void simulate_verlet(float delta_t, Vector2D gravity) {
        // 1. è®¡ç®—çº¦æŸåŠ›ï¼ˆå¼¹ç°§åŠ›ï¼‰
        for (auto& spring : springs) {
            // Verletç§¯åˆ†ä¸­ï¼Œæˆ‘ä»¬ç›´æ¥è°ƒæ•´ä½ç½®æ¥æ»¡è¶³çº¦æŸ
            Vector2D displacement = spring->m2->position - spring->m1->position;
            float current_length = displacement.norm();

            if (current_length > EPSILON) {
                Vector2D direction = displacement / current_length;
                float difference = current_length - spring->rest_length;
                Vector2D correction = 0.5f * difference * direction;

                if (!spring->m1->pinned) {
                    spring->m1->position += correction;
                }
                if (!spring->m2->pinned) {
                    spring->m2->position -= correction;
                }
            }
        }

        // 2. Verletç§¯åˆ†
        for (auto& mass : masses) {
            if (!mass->pinned) {
                Vector2D temp_position = mass->position;

                // Verletå…¬å¼ï¼š$x(t+dt) = 2x(t) - x(t-dt) + a \cdot dt^2$
                Vector2D acceleration = gravity;  // åªè€ƒè™‘é‡åŠ›
                mass->position = 2.0f * mass->position - mass->last_position +
                               acceleration * delta_t * delta_t;

                mass->last_position = temp_position;

                // Verleté˜»å°¼
                mass->position = mass->position * 0.99f + mass->last_position * 0.01f;
            }
        }
    }
};
```

## 22.3 æ•°å€¼ç§¯åˆ†æ–¹æ³•

### 22.3.1 æ˜¾å¼æ¬§æ‹‰æ³•

**åŸºæœ¬å…¬å¼**ï¼š

```
x(t+h) = x(t) + hÂ·v(t)
v(t+h) = v(t) + hÂ·a(t)
```

**ä¼˜ç¼ºç‚¹**ï¼š

- âœ… **ä¼˜ç‚¹**ï¼šç®€å•æ˜“å®ç°ï¼Œè®¡ç®—é‡å°
- âŒ **ç¼ºç‚¹**ï¼šæ•°å€¼ä¸ç¨³å®šï¼Œèƒ½é‡ä¸å®ˆæ’ï¼Œå¤§æ—¶é—´æ­¥é•¿ä¼šå‘æ•£

**ç¨³å®šæ€§åˆ†æ**ï¼š

```cpp
// å¼¹ç°§-è´¨ç‚¹ç³»ç»Ÿçš„ç¨³å®šæ€§æ¡ä»¶
float calculate_max_stable_timestep(float mass, float spring_constant) {
    // å¯¹äºå¼¹ç°§-è´¨ç‚¹ç³»ç»Ÿï¼š$dt < \frac{2}{\omega}$ï¼Œå…¶ä¸­$\omega = \sqrt{\frac{k}{m}}$
    float omega = std::sqrt(spring_constant / mass);
    return 2.0f / omega;
}

void adaptive_euler_integration(Rope& rope, float target_dt, Vector2D gravity) {
    float max_safe_dt = calculate_max_stable_timestep(rope.get_min_mass(),
                                                     rope.get_max_spring_constant());

    if (target_dt <= max_safe_dt) {
        rope.simulate_euler(target_dt, gravity);
    } else {
        // åˆ†å‰²æ—¶é—´æ­¥
        int substeps = static_cast<int>(std::ceil(target_dt / max_safe_dt));
        float substep_dt = target_dt / substeps;

        for (int i = 0; i < substeps; ++i) {
            rope.simulate_euler(substep_dt, gravity);
        }
    }
}
```

### 22.3.2 Verletç§¯åˆ†

**ä½ç½®Verlet**ï¼š

```
$$x(t+h) = 2x(t) - x(t-h) + a(t)h^2$$
```

**é€Ÿåº¦Verlet**ï¼š
$$x(t+h) = x(t) + v(t)h + \frac{1}{2}a(t)h^2$$
$$v(t+h) = v(t) + \frac{1}{2}[a(t) + a(t+h)]h$$

**ä¼˜åŠ¿**ï¼š

- æ—¶é—´å¯é€†æ€§
- æ›´å¥½çš„èƒ½é‡å®ˆæ’
- å¯¹äºçº¦æŸç³»ç»Ÿæ›´ç¨³å®š

**å®ç°ç»†èŠ‚**ï¼š

```cpp
class VerletIntegrator {
public:
    static void integrate_position(Mass& mass, float dt, const Vector2D& acceleration) {
        if (mass.pinned) return;

        Vector2D new_position = mass.position + (mass.position - mass.last_position) +
                               acceleration * dt * dt;
        mass.last_position = mass.position;
        mass.position = new_position;
    }

    static void integrate_velocity(Mass& mass, float dt, const Vector2D& old_acceleration,
                                  const Vector2D& new_acceleration) {
        if (mass.pinned) return;

        // é€Ÿåº¦Verletï¼šv(t+dt) = v(t) + 0.5*[a(t) + a(t+dt)]*dt
        mass.velocity += 0.5f * (old_acceleration + new_acceleration) * dt;
    }

    static Vector2D calculate_velocity_from_positions(const Mass& mass, float dt) {
        // ä»ä½ç½®å·®åˆ†ä¼°ç®—é€Ÿåº¦
        return (mass.position - mass.last_position) / dt;
    }
};
```

### 22.3.3 éšå¼ç§¯åˆ†æ–¹æ³•

**éšå¼æ¬§æ‹‰**ï¼š

```
x(t+h) = x(t) + hÂ·v(t+h)
v(t+h) = v(t) + hÂ·a(t+h)
```

**éœ€è¦æ±‚è§£çº¿æ€§ç³»ç»Ÿ**ï¼š

```cpp
class ImplicitEulerSolver {
private:
    // ç³»ç»ŸçŸ©é˜µï¼š$(M - h^2K)\Delta v = h(F + hKv)$
    // M: è´¨é‡çŸ©é˜µ, K: åˆšåº¦çŸ©é˜µ, F: å¤–åŠ›

public:
    void solve_implicit_step(std::vector<Mass*>& masses,
                           std::vector<Spring*>& springs,
                           float dt, const Vector2D& gravity) {
        int n = masses.size();

        // æ„å»ºç³»ç»ŸçŸ©é˜µå’Œå³ç«¯å‘é‡
        Eigen::MatrixXf system_matrix = Eigen::MatrixXf::Zero(2*n, 2*n);
        Eigen::VectorXf rhs = Eigen::VectorXf::Zero(2*n);

        // è´¨é‡çŸ©é˜µéƒ¨åˆ†
        for (int i = 0; i < n; ++i) {
            if (!masses[i]->pinned) {
                float mass = masses[i]->mass;
                system_matrix(2*i, 2*i) = mass;
                system_matrix(2*i+1, 2*i+1) = mass;
            }
        }

        // åˆšåº¦çŸ©é˜µéƒ¨åˆ†
        for (const auto& spring : springs) {
            add_spring_to_system_matrix(system_matrix, spring, dt);
        }

        // å¤–åŠ›
        for (int i = 0; i < n; ++i) {
            if (!masses[i]->pinned) {
                Vector2D force = masses[i]->mass * gravity;
                rhs(2*i) = dt * force.x;
                rhs(2*i+1) = dt * force.y;
            }
        }

        // æ±‚è§£çº¿æ€§ç³»ç»Ÿ
        Eigen::VectorXf delta_v = system_matrix.ldlt().solve(rhs);

        // æ›´æ–°é€Ÿåº¦å’Œä½ç½®
        for (int i = 0; i < n; ++i) {
            if (!masses[i]->pinned) {
                masses[i]->velocity.x += delta_v(2*i);
                masses[i]->velocity.y += delta_v(2*i+1);
                masses[i]->position += dt * masses[i]->velocity;
            }
        }
    }

private:
    void add_spring_to_system_matrix(Eigen::MatrixXf& matrix, Spring* spring, float dt) {
        // æ·»åŠ å¼¹ç°§åˆšåº¦åˆ°ç³»ç»ŸçŸ©é˜µ
        // è¿™é‡Œéœ€è¦è®¡ç®—å¼¹ç°§çš„é›…å¯æ¯”çŸ©é˜µ
        // å®ç°ç»†èŠ‚è¾ƒå¤æ‚ï¼Œæ¶‰åŠéçº¿æ€§å¼¹ç°§åŠ›çš„çº¿æ€§åŒ–
    }
};
```

### 22.3.4 Runge-Kuttaæ–¹æ³•

**å››é˜¶Runge-Kuttaï¼ˆRK4ï¼‰**ï¼š

```cpp
class RungeKuttaIntegrator {
public:
    static void rk4_step(Mass& mass, float dt,
                        std::function<Vector2D(const Vector2D&, const Vector2D&)> force_function) {
        if (mass.pinned) return;

        Vector2D x0 = mass.position;
        Vector2D v0 = mass.velocity;

        // k1
        Vector2D k1_v = dt * (force_function(x0, v0) / mass.mass);
        Vector2D k1_x = dt * v0;

        // k2
        Vector2D k2_v = dt * (force_function(x0 + 0.5f * k1_x, v0 + 0.5f * k1_v) / mass.mass);
        Vector2D k2_x = dt * (v0 + 0.5f * k1_v);

        // k3
        Vector2D k3_v = dt * (force_function(x0 + 0.5f * k2_x, v0 + 0.5f * k2_v) / mass.mass);
        Vector2D k3_x = dt * (v0 + 0.5f * k2_v);

        // k4
        Vector2D k4_v = dt * (force_function(x0 + k3_x, v0 + k3_v) / mass.mass);
        Vector2D k4_x = dt * (v0 + k3_v);

        // æ›´æ–°
        mass.velocity = v0 + (k1_v + 2.0f * k2_v + 2.0f * k3_v + k4_v) / 6.0f;
        mass.position = x0 + (k1_x + 2.0f * k2_x + 2.0f * k3_x + k4_x) / 6.0f;
    }
};
```

## 22.4 çº¦æŸæ±‚è§£

### 22.4.1 ä½ç½®çº¦æŸ

**è·ç¦»çº¦æŸ**ï¼š
$$C(\mathbf{x}_1, \mathbf{x}_2) = \|\mathbf{x}_2 - \mathbf{x}_1\| - L = 0$$

**çº¦æŸæŠ•å½±æ–¹æ³•**ï¼š

```cpp
void satisfy_distance_constraint(Mass* m1, Mass* m2, float rest_length) {
    Vector2D displacement = m2->position - m1->position;
    float current_length = displacement.norm();

    if (current_length < EPSILON) return;

    Vector2D direction = displacement / current_length;
    float difference = current_length - rest_length;
    Vector2D correction = 0.5f * difference * direction;

    // æ ¹æ®è´¨é‡åˆ†é…ä¿®æ­£é‡
    float total_mass = m1->mass + m2->mass;
    float w1 = m2->mass / total_mass;  // è´¨é‡è¶Šå¤§ï¼Œä¿®æ­£è¶Šå°
    float w2 = m1->mass / total_mass;

    if (!m1->pinned) {
        m1->position += w1 * correction;
    }
    if (!m2->pinned) {
        m2->position -= w2 * correction;
    }
}
```

### 22.4.2 Position Based Dynamics (PBD)

**åŸºæœ¬ç®—æ³•æµç¨‹**ï¼š

```cpp
class PBDSolver {
public:
    void simulate_step(std::vector<Mass*>& masses,
                      std::vector<Constraint*>& constraints,
                      float dt, const Vector2D& gravity) {
        // 1. é¢„æµ‹ä½ç½®
        for (auto& mass : masses) {
            if (!mass->pinned) {
                mass->velocity += dt * gravity;
                mass->predicted_position = mass->position + dt * mass->velocity;
            }
        }

        // 2. è¿­ä»£æ±‚è§£çº¦æŸ
        for (int iter = 0; iter < solver_iterations; ++iter) {
            for (auto& constraint : constraints) {
                constraint->project(masses);
            }
        }

        // 3. æ›´æ–°é€Ÿåº¦å’Œä½ç½®
        for (auto& mass : masses) {
            if (!mass->pinned) {
                mass->velocity = (mass->predicted_position - mass->position) / dt;
                mass->position = mass->predicted_position;
            }
        }
    }

private:
    int solver_iterations = 5;
};

class DistanceConstraint : public Constraint {
private:
    int index1, index2;
    float rest_length;
    float stiffness;

public:
    void project(std::vector<Mass*>& masses) override {
        Mass* m1 = masses[index1];
        Mass* m2 = masses[index2];

        Vector2D displacement = m2->predicted_position - m1->predicted_position;
        float current_length = displacement.norm();

        if (current_length < EPSILON) return;

        Vector2D direction = displacement / current_length;
        float constraint_value = current_length - rest_length;

        // è®¡ç®—ä¿®æ­£é‡
        float w1 = m1->pinned ? 0.0f : 1.0f / m1->mass;
        float w2 = m2->pinned ? 0.0f : 1.0f / m2->mass;
        float lambda = -constraint_value / (w1 + w2);

        Vector2D correction1 = stiffness * lambda * w1 * direction;
        Vector2D correction2 = -stiffness * lambda * w2 * direction;

        if (!m1->pinned) {
            m1->predicted_position += correction1;
        }
        if (!m2->pinned) {
            m2->predicted_position += correction2;
        }
    }
};
```

---

## è´¨ç‚¹å¼¹ç°§ç³»ç»Ÿ

## 23.1 ç³»ç»Ÿå»ºæ¨¡

### 23.1.1 è´¨ç‚¹å¼¹ç°§ç³»ç»Ÿçš„æ•°å­¦å»ºæ¨¡

#### ç³»ç»Ÿçš„æ•°å­¦æè¿°

**çŠ¶æ€å‘é‡**ï¼š
è´¨ç‚¹å¼¹ç°§ç³»ç»Ÿçš„çŠ¶æ€å¯ä»¥ç”¨çŠ¶æ€å‘é‡æè¿°ï¼š
$$\mathbf{s} = \begin{pmatrix} \mathbf{x}_1 \\ \mathbf{v}_1 \\ \mathbf{x}_2 \\ \mathbf{v}_2 \\ \vdots \\ \mathbf{x}_n \\ \mathbf{v}_n \end{pmatrix} \in \mathbb{R}^{6n}$$

å…¶ä¸­ $\mathbf{x}_i \in \mathbb{R}^3$ æ˜¯ç¬¬ $i$ ä¸ªè´¨ç‚¹çš„ä½ç½®ï¼Œ$\mathbf{v}_i \in \mathbb{R}^3$ æ˜¯é€Ÿåº¦ã€‚

**ç³»ç»ŸåŠ¨åŠ›å­¦æ–¹ç¨‹**ï¼š
$$\frac{d\mathbf{s}}{dt} = \begin{pmatrix} \mathbf{v}_1 \\ \mathbf{a}_1 \\ \mathbf{v}_2 \\ \mathbf{a}_2 \\ \vdots \\ \mathbf{v}_n \\ \mathbf{a}_n \end{pmatrix}$$

å…¶ä¸­åŠ é€Ÿåº¦ $\mathbf{a}_i = \frac{\mathbf{F}_i}{m_i}$ ç”±ç‰›é¡¿ç¬¬äºŒå®šå¾‹ç¡®å®šã€‚

#### æ‹“æ‰‘ç»“æ„çš„æ•°å­¦è¡¨ç¤º

**é‚»æ¥çŸ©é˜µ**ï¼š
ç³»ç»Ÿçš„è¿æ¥å…³ç³»å¯ä»¥ç”¨é‚»æ¥çŸ©é˜µ $\mathbf{A} \in \{0,1\}^{n \times n}$ è¡¨ç¤ºï¼š

é‚»æ¥çŸ©é˜µå…ƒç´ å®šä¹‰ï¼š

å½“è´¨ç‚¹ $i$ å’Œ $j$ ä¹‹é—´æœ‰å¼¹ç°§è¿æ¥æ—¶ï¼š$A_{ij} = 1$

å…¶ä»–æƒ…å†µï¼š$A_{ij} = 0$

**é“¾å¼ç»“æ„ï¼ˆç»³å­ï¼‰çš„æ•°å­¦æ¨¡å‹**ï¼š

```cpp
class RopeTopology {
public:
    static std::vector<Spring*> create_chain(std::vector<Mass*>& masses, float k) {
        std::vector<Spring*> springs;

        for (int i = 0; i < masses.size() - 1; ++i) {
            springs.push_back(new Spring(masses[i], masses[i + 1], k));
        }

        return springs;
    }
};
```

**ç½‘æ ¼ç»“æ„ï¼ˆå¸ƒæ–™ï¼‰**ï¼š

```cpp
class ClothTopology {
public:
    static std::vector<Spring*> create_cloth_springs(
        std::vector<std::vector<Mass*>>& mass_grid, float k) {

        std::vector<Spring*> springs;
        int rows = mass_grid.size();
        int cols = mass_grid[0].size();

        // ç»“æ„å¼¹ç°§ï¼ˆç›¸é‚»è´¨ç‚¹ï¼‰
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols; ++j) {
                // æ°´å¹³å¼¹ç°§
                if (j < cols - 1) {
                    springs.push_back(new Spring(mass_grid[i][j], mass_grid[i][j + 1], k));
                }
                // å‚ç›´å¼¹ç°§
                if (i < rows - 1) {
                    springs.push_back(new Spring(mass_grid[i][j], mass_grid[i + 1][j], k));
                }
            }
        }

        // å‰ªåˆ‡å¼¹ç°§ï¼ˆå¯¹è§’çº¿ï¼‰
        for (int i = 0; i < rows - 1; ++i) {
            for (int j = 0; j < cols - 1; ++j) {
                springs.push_back(new Spring(mass_grid[i][j], mass_grid[i + 1][j + 1], k * 0.5f));
                springs.push_back(new Spring(mass_grid[i + 1][j], mass_grid[i][j + 1], k * 0.5f));
            }
        }

        // å¼¯æ›²å¼¹ç°§ï¼ˆè·¨è¶Šä¸€ä¸ªè´¨ç‚¹ï¼‰
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < cols - 2; ++j) {
                springs.push_back(new Spring(mass_grid[i][j], mass_grid[i][j + 2], k * 0.25f));
            }
        }
        for (int i = 0; i < rows - 2; ++i) {
            for (int j = 0; j < cols; ++j) {
                springs.push_back(new Spring(mass_grid[i][j], mass_grid[i + 2][j], k * 0.25f));
            }
        }

        return springs;
    }
};
```

### 23.1.2 ææ–™å±æ€§

**å¼¹æ€§æ¨¡é‡ä¸å¼¹ç°§å¸¸æ•°çš„å…³ç³»**ï¼š
$$k = \frac{E \times A}{L}$$
å…¶ä¸­Eæ˜¯æ¨æ°æ¨¡é‡ï¼ŒAæ˜¯æˆªé¢ç§¯ï¼ŒLæ˜¯åŸé•¿

**ä¸åŒææ–™çš„å‚æ•°**ï¼š

```cpp
struct MaterialProperties {
    float youngs_modulus;     // æ¨æ°æ¨¡é‡ (Pa)
    float density;            // å¯†åº¦ $(kg/m^3)$
    float poisson_ratio;      // æ³Šæ¾æ¯”
    float damping_coefficient; // é˜»å°¼ç³»æ•°

    static MaterialProperties steel() {
        return {200e9f, 7850.0f, 0.3f, 0.01f};
    }

    static MaterialProperties rubber() {
        return {0.01e9f, 1000.0f, 0.5f, 0.1f};
    }

    static MaterialProperties cotton() {
        return {5e9f, 1500.0f, 0.4f, 0.05f};
    }
};

float calculate_spring_constant(const MaterialProperties& material,
                               float cross_section_area, float length) {
    return (material.youngs_modulus * cross_section_area) / length;
}
```

## 23.2 é«˜çº§å¼¹ç°§æ¨¡å‹

### 23.2.1 éçº¿æ€§å¼¹ç°§

**æŒ‡æ•°å¼¹ç°§æ¨¡å‹**ï¼š

```cpp
class NonlinearSpring : public Spring {
private:
    float exponential_factor;

public:
    Vector2D calculate_force() override {
        Vector2D displacement = m2->position - m1->position;
        float current_length = displacement.norm();

        if (current_length < EPSILON) return Vector2D(0, 0);

        Vector2D direction = displacement / current_length;
        float strain = (current_length - rest_length) / rest_length;

        // éçº¿æ€§åŠ›ï¼š$F = k \times strain \times \exp(\alpha \times |strain|)$
        float force_magnitude = k * strain * std::exp(exponential_factor * std::abs(strain));

        return force_magnitude * direction;
    }
};
```

**åˆ†æ®µçº¿æ€§å¼¹ç°§**ï¼š

```cpp
class PiecewiseLinearSpring : public Spring {
private:
    struct ForceSegment {
        float strain_start;
        float strain_end;
        float stiffness;
    };

    std::vector<ForceSegment> segments;

public:
    Vector2D calculate_force() override {
        Vector2D displacement = m2->position - m1->position;
        float current_length = displacement.norm();

        if (current_length < EPSILON) return Vector2D(0, 0);

        Vector2D direction = displacement / current_length;
        float strain = (current_length - rest_length) / rest_length;

        // æ‰¾åˆ°å¯¹åº”çš„åˆšåº¦æ®µ
        float stiffness = k;  // é»˜è®¤åˆšåº¦
        for (const auto& segment : segments) {
            if (strain >= segment.strain_start && strain < segment.strain_end) {
                stiffness = segment.stiffness;
                break;
            }
        }

        float force_magnitude = stiffness * strain * rest_length;
        return force_magnitude * direction;
    }
};
```

### 23.2.2 å¼¹å¡‘æ€§æ¨¡å‹

**å¡‘æ€§å˜å½¢**ï¼š

```cpp
class PlasticSpring : public Spring {
private:
    float yield_strain;      // å±ˆæœåº”å˜
    float plastic_modulus;   // å¡‘æ€§æ¨¡é‡
    float accumulated_plastic_strain;

public:
    Vector2D calculate_force() override {
        Vector2D displacement = m2->position - m1->position;
        float current_length = displacement.norm();

        if (current_length < EPSILON) return Vector2D(0, 0);

        Vector2D direction = displacement / current_length;
        float total_strain = (current_length - rest_length) / rest_length;
        float elastic_strain = total_strain - accumulated_plastic_strain;

        // æ£€æŸ¥æ˜¯å¦è¶…è¿‡å±ˆæœç‚¹
        if (std::abs(elastic_strain) > yield_strain) {
            float excess_strain = std::abs(elastic_strain) - yield_strain;
            float strain_sign = (elastic_strain > 0) ? 1.0f : -1.0f;

            // æ›´æ–°å¡‘æ€§åº”å˜
            accumulated_plastic_strain += strain_sign * excess_strain;
            elastic_strain = strain_sign * yield_strain;
        }

        float force_magnitude = k * elastic_strain * rest_length;
        return force_magnitude * direction;
    }
};
```

## 23.3 ç¢°æ’æ£€æµ‹ä¸å“åº”

### 23.3.1 è´¨ç‚¹-å¹³é¢ç¢°æ’

**ç¢°æ’æ£€æµ‹**ï¼š

```cpp
struct Plane {
    Vector2D point;
    Vector2D normal;

    float distance_to_point(const Vector2D& p) const {
        return (p - point).dot(normal);
    }
};

bool check_particle_plane_collision(const Mass& mass, const Plane& plane,
                                   float& penetration_depth) {
    float distance = plane.distance_to_point(mass.position);

    if (distance < 0) {
        penetration_depth = -distance;
        return true;
    }

    return false;
}
```

**ç¢°æ’å“åº”**ï¼š

```cpp
void resolve_particle_plane_collision(Mass& mass, const Plane& plane,
                                     float restitution_coefficient) {
    float penetration;
    if (!check_particle_plane_collision(mass, plane, penetration)) return;

    // ä½ç½®ä¿®æ­£
    mass.position += penetration * plane.normal;

    // é€Ÿåº¦ä¿®æ­£
    float velocity_normal = mass.velocity.dot(plane.normal);
    if (velocity_normal < 0) {  // åªå¤„ç†æœå‘å¹³é¢çš„é€Ÿåº¦
        Vector2D velocity_normal_component = velocity_normal * plane.normal;
        Vector2D velocity_tangential = mass.velocity - velocity_normal_component;

        // æ³•å‘é€Ÿåº¦åå¼¹
        Vector2D new_velocity_normal = -restitution_coefficient * velocity_normal_component;

        // åˆ‡å‘æ‘©æ“¦
        float friction_coefficient = 0.3f;
        Vector2D friction_force = -friction_coefficient * velocity_tangential;

        mass.velocity = new_velocity_normal + velocity_tangential + friction_force;
    }
}
```

### 23.3.2 è‡ªç¢°æ’æ£€æµ‹

**ç©ºé—´å“ˆå¸Œ**ï¼š

```cpp
class SpatialHash {
private:
    float cell_size;
    std::unordered_map<int, std::vector<Mass*>> hash_table;

    int hash_position(const Vector2D& pos) {
        int x = static_cast<int>(pos.x / cell_size);
        int y = static_cast<int>(pos.y / cell_size);
        return x * 73856093 ^ y * 19349663;  // å¤§è´¨æ•°å“ˆå¸Œ
    }

public:
    void clear() {
        hash_table.clear();
    }

    void insert(Mass* mass) {
        int hash = hash_position(mass->position);
        hash_table[hash].push_back(mass);
    }

    std::vector<Mass*> query_nearby(const Vector2D& position, float radius) {
        std::vector<Mass*> nearby_masses;

        // æ£€æŸ¥å‘¨å›´çš„9ä¸ªæ ¼å­
        for (int dx = -1; dx <= 1; ++dx) {
            for (int dy = -1; dy <= 1; ++dy) {
                Vector2D offset_pos = position + Vector2D(dx * cell_size, dy * cell_size);
                int hash = hash_position(offset_pos);

                auto it = hash_table.find(hash);
                if (it != hash_table.end()) {
                    for (Mass* mass : it->second) {
                        float distance = (mass->position - position).norm();
                        if (distance <= radius) {
                            nearby_masses.push_back(mass);
                        }
                    }
                }
            }
        }

        return nearby_masses;
    }
};
```

**è¿ç»­ç¢°æ’æ£€æµ‹**ï¼š

```cpp
bool continuous_collision_detection(const Mass& mass1, const Mass& mass2,
                                   float dt, float& collision_time) {
    Vector2D relative_position = mass2.position - mass1.position;
    Vector2D relative_velocity = mass2.velocity - mass1.velocity;
    float min_distance = 0.1f;  // æœ€å°å®‰å…¨è·ç¦»

    // æ±‚è§£äºŒæ¬¡æ–¹ç¨‹ï¼š$|p + v \cdot t|^2 = min\_distance^2$
    float a = relative_velocity.norm2();
    float b = 2.0f * relative_position.dot(relative_velocity);
    float c = relative_position.norm2() - min_distance * min_distance;

    float discriminant = b * b - 4 * a * c;

    if (discriminant >= 0 && a > EPSILON) {
        float t1 = (-b - std::sqrt(discriminant)) / (2 * a);
        float t2 = (-b + std::sqrt(discriminant)) / (2 * a);

        // é€‰æ‹©åœ¨æ—¶é—´æ­¥å†…çš„æœ€æ—©ç¢°æ’æ—¶é—´
        if (t1 >= 0 && t1 <= dt) {
            collision_time = t1;
            return true;
        } else if (t2 >= 0 && t2 <= dt) {
            collision_time = t2;
            return true;
        }
    }

    return false;
}
```

---

## æ•°å€¼ç§¯åˆ†æ–¹æ³•

## 24.1 ç¨³å®šæ€§åˆ†æ

### 24.1.1 çº¿æ€§ç¨³å®šæ€§ç†è®º

#### çº¿æ€§ç³»ç»Ÿçš„ç¨³å®šæ€§åˆ†æ

**çº¿æ€§å¸¸å¾®åˆ†æ–¹ç¨‹ç³»ç»Ÿ**ï¼š
è€ƒè™‘çº¿æ€§ç³»ç»Ÿï¼š
$$\frac{d\mathbf{x}}{dt} = \mathbf{A}\mathbf{x}$$

å…¶ä¸­ $\mathbf{A} \in \mathbb{R}^{n \times n}$ æ˜¯ç³»ç»ŸçŸ©é˜µã€‚

**è§£æè§£çš„ç¨³å®šæ€§**ï¼š
è§£æè§£ä¸º $\mathbf{x}(t) = e^{\mathbf{A}t}\mathbf{x}_0$ï¼Œç³»ç»Ÿç¨³å®šå½“ä¸”ä»…å½“ $\mathbf{A}$ çš„æ‰€æœ‰ç‰¹å¾å€¼ $\lambda_i$ æ»¡è¶³ $\text{Re}(\lambda_i) \leq 0$ã€‚

#### æ•°å€¼æ–¹æ³•çš„ç¨³å®šæ€§

**æ˜¾å¼æ¬§æ‹‰æ³•çš„æ”¾å¤§å› å­**ï¼š
æ˜¾å¼æ¬§æ‹‰æ³•ï¼š$\mathbf{x}_{n+1} = \mathbf{x}_n + h\mathbf{A}\mathbf{x}_n = (\mathbf{I} + h\mathbf{A})\mathbf{x}_n$

æ”¾å¤§å› å­ä¸ºï¼š$G = 1 + h\lambda$

**ç¨³å®šæ€§æ¡ä»¶**ï¼š
æ•°å€¼è§£ç¨³å®šå½“ä¸”ä»…å½“ï¼š
$$|1 + h\lambda| \leq 1$$

å¯¹äºæ‰€æœ‰ç‰¹å¾å€¼ $\lambda$ã€‚

**ç¨³å®šåŸŸåˆ†æ**ï¼š

- **å®ç‰¹å¾å€¼**ï¼š$\lambda \in \mathbb{R}$ï¼Œç¨³å®šæ¡ä»¶ä¸º $-2 \leq h\lambda \leq 0$
- **å¤ç‰¹å¾å€¼**ï¼š$\lambda = \alpha + i\beta$ï¼Œç¨³å®šåŸŸä¸ºå¤å¹³é¢ä¸Šä»¥ $(-1, 0)$ ä¸ºåœ†å¿ƒï¼ŒåŠå¾„ä¸º 1 çš„åœ†ç›˜

#### æ—¶é—´æ­¥é•¿çš„é€‰æ‹©

**æœ€å¤§ç¨³å®šæ—¶é—´æ­¥é•¿**ï¼š
$$h_{max} = \frac{2}{|\lambda_{max}|}$$

å…¶ä¸­ $\lambda_{max}$ æ˜¯ç³»ç»ŸçŸ©é˜µçš„æœ€å¤§ç‰¹å¾å€¼ï¼ˆæŒ‰æ¨¡é•¿ï¼‰ã€‚

**ç¨³å®šæ€§æµ‹è¯•**ï¼š

```cpp
class StabilityAnalyzer {
public:
    static bool is_euler_stable(float eigenvalue_real, float eigenvalue_imag, float dt) {
        std::complex<float> lambda(eigenvalue_real, eigenvalue_imag);
        std::complex<float> amplification_factor = 1.0f + lambda * dt;
        return std::abs(amplification_factor) <= 1.0f;
    }

    static float max_stable_timestep_euler(float max_eigenvalue_magnitude) {
        // å¯¹äºå®ç‰¹å¾å€¼ï¼š$dt < \frac{2}{|\lambda_{max}|}$
        return 2.0f / max_eigenvalue_magnitude;
    }

    static void analyze_spring_system_stability(float mass, float spring_constant) {
        float omega = std::sqrt(spring_constant / mass);
        float max_dt = 2.0f / omega;

        std::cout << "å¼¹ç°§ç³»ç»Ÿç¨³å®šæ€§åˆ†æ:\n";
        std::cout << "  å›ºæœ‰é¢‘ç‡: " << omega << " rad/s\n";
        std::cout << "  æœ€å¤§ç¨³å®šæ—¶é—´æ­¥: " << max_dt << " s\n";
        std::cout << "  å»ºè®®æ—¶é—´æ­¥: " << max_dt * 0.5f << " s\n";
    }
};
```

### 24.1.2 èƒ½é‡å®ˆæ’æ€§

**èƒ½é‡æ¼‚ç§»ç›‘æ§**ï¼š

```cpp
class EnergyConservationMonitor {
private:
    float initial_energy;
    std::vector<float> energy_history;

public:
    void initialize(const std::vector<Mass*>& masses,
                   const std::vector<Spring*>& springs,
                   const Vector2D& gravity) {
        EnergyMonitor monitor;
        initial_energy = monitor.calculate_total_energy(masses, springs, gravity);
        energy_history.clear();
    }

    void record_energy(const std::vector<Mass*>& masses,
                      const std::vector<Spring*>& springs,
                      const Vector2D& gravity) {
        EnergyMonitor monitor;
        float current_energy = monitor.calculate_total_energy(masses, springs, gravity);
        energy_history.push_back(current_energy);
    }

    float calculate_energy_drift() const {
        if (energy_history.empty()) return 0.0f;

        float current_energy = energy_history.back();
        return std::abs(current_energy - initial_energy) / initial_energy;
    }

    void print_energy_statistics() const {
        if (energy_history.size() < 2) return;

        float min_energy = *std::min_element(energy_history.begin(), energy_history.end());
        float max_energy = *std::max_element(energy_history.begin(), energy_history.end());
        float energy_range = max_energy - min_energy;

        std::cout << "èƒ½é‡å®ˆæ’ç»Ÿè®¡:\n";
        std::cout << "  åˆå§‹èƒ½é‡: " << initial_energy << "\n";
        std::cout << "  èƒ½é‡èŒƒå›´: [" << min_energy << ", " << max_energy << "]\n";
        std::cout << "  èƒ½é‡æ¼‚ç§»: " << calculate_energy_drift() * 100 << "%\n";
        std::cout << "  èƒ½é‡æŒ¯è¡: " << energy_range / initial_energy * 100 << "%\n";
    }
};
```

## 24.2 è‡ªé€‚åº”æ—¶é—´æ­¥é•¿

### 24.2.1 è¯¯å·®ä¼°è®¡

**Richardsonå¤–æ¨æ³•**ï¼š

```cpp
class AdaptiveTimestepper {
private:
    float tolerance;
    float min_dt;
    float max_dt;

public:
    float estimate_optimal_timestep(Rope& rope, float current_dt, const Vector2D& gravity) {
        // ä¿å­˜å½“å‰çŠ¶æ€
        auto saved_state = rope.save_state();

        // ç”¨å½“å‰æ—¶é—´æ­¥ç§¯åˆ†ä¸€æ­¥
        rope.simulate_euler(current_dt, gravity);
        auto state_full_step = rope.save_state();

        // æ¢å¤çŠ¶æ€ï¼Œç”¨ä¸¤ä¸ªåŠæ­¥ç§¯åˆ†
        rope.restore_state(saved_state);
        rope.simulate_euler(current_dt * 0.5f, gravity);
        rope.simulate_euler(current_dt * 0.5f, gravity);
        auto state_half_steps = rope.save_state();

        // è®¡ç®—è¯¯å·®
        float error = calculate_state_difference(state_full_step, state_half_steps);

        // æ¢å¤åŸå§‹çŠ¶æ€
        rope.restore_state(saved_state);

        // æ ¹æ®è¯¯å·®è°ƒæ•´æ—¶é—´æ­¥
        float safety_factor = 0.8f;
        float new_dt = current_dt * safety_factor * std::pow(tolerance / error, 0.2f);

        return std::clamp(new_dt, min_dt, max_dt);
    }

private:
    float calculate_state_difference(const RopeState& state1, const RopeState& state2) {
        float max_position_diff = 0.0f;

        for (int i = 0; i < state1.positions.size(); ++i) {
            float diff = (state1.positions[i] - state2.positions[i]).norm();
            max_position_diff = std::max(max_position_diff, diff);
        }

        return max_position_diff;
    }
};
```

### 24.2.2 CFLæ¡ä»¶

**Courant-Friedrichs-Lewyæ¡ä»¶**ï¼š

```cpp
class CFLCondition {
public:
    static float calculate_cfl_timestep(const std::vector<Spring*>& springs,
                                       const std::vector<Mass*>& masses) {
        float min_dt = std::numeric_limits<float>::max();

        for (const auto& spring : springs) {
            // è®¡ç®—å¼¹ç°§çš„æ³¢é€Ÿ
            float reduced_mass = (spring->m1->mass * spring->m2->mass) /
                               (spring->m1->mass + spring->m2->mass);
            float wave_speed = std::sqrt(spring->k / reduced_mass);

            // CFLæ¡ä»¶ï¼šdt < dx / c
            float element_length = spring->rest_length;
            float cfl_dt = element_length / wave_speed;

            min_dt = std::min(min_dt, cfl_dt);
        }

        return 0.5f * min_dt;  // å®‰å…¨ç³»æ•°
    }

    static void print_cfl_analysis(const std::vector<Spring*>& springs,
                                  const std::vector<Mass*>& masses) {
        float cfl_dt = calculate_cfl_timestep(springs, masses);

        std::cout << "CFLç¨³å®šæ€§åˆ†æ:\n";
        std::cout << "  CFLæ—¶é—´æ­¥é™åˆ¶: " << cfl_dt << " s\n";
        std::cout << "  å¯¹åº”é¢‘ç‡: " << 1.0f / cfl_dt << " Hz\n";
    }
};
```

## 24.3 é«˜é˜¶ç§¯åˆ†æ–¹æ³•

### 24.3.1 å¤šæ­¥æ³•

**Adams-Bashforthæ–¹æ³•**ï¼š

```cpp
class AdamsBashforthIntegrator {
private:
    std::deque<Vector2D> acceleration_history;
    int order;

public:
    AdamsBashforthIntegrator(int method_order) : order(method_order) {}

    void integrate_step(Mass& mass, float dt, const Vector2D& current_acceleration) {
        if (mass.pinned) return;

        acceleration_history.push_back(current_acceleration);

        if (acceleration_history.size() > order) {
            acceleration_history.pop_front();
        }

        Vector2D velocity_increment(0, 0);

        if (acceleration_history.size() == 1) {
            // ä¸€é˜¶ï¼ˆæ˜¾å¼æ¬§æ‹‰ï¼‰
            velocity_increment = dt * acceleration_history[0];
        } else if (acceleration_history.size() == 2) {
            // äºŒé˜¶Adams-Bashforth
            velocity_increment = dt * (1.5f * acceleration_history[1] -
                                     0.5f * acceleration_history[0]);
        } else if (acceleration_history.size() >= 3) {
            // ä¸‰é˜¶Adams-Bashforth
            velocity_increment = dt * (23.0f/12.0f * acceleration_history[2] -
                                     16.0f/12.0f * acceleration_history[1] +
                                     5.0f/12.0f * acceleration_history[0]);
        }

        mass.velocity += velocity_increment;
        mass.position += dt * mass.velocity;
    }
};
```

### 24.3.2 é¢„æµ‹-æ ¡æ­£æ–¹æ³•

**Adams-Bashforth-Moultonæ–¹æ³•**ï¼š

```cpp
class PredictorCorrectorIntegrator {
public:
    void integrate_step(Mass& mass, float dt,
                       std::function<Vector2D(const Mass&)> force_function) {
        if (mass.pinned) return;

        // é¢„æµ‹æ­¥ï¼ˆAdams-Bashforthï¼‰
        Vector2D current_acceleration = force_function(mass) / mass.mass;
        Vector2D predicted_velocity = mass.velocity + dt * current_acceleration;
        Vector2D predicted_position = mass.position + dt * predicted_velocity;

        // åˆ›å»ºé¢„æµ‹çŠ¶æ€
        Mass predicted_mass = mass;
        predicted_mass.position = predicted_position;
        predicted_mass.velocity = predicted_velocity;

        // æ ¡æ­£æ­¥ï¼ˆAdams-Moultonï¼‰
        Vector2D predicted_acceleration = force_function(predicted_mass) / mass.mass;
        Vector2D corrected_velocity = mass.velocity +
            0.5f * dt * (current_acceleration + predicted_acceleration);
        Vector2D corrected_position = mass.position +
            0.5f * dt * (mass.velocity + corrected_velocity);

        mass.velocity = corrected_velocity;
        mass.position = corrected_position;
    }
};
```

## 24.4 ä¸“ç”¨ç‰©ç†ç§¯åˆ†å™¨

### 24.4.1 è¾›ç§¯åˆ†å™¨

**StÃ¶rmer-Verletæ–¹æ³•**ï¼š

```cpp
class SymplecticIntegrator {
public:
    // ä¿æŒå“ˆå¯†é¡¿ç³»ç»Ÿçš„è¾›ç»“æ„
    static void stormer_verlet_step(Mass& mass, float dt,
                                   std::function<Vector2D(const Vector2D&)> force_function) {
        if (mass.pinned) return;

        // ä½ç½®åŠæ­¥æ›´æ–°
        mass.position += 0.5f * dt * mass.velocity;

        // è®¡ç®—æ–°ä½ç½®çš„åŠ›
        Vector2D force = force_function(mass.position);
        Vector2D acceleration = force / mass.mass;

        // é€Ÿåº¦å…¨æ­¥æ›´æ–°
        mass.velocity += dt * acceleration;

        // ä½ç½®åŠæ­¥æ›´æ–°
        mass.position += 0.5f * dt * mass.velocity;
    }

    // Leapfrogæ–¹æ³•ï¼ˆç­‰ä»·äºStÃ¶rmer-Verletï¼‰
    static void leapfrog_step(Mass& mass, float dt,
                             std::function<Vector2D(const Vector2D&)> force_function) {
        if (mass.pinned) return;

        // é€Ÿåº¦åœ¨åŠæ—¶é—´æ­¥æ›´æ–°
        Vector2D force = force_function(mass.position);
        Vector2D acceleration = force / mass.mass;
        mass.velocity += 0.5f * dt * acceleration;

        // ä½ç½®å…¨æ—¶é—´æ­¥æ›´æ–°
        mass.position += dt * mass.velocity;

        // è®¡ç®—æ–°ä½ç½®çš„åŠ›å¹¶å®Œæˆé€Ÿåº¦æ›´æ–°
        force = force_function(mass.position);
        acceleration = force / mass.mass;
        mass.velocity += 0.5f * dt * acceleration;
    }
};
```

### 24.4.2 çº¦æŸä¿æŒç§¯åˆ†å™¨

**SHAKEç®—æ³•**ï¼š

```cpp
class SHAKEIntegrator {
private:
    float tolerance;
    int max_iterations;

public:
    void integrate_with_constraints(std::vector<Mass*>& masses,
                                   std::vector<DistanceConstraint*>& constraints,
                                   float dt, const Vector2D& gravity) {
        // 1. æ— çº¦æŸçš„Verletæ­¥
        for (auto& mass : masses) {
            if (!mass->pinned) {
                Vector2D acceleration = gravity;
                Vector2D new_position = 2.0f * mass->position - mass->last_position +
                                       acceleration * dt * dt;
                mass->last_position = mass->position;
                mass->position = new_position;
            }
        }

        // 2. è¿­ä»£æ»¡è¶³çº¦æŸ
        for (int iter = 0; iter < max_iterations; ++iter) {
            bool converged = true;

            for (auto& constraint : constraints) {
                float constraint_error = constraint->evaluate(masses);

                if (std::abs(constraint_error) > tolerance) {
                    converged = false;
                    constraint->apply_correction(masses, dt);
                }
            }

            if (converged) break;
        }

        // 3. æ›´æ–°é€Ÿåº¦
        for (auto& mass : masses) {
            if (!mass->pinned) {
                mass->velocity = (mass->position - mass->last_position) / dt;
            }
        }
    }
};

class DistanceConstraint {
private:
    int index1, index2;
    float target_distance;

public:
    float evaluate(const std::vector<Mass*>& masses) {
        Vector2D displacement = masses[index2]->position - masses[index1]->position;
        float current_distance = displacement.norm();
        return current_distance - target_distance;
    }

    void apply_correction(std::vector<Mass*>& masses, float dt) {
        Mass* m1 = masses[index1];
        Mass* m2 = masses[index2];

        Vector2D displacement = m2->position - m1->position;
        float current_distance = displacement.norm();

        if (current_distance < EPSILON) return;

        Vector2D direction = displacement / current_distance;
        float constraint_error = current_distance - target_distance;

        // è®¡ç®—æ‹‰æ ¼æœ—æ—¥ä¹˜æ•°
        float w1 = m1->pinned ? 0.0f : 1.0f / m1->mass;
        float w2 = m2->pinned ? 0.0f : 1.0f / m2->mass;
        float lambda = -constraint_error / (w1 + w2);

        // åº”ç”¨ä½ç½®ä¿®æ­£
        Vector2D correction1 = lambda * w1 * direction;
        Vector2D correction2 = -lambda * w2 * direction;

        if (!m1->pinned) m1->position += correction1;
        if (!m2->pinned) m2->position += correction2;
    }
};
```

è¿™ä¸ªå®Œæ•´çš„æ•°å€¼ç§¯åˆ†æ¡†æ¶ä¸ºç‰©ç†ä»¿çœŸæä¾›äº†åšå®çš„æ•°å­¦åŸºç¡€ï¼Œç¡®ä¿äº†ä»¿çœŸçš„ç¨³å®šæ€§å’Œç²¾åº¦ã€‚

---

## å®æ—¶æ¸²æŸ“ä¼˜åŒ–æŠ€æœ¯

## 25.1 å±‚æ¬¡ç»†èŠ‚(LOD)æŠ€æœ¯

### 25.1.1 LODçš„æ•°å­¦åŸºç¡€

**è·ç¦»åŸºç¡€LOD**ï¼š
$$LOD_{level} = \left\lfloor \log_2\left(\frac{distance}{base\_distance}\right) \right\rfloor$$

å…¶ä¸­ï¼š

- $distance$ æ˜¯ç‰©ä½“åˆ°ç›¸æœºçš„è·ç¦»
- $base\_distance$ æ˜¯åŸºå‡†è·ç¦»
- $LOD_{level}$ æ˜¯ç»†èŠ‚å±‚æ¬¡ç­‰çº§

**å±å¹•ç©ºé—´è¯¯å·®åº¦é‡**ï¼š
$$error_{screen} = \frac{error_{world} \times focal\_length}{distance \times pixel\_size}$$

### 25.1.2 å‡ ä½•LODå®ç°

```cpp
class GeometricLOD {
private:
    struct LODLevel {
        Mesh mesh;
        float distance_threshold;
        int triangle_count;
        float geometric_error;
    };

    std::vector<LODLevel> lod_levels;

public:
    void generate_lod_chain(const Mesh& original_mesh, int num_levels) {
        lod_levels.clear();
        lod_levels.resize(num_levels);

        // åŸå§‹ç½‘æ ¼ä½œä¸ºLOD 0
        lod_levels[0] = {original_mesh, 0.0f,
                        original_mesh.triangle_count(), 0.0f};

        // ç”Ÿæˆç®€åŒ–ç‰ˆæœ¬
        for (int i = 1; i < num_levels; ++i) {
            float reduction_ratio = std::pow(0.5f, i);
            lod_levels[i].mesh = simplify_mesh(original_mesh, reduction_ratio);
            lod_levels[i].distance_threshold = calculate_distance_threshold(i);
            lod_levels[i].triangle_count = lod_levels[i].mesh.triangle_count();
            lod_levels[i].geometric_error = calculate_geometric_error(
                original_mesh, lod_levels[i].mesh);
        }
    }

    const Mesh& select_lod(const Vector3f& camera_pos, const Vector3f& object_pos) {
        float distance = (camera_pos - object_pos).norm();

        for (int i = lod_levels.size() - 1; i >= 0; --i) {
            if (distance >= lod_levels[i].distance_threshold) {
                return lod_levels[i].mesh;
            }
        }

        return lod_levels[0].mesh;  // æœ€é«˜ç»†èŠ‚
    }

private:
    Mesh simplify_mesh(const Mesh& mesh, float reduction_ratio) {
        // ä½¿ç”¨äºŒæ¬¡è¯¯å·®åº¦é‡è¿›è¡Œç½‘æ ¼ç®€åŒ–
        QuadricErrorMetrics qem(mesh);
        return qem.simplify(reduction_ratio);
    }

    float calculate_distance_threshold(int lod_level) {
        // åŸºäºå±å¹•ç©ºé—´è¯¯å·®çš„è·ç¦»é˜ˆå€¼
        float base_distance = 10.0f;
        return base_distance * std::pow(2.0f, lod_level);
    }

    float calculate_geometric_error(const Mesh& original, const Mesh& simplified) {
        // è®¡ç®—Hausdorffè·ç¦»ä½œä¸ºå‡ ä½•è¯¯å·®
        float max_error = 0.0f;

        for (const auto& vertex : simplified.vertices) {
            float min_distance = std::numeric_limits<float>::max();

            for (const auto& orig_vertex : original.vertices) {
                float distance = (vertex.position - orig_vertex.position).norm();
                min_distance = std::min(min_distance, distance);
            }

            max_error = std::max(max_error, min_distance);
        }

        return max_error;
    }
};
```

## 25.2 é®æŒ¡å‰”é™¤æŠ€æœ¯

### 25.2.1 è§†é”¥ä½“å‰”é™¤

**å¹³é¢æ–¹ç¨‹**ï¼š
$$ax + by + cz + d = 0$$

**ç‚¹åˆ°å¹³é¢è·ç¦»**ï¼š
$$distance = \frac{|ax_0 + by_0 + cz_0 + d|}{\sqrt{a^2 + b^2 + c^2}}$$

```cpp
class FrustumCuller {
private:
    struct Plane {
        Vector3f normal;
        float distance;

        float distance_to_point(const Vector3f& point) const {
            return normal.dot(point) + distance;
        }

        bool is_point_inside(const Vector3f& point) const {
            return distance_to_point(point) >= 0;
        }
    };

    std::array<Plane, 6> frustum_planes;  // å·¦å³ä¸Šä¸‹è¿œè¿‘

public:
    void extract_frustum_planes(const Matrix4f& view_projection_matrix) {
        // ä»MVPçŸ©é˜µæå–è§†é”¥ä½“å¹³é¢
        Matrix4f mvp = view_projection_matrix.transpose();

        // å·¦å¹³é¢: mvp.row(3) + mvp.row(0)
        frustum_planes[0] = extract_plane(mvp.row(3) + mvp.row(0));

        // å³å¹³é¢: mvp.row(3) - mvp.row(0)
        frustum_planes[1] = extract_plane(mvp.row(3) - mvp.row(0));

        // ä¸‹å¹³é¢: mvp.row(3) + mvp.row(1)
        frustum_planes[2] = extract_plane(mvp.row(3) + mvp.row(1));

        // ä¸Šå¹³é¢: mvp.row(3) - mvp.row(1)
        frustum_planes[3] = extract_plane(mvp.row(3) - mvp.row(1));

        // è¿‘å¹³é¢: mvp.row(3) + mvp.row(2)
        frustum_planes[4] = extract_plane(mvp.row(3) + mvp.row(2));

        // è¿œå¹³é¢: mvp.row(3) - mvp.row(2)
        frustum_planes[5] = extract_plane(mvp.row(3) - mvp.row(2));
    }

    bool is_aabb_visible(const AABB& aabb) const {
        for (const auto& plane : frustum_planes) {
            // è®¡ç®—AABBçš„æ­£é¡¶ç‚¹ï¼ˆæœ€è¿œç‚¹ï¼‰
            Vector3f positive_vertex = aabb.min;

            if (plane.normal.x() >= 0) positive_vertex.x() = aabb.max.x();
            if (plane.normal.y() >= 0) positive_vertex.y() = aabb.max.y();
            if (plane.normal.z() >= 0) positive_vertex.z() = aabb.max.z();

            // å¦‚æœæ­£é¡¶ç‚¹åœ¨å¹³é¢å¤–ä¾§ï¼Œåˆ™AABBå®Œå…¨åœ¨è§†é”¥ä½“å¤–
            if (plane.distance_to_point(positive_vertex) < 0) {
                return false;
            }
        }

        return true;
    }

    bool is_sphere_visible(const Vector3f& center, float radius) const {
        for (const auto& plane : frustum_planes) {
            if (plane.distance_to_point(center) < -radius) {
                return false;
            }
        }

        return true;
    }

private:
    Plane extract_plane(const Vector4f& plane_coeffs) {
        Vector3f normal = plane_coeffs.head<3>();
        float length = normal.norm();

        return {normal / length, plane_coeffs.w() / length};
    }
};
```

### 25.2.2 é®æŒ¡æŸ¥è¯¢

```cpp
class OcclusionCuller {
private:
    struct OcclusionQuery {
        GLuint query_id;
        bool result_available;
        GLuint sample_count;

        OcclusionQuery() {
            glGenQueries(1, &query_id);
            result_available = false;
            sample_count = 0;
        }

        ~OcclusionQuery() {
            glDeleteQueries(1, &query_id);
        }
    };

    std::unordered_map<uint32_t, std::unique_ptr<OcclusionQuery>> queries;

public:
    void begin_occlusion_test(uint32_t object_id) {
        auto& query = get_or_create_query(object_id);

        // å¼€å§‹é®æŒ¡æŸ¥è¯¢
        glBeginQuery(GL_SAMPLES_PASSED, query->query_id);

        // ç¦ç”¨é¢œè‰²å’Œæ·±åº¦å†™å…¥ï¼Œåªæµ‹è¯•é®æŒ¡
        glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
        glDepthMask(GL_FALSE);
    }

    void end_occlusion_test(uint32_t object_id) {
        glEndQuery(GL_SAMPLES_PASSED);

        // æ¢å¤æ¸²æŸ“çŠ¶æ€
        glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
        glDepthMask(GL_TRUE);

        auto& query = queries[object_id];
        query->result_available = false;
    }

    bool is_object_visible(uint32_t object_id, float visibility_threshold = 0.0f) {
        auto it = queries.find(object_id);
        if (it == queries.end()) {
            return true;  // é»˜è®¤å¯è§
        }

        auto& query = it->second;

        if (!query->result_available) {
            GLint available;
            glGetQueryObjectiv(query->query_id, GL_QUERY_RESULT_AVAILABLE, &available);

            if (available) {
                glGetQueryObjectuiv(query->query_id, GL_QUERY_RESULT, &query->sample_count);
                query->result_available = true;
            } else {
                return true;  // ç»“æœæœªå‡†å¤‡å¥½ï¼Œå‡è®¾å¯è§
            }
        }

        return query->sample_count > visibility_threshold;
    }

private:
    std::unique_ptr<OcclusionQuery>& get_or_create_query(uint32_t object_id) {
        auto it = queries.find(object_id);
        if (it == queries.end()) {
            queries[object_id] = std::make_unique<OcclusionQuery>();
        }
        return queries[object_id];
    }
};
```

## 25.3 GPUæ€§èƒ½ä¼˜åŒ–

### 25.3.1 æ‰¹å¤„ç†ä¼˜åŒ–

```cpp
class BatchRenderer {
private:
    struct BatchData {
        std::vector<Matrix4f> model_matrices;
        std::vector<Vector4f> colors;
        std::vector<Vector2f> texture_coords;
        GLuint vao, vbo, instance_vbo;
        int instance_count;

        BatchData() : instance_count(0) {
            glGenVertexArrays(1, &vao);
            glGenBuffers(1, &vbo);
            glGenBuffers(1, &instance_vbo);
        }

        ~BatchData() {
            glDeleteVertexArrays(1, &vao);
            glDeleteBuffers(1, &vbo);
            glDeleteBuffers(1, &instance_vbo);
        }
    };

    std::unordered_map<uint32_t, std::unique_ptr<BatchData>> batches;

public:
    void add_instance(uint32_t batch_id, const Matrix4f& model_matrix,
                     const Vector4f& color, const Vector2f& tex_coord) {
        auto& batch = get_or_create_batch(batch_id);

        batch->model_matrices.push_back(model_matrix);
        batch->colors.push_back(color);
        batch->texture_coords.push_back(tex_coord);
        batch->instance_count++;
    }

    void render_batch(uint32_t batch_id, const Mesh& mesh, const Shader& shader) {
        auto it = batches.find(batch_id);
        if (it == batches.end() || it->second->instance_count == 0) {
            return;
        }

        auto& batch = it->second;

        // æ›´æ–°å®ä¾‹æ•°æ®
        update_instance_buffer(*batch);

        // ç»‘å®šVAOå’Œè®¾ç½®é¡¶ç‚¹å±æ€§
        glBindVertexArray(batch->vao);
        setup_vertex_attributes(mesh, *batch);

        // ä½¿ç”¨ç€è‰²å™¨
        shader.use();

        // å®ä¾‹åŒ–æ¸²æŸ“
        glDrawElementsInstanced(GL_TRIANGLES, mesh.index_count(),
                               GL_UNSIGNED_INT, 0, batch->instance_count);

        // æ¸…ç©ºæ‰¹æ¬¡æ•°æ®
        clear_batch(*batch);
    }

private:
    std::unique_ptr<BatchData>& get_or_create_batch(uint32_t batch_id) {
        auto it = batches.find(batch_id);
        if (it == batches.end()) {
            batches[batch_id] = std::make_unique<BatchData>();
        }
        return batches[batch_id];
    }

    void update_instance_buffer(BatchData& batch) {
        glBindBuffer(GL_ARRAY_BUFFER, batch.instance_vbo);

        // è®¡ç®—æ€»æ•°æ®å¤§å°
        size_t matrix_size = batch.model_matrices.size() * sizeof(Matrix4f);
        size_t color_size = batch.colors.size() * sizeof(Vector4f);
        size_t texcoord_size = batch.texture_coords.size() * sizeof(Vector2f);
        size_t total_size = matrix_size + color_size + texcoord_size;

        // åˆ†é…ç¼“å†²åŒº
        glBufferData(GL_ARRAY_BUFFER, total_size, nullptr, GL_DYNAMIC_DRAW);

        // ä¸Šä¼ æ•°æ®
        glBufferSubData(GL_ARRAY_BUFFER, 0, matrix_size, batch.model_matrices.data());
        glBufferSubData(GL_ARRAY_BUFFER, matrix_size, color_size, batch.colors.data());
        glBufferSubData(GL_ARRAY_BUFFER, matrix_size + color_size, texcoord_size,
                       batch.texture_coords.data());
    }

    void setup_vertex_attributes(const Mesh& mesh, const BatchData& batch) {
        // è®¾ç½®ç½‘æ ¼é¡¶ç‚¹å±æ€§
        mesh.bind_vertex_attributes();

        // è®¾ç½®å®ä¾‹å±æ€§
        size_t matrix_size = batch.model_matrices.size() * sizeof(Matrix4f);
        size_t color_size = batch.colors.size() * sizeof(Vector4f);

        glBindBuffer(GL_ARRAY_BUFFER, batch.instance_vbo);

        // æ¨¡å‹çŸ©é˜µï¼ˆ4ä¸ªvec4ï¼‰
        for (int i = 0; i < 4; ++i) {
            glEnableVertexAttribArray(3 + i);
            glVertexAttribPointer(3 + i, 4, GL_FLOAT, GL_FALSE, sizeof(Matrix4f),
                                 (void*)(i * sizeof(Vector4f)));
            glVertexAttribDivisor(3 + i, 1);
        }

        // é¢œè‰²
        glEnableVertexAttribArray(7);
        glVertexAttribPointer(7, 4, GL_FLOAT, GL_FALSE, sizeof(Vector4f),
                             (void*)matrix_size);
        glVertexAttribDivisor(7, 1);

        // çº¹ç†åæ ‡
        glEnableVertexAttribArray(8);
        glVertexAttribPointer(8, 2, GL_FLOAT, GL_FALSE, sizeof(Vector2f),
                             (void*)(matrix_size + color_size));
        glVertexAttribDivisor(8, 1);
    }

    void clear_batch(BatchData& batch) {
        batch.model_matrices.clear();
        batch.colors.clear();
        batch.texture_coords.clear();
        batch.instance_count = 0;
    }
};
```

---

## åŸºäºç‰©ç†çš„æ¸²æŸ“(PBR)

## 26.1 PBRç†è®ºåŸºç¡€

### 26.1.1 æ¸²æŸ“æ–¹ç¨‹

**å®Œæ•´æ¸²æŸ“æ–¹ç¨‹**ï¼š
$$L_o(p, \omega_o) = L_e(p, \omega_o) + \int_{\Omega} f_r(p, \omega_i, \omega_o) L_i(p, \omega_i) (\omega_i \cdot n) d\omega_i$$

å…¶ä¸­ï¼š

- $L_o(p, \omega_o)$ æ˜¯ä»ç‚¹på‘æ–¹å‘$\omega_o$çš„å‡ºå°„è¾å°„åº¦
- $L_e(p, \omega_o)$ æ˜¯è‡ªå‘å…‰
- $f_r(p, \omega_i, \omega_o)$ æ˜¯åŒå‘åå°„åˆ†å¸ƒå‡½æ•°(BRDF)
- $L_i(p, \omega_i)$ æ˜¯å…¥å°„è¾å°„åº¦
- $(\omega_i \cdot n)$ æ˜¯Lambertä½™å¼¦å®šå¾‹

### 26.1.2 BRDFæ¨¡å‹

**Cook-Torrance BRDF**ï¼š
$$f_r = k_d f_{lambert} + k_s f_{cook-torrance}$$

å…¶ä¸­ï¼š
$$f_{lambert} = \frac{c}{\pi}$$
$$f_{cook-torrance} = \frac{DFG}{4(\omega_o \cdot n)(\omega_i \cdot n)}$$

**æ³•çº¿åˆ†å¸ƒå‡½æ•°(D)**ï¼š
$$D_{GGX}(n, h, \alpha) = \frac{\alpha^2}{\pi((n \cdot h)^2(\alpha^2 - 1) + 1)^2}$$

**å‡ ä½•å‡½æ•°(G)**ï¼š
$$G(n, v, l, k) = G_1(n, v, k) G_1(n, l, k)$$
$$G_1(n, v, k) = \frac{n \cdot v}{(n \cdot v)(1 - k) + k}$$

**è²æ¶…å°”é¡¹(F)**ï¼š
$$F_{Schlick}(h, v, F_0) = F_0 + (1 - F_0)(1 - (h \cdot v))^5$$

```cpp
class PBRMaterial {
private:
    Vector3f albedo;
    float metallic;
    float roughness;
    float ao;  // ç¯å¢ƒé®æŒ¡
    Vector3f F0;  // åŸºç¡€åå°„ç‡

public:
    PBRMaterial(const Vector3f& albedo, float metallic, float roughness, float ao = 1.0f)
        : albedo(albedo), metallic(metallic), roughness(roughness), ao(ao) {
        // è®¡ç®—åŸºç¡€åå°„ç‡
        F0 = Vector3f(0.04f, 0.04f, 0.04f);  // éé‡‘å±é»˜è®¤å€¼
        F0 = F0 * (1.0f - metallic) + albedo * metallic;
    }

    Vector3f evaluate_brdf(const Vector3f& light_dir, const Vector3f& view_dir,
                          const Vector3f& normal) const {
        Vector3f h = (light_dir + view_dir).normalized();

        float NdotV = std::max(normal.dot(view_dir), 0.0f);
        float NdotL = std::max(normal.dot(light_dir), 0.0f);
        float HdotV = std::max(h.dot(view_dir), 0.0f);
        float NdotH = std::max(normal.dot(h), 0.0f);

        // æ³•çº¿åˆ†å¸ƒå‡½æ•° (GGX/Trowbridge-Reitz)
        float D = distribution_ggx(NdotH, roughness);

        // å‡ ä½•å‡½æ•°
        float G = geometry_smith(normal, view_dir, light_dir, roughness);

        // è²æ¶…å°”é¡¹
        Vector3f F = fresnel_schlick(HdotV, F0);

        // Cook-Torrance BRDF
        Vector3f numerator = D * G * F;
        float denominator = 4.0f * NdotV * NdotL + 0.0001f;  // é˜²æ­¢é™¤é›¶
        Vector3f specular = numerator / denominator;

        // æ¼«åå°„éƒ¨åˆ†
        Vector3f kS = F;
        Vector3f kD = Vector3f(1.0f, 1.0f, 1.0f) - kS;
        kD *= 1.0f - metallic;  // é‡‘å±æ²¡æœ‰æ¼«åå°„

        Vector3f diffuse = kD * albedo / M_PI;

        return (diffuse + specular) * NdotL;
    }

private:
    float distribution_ggx(float NdotH, float roughness) const {
        float a = roughness * roughness;
        float a2 = a * a;
        float NdotH2 = NdotH * NdotH;

        float num = a2;
        float denom = (NdotH2 * (a2 - 1.0f) + 1.0f);
        denom = M_PI * denom * denom;

        return num / denom;
    }

    float geometry_schlick_ggx(float NdotV, float roughness) const {
        float r = (roughness + 1.0f);
        float k = (r * r) / 8.0f;

        float num = NdotV;
        float denom = NdotV * (1.0f - k) + k;

        return num / denom;
    }

    float geometry_smith(const Vector3f& N, const Vector3f& V,
                        const Vector3f& L, float roughness) const {
        float NdotV = std::max(N.dot(V), 0.0f);
        float NdotL = std::max(N.dot(L), 0.0f);
        float ggx2 = geometry_schlick_ggx(NdotV, roughness);
        float ggx1 = geometry_schlick_ggx(NdotL, roughness);

        return ggx1 * ggx2;
    }

    Vector3f fresnel_schlick(float cosTheta, const Vector3f& F0) const {
        return F0 + (Vector3f(1.0f, 1.0f, 1.0f) - F0) *
               std::pow(std::clamp(1.0f - cosTheta, 0.0f, 1.0f), 5.0f);
    }
};
```

## 26.2 åŸºäºå›¾åƒçš„å…‰ç…§(IBL)

### 26.2.1 ç¯å¢ƒè´´å›¾

```cpp
class IBLRenderer {
private:
    GLuint environment_map;
    GLuint irradiance_map;
    GLuint prefilter_map;
    GLuint brdf_lut;

public:
    void setup_ibl(const std::string& hdr_path) {
        // åŠ è½½HDRç¯å¢ƒè´´å›¾
        load_hdr_environment(hdr_path);

        // ç”Ÿæˆè¾ç…§åº¦è´´å›¾
        generate_irradiance_map();

        // ç”Ÿæˆé¢„è¿‡æ»¤ç¯å¢ƒè´´å›¾
        generate_prefilter_map();

        // ç”ŸæˆBRDFæŸ¥æ‰¾è¡¨
        generate_brdf_lut();
    }

    Vector3f sample_environment_lighting(const Vector3f& normal, const Vector3f& view_dir,
                                        const PBRMaterial& material) const {
        Vector3f reflection = reflect(-view_dir, normal);

        // æ¼«åå°„éƒ¨åˆ†ï¼šä»è¾ç…§åº¦è´´å›¾é‡‡æ ·
        Vector3f irradiance = sample_irradiance_map(normal);
        Vector3f diffuse = irradiance * material.get_albedo();

        // é•œé¢åå°„éƒ¨åˆ†ï¼šä»é¢„è¿‡æ»¤è´´å›¾é‡‡æ ·
        float roughness = material.get_roughness();
        Vector3f prefiltered_color = sample_prefilter_map(reflection, roughness);

        // BRDFç§¯åˆ†
        float NdotV = std::max(normal.dot(view_dir), 0.0f);
        Vector2f brdf_sample = sample_brdf_lut(NdotV, roughness);
        Vector3f F0 = material.get_F0();
        Vector3f specular = prefiltered_color * (F0 * brdf_sample.x() + brdf_sample.y());

        // ç»„åˆç»“æœ
        Vector3f kS = fresnel_schlick_roughness(NdotV, F0, roughness);
        Vector3f kD = Vector3f(1.0f, 1.0f, 1.0f) - kS;
        kD *= 1.0f - material.get_metallic();

        return kD * diffuse + specular;
    }

private:
    void load_hdr_environment(const std::string& path) {
        // åŠ è½½HDRå›¾åƒ
        int width, height, channels;
        float* data = stbi_loadf(path.c_str(), &width, &height, &channels, 0);

        if (data) {
            glGenTextures(1, &environment_map);
            glBindTexture(GL_TEXTURE_2D, environment_map);
            glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB16F, width, height, 0, GL_RGB, GL_FLOAT, data);

            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

            stbi_image_free(data);
        }
    }

    void generate_irradiance_map() {
        // åˆ›å»ºç«‹æ–¹ä½“è´´å›¾
        glGenTextures(1, &irradiance_map);
        glBindTexture(GL_TEXTURE_CUBE_MAP, irradiance_map);

        for (unsigned int i = 0; i < 6; ++i) {
            glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB16F,
                        32, 32, 0, GL_RGB, GL_FLOAT, nullptr);
        }

        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

        // ä½¿ç”¨è®¡ç®—ç€è‰²å™¨æˆ–æ¸²æŸ“åˆ°ç«‹æ–¹ä½“è´´å›¾çš„æ–¹å¼ç”Ÿæˆè¾ç…§åº¦è´´å›¾
        render_irradiance_convolution();
    }

    void generate_prefilter_map() {
        glGenTextures(1, &prefilter_map);
        glBindTexture(GL_TEXTURE_CUBE_MAP, prefilter_map);

        for (unsigned int i = 0; i < 6; ++i) {
            glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB16F,
                        128, 128, 0, GL_RGB, GL_FLOAT, nullptr);
        }

        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
        glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

        glGenerateMipmap(GL_TEXTURE_CUBE_MAP);

        // ä¸ºæ¯ä¸ªmipçº§åˆ«æ¸²æŸ“ä¸åŒç²—ç³™åº¦çš„é¢„è¿‡æ»¤è´´å›¾
        render_prefilter_convolution();
    }

    void generate_brdf_lut() {
        glGenTextures(1, &brdf_lut);
        glBindTexture(GL_TEXTURE_2D, brdf_lut);
        glTexImage2D(GL_TEXTURE_2D, 0, GL_RG16F, 512, 512, 0, GL_RG, GL_FLOAT, 0);

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

        // æ¸²æŸ“BRDFç§¯åˆ†æŸ¥æ‰¾è¡¨
        render_brdf_integration();
    }

    Vector3f fresnel_schlick_roughness(float cosTheta, const Vector3f& F0, float roughness) const {
        return F0 + (std::max(Vector3f(1.0f - roughness, 1.0f - roughness, 1.0f - roughness), F0) - F0) *
               std::pow(std::clamp(1.0f - cosTheta, 0.0f, 1.0f), 5.0f);
    }
};
```

---

## ä½“ç§¯æ¸²æŸ“ä¸å‚ä¸ä»‹è´¨

## 27.1 ä½“ç§¯æ¸²æŸ“ç†è®º

### 27.1.1 ä½“ç§¯æ¸²æŸ“æ–¹ç¨‹

**ä½“ç§¯æ¸²æŸ“ç§¯åˆ†æ–¹ç¨‹**ï¼š
$$L(x, \omega) = \int_0^d T(x, x + t\omega) \sigma_s(x + t\omega) \int_{4\pi} p(x + t\omega, \omega', \omega) L(x + t\omega, \omega') d\omega' dt + T(x, x + d\omega) L(x + d\omega, \omega)$$

å…¶ä¸­ï¼š

- $T(x, y)$ æ˜¯é€å°„ç‡å‡½æ•°
- $\sigma_s$ æ˜¯æ•£å°„ç³»æ•°
- $p(\omega', \omega)$ æ˜¯ç›¸ä½å‡½æ•°
- $d$ æ˜¯å…‰çº¿ä¼ æ’­è·ç¦»

**é€å°„ç‡å‡½æ•°**ï¼š
$$T(x, y) = \exp\left(-\int_0^{||y-x||} \sigma_t(x + s \cdot \frac{y-x}{||y-x||}) ds\right)$$

**ç›¸ä½å‡½æ•°(Henyey-Greenstein)**ï¼š
$$p(\cos\theta) = \frac{1 - g^2}{4\pi(1 + g^2 - 2g\cos\theta)^{3/2}}$$

å…¶ä¸­$g \in [-1, 1]$æ˜¯å„å‘å¼‚æ€§å‚æ•°ã€‚

```cpp
class VolumeRenderer {
private:
    struct VolumeProperties {
        float density;           // å¯†åº¦
        float absorption;        // å¸æ”¶ç³»æ•°
        float scattering;        // æ•£å°„ç³»æ•°
        float anisotropy;        // å„å‘å¼‚æ€§å‚æ•°g
        Vector3f albedo;         // æ•£å°„åç…§ç‡

        float extinction() const { return absorption + scattering; }
    };

    struct VolumeData {
        std::vector<float> density_grid;
        int width, height, depth;
        Vector3f bounds_min, bounds_max;

        float sample_density(const Vector3f& pos) const {
            // ä¸‰çº¿æ€§æ’å€¼é‡‡æ ·å¯†åº¦
            Vector3f normalized_pos = (pos - bounds_min).cwiseQuotient(bounds_max - bounds_min);

            if (normalized_pos.x() < 0 || normalized_pos.x() > 1 ||
                normalized_pos.y() < 0 || normalized_pos.y() > 1 ||
                normalized_pos.z() < 0 || normalized_pos.z() > 1) {
                return 0.0f;
            }

            return trilinear_interpolate(normalized_pos);
        }

    private:
        float trilinear_interpolate(const Vector3f& pos) const {
            float x = pos.x() * (width - 1);
            float y = pos.y() * (height - 1);
            float z = pos.z() * (depth - 1);

            int x0 = static_cast<int>(x), x1 = std::min(x0 + 1, width - 1);
            int y0 = static_cast<int>(y), y1 = std::min(y0 + 1, height - 1);
            int z0 = static_cast<int>(z), z1 = std::min(z0 + 1, depth - 1);

            float fx = x - x0, fy = y - y0, fz = z - z0;

            auto get_density = [this](int x, int y, int z) {
                return density_grid[z * width * height + y * width + x];
            };

            // ä¸‰çº¿æ€§æ’å€¼
            float c000 = get_density(x0, y0, z0);
            float c001 = get_density(x0, y0, z1);
            float c010 = get_density(x0, y1, z0);
            float c011 = get_density(x0, y1, z1);
            float c100 = get_density(x1, y0, z0);
            float c101 = get_density(x1, y0, z1);
            float c110 = get_density(x1, y1, z0);
            float c111 = get_density(x1, y1, z1);

            float c00 = c000 * (1 - fx) + c100 * fx;
            float c01 = c001 * (1 - fx) + c101 * fx;
            float c10 = c010 * (1 - fx) + c110 * fx;
            float c11 = c011 * (1 - fx) + c111 * fx;

            float c0 = c00 * (1 - fy) + c10 * fy;
            float c1 = c01 * (1 - fy) + c11 * fy;

            return c0 * (1 - fz) + c1 * fz;
        }
    };

    VolumeData volume_data;
    VolumeProperties volume_props;

public:
    Vector3f render_volume_ray(const Ray& ray, float t_min, float t_max,
                              const std::vector<Light>& lights) const {
        Vector3f color(0, 0, 0);
        float transmittance = 1.0f;

        // å…‰çº¿æ­¥è¿›å‚æ•°
        float step_size = 0.1f;
        int num_steps = static_cast<int>((t_max - t_min) / step_size);

        for (int i = 0; i < num_steps; ++i) {
            float t = t_min + i * step_size;
            Vector3f pos = ray.origin + t * ray.direction;

            // é‡‡æ ·ä½“ç§¯å¯†åº¦
            float density = volume_data.sample_density(pos);
            if (density <= 0.0f) continue;

            // è®¡ç®—ä½“ç§¯å±æ€§
            float extinction = volume_props.extinction() * density;
            float scattering = volume_props.scattering * density;

            // è®¡ç®—é€å°„ç‡è¡°å‡
            float step_transmittance = std::exp(-extinction * step_size);

            // è®¡ç®—æ•£å°„å…‰ç…§
            Vector3f scattered_light = calculate_in_scattering(pos, -ray.direction, lights, density);

            // ç´¯ç§¯é¢œè‰²
            color += transmittance * (1.0f - step_transmittance) * scattered_light;

            // æ›´æ–°é€å°„ç‡
            transmittance *= step_transmittance;

            // æ—©æœŸç»ˆæ­¢ä¼˜åŒ–
            if (transmittance < 0.01f) break;
        }

        return color;
    }

private:
    Vector3f calculate_in_scattering(const Vector3f& pos, const Vector3f& view_dir,
                                   const std::vector<Light>& lights, float density) const {
        Vector3f scattered_light(0, 0, 0);

        for (const auto& light : lights) {
            Vector3f light_dir = (light.position - pos).normalized();
            float light_distance = (light.position - pos).norm();

            // è®¡ç®—åˆ°å…‰æºçš„é€å°„ç‡
            float light_transmittance = calculate_transmittance(pos, light.position);

            // ç›¸ä½å‡½æ•°
            float cos_theta = view_dir.dot(light_dir);
            float phase = henyey_greenberg_phase(cos_theta, volume_props.anisotropy);

            // å…‰ç…§è¡°å‡
            float attenuation = 1.0f / (light_distance * light_distance);

            // æ•£å°„è´¡çŒ®
            Vector3f light_contribution = light.color * light.intensity * attenuation *
                                        light_transmittance * phase * volume_props.scattering * density;

            scattered_light += light_contribution * volume_props.albedo;
        }

        return scattered_light;
    }

    float calculate_transmittance(const Vector3f& start, const Vector3f& end) const {
        Vector3f direction = (end - start).normalized();
        float distance = (end - start).norm();

        float transmittance = 1.0f;
        float step_size = 0.1f;
        int num_steps = static_cast<int>(distance / step_size);

        for (int i = 0; i < num_steps; ++i) {
            float t = i * step_size;
            Vector3f pos = start + t * direction;

            float density = volume_data.sample_density(pos);
            float extinction = volume_props.extinction() * density;

            transmittance *= std::exp(-extinction * step_size);

            if (transmittance < 0.01f) break;
        }

        return transmittance;
    }

    float henyey_greenberg_phase(float cos_theta, float g) const {
        float g2 = g * g;
        float denom = 1.0f + g2 - 2.0f * g * cos_theta;
        return (1.0f - g2) / (4.0f * M_PI * std::pow(denom, 1.5f));
    }
};
```

## 27.2 äº‘æ¸²æŸ“

```cpp
class CloudRenderer {
private:
    struct CloudLayer {
        float altitude_min, altitude_max;
        float density_multiplier;
        float coverage;
        Vector2f wind_direction;
        float wind_speed;

        // å™ªå£°å‚æ•°
        float noise_scale;
        float detail_scale;
        int octaves;
    };

    std::vector<CloudLayer> cloud_layers;
    GLuint noise_texture_3d;
    GLuint weather_texture;

public:
    void setup_cloud_system() {
        // ç”Ÿæˆ3Då™ªå£°çº¹ç†
        generate_3d_noise_texture();

        // ç”Ÿæˆå¤©æ°”è´´å›¾
        generate_weather_texture();

        // è®¾ç½®äº‘å±‚
        setup_cloud_layers();
    }

    Vector4f render_clouds(const Ray& ray, float t_min, float t_max,
                          const Vector3f& sun_direction) const {
        Vector3f color(0, 0, 0);
        float alpha = 0.0f;

        // å…‰çº¿æ­¥è¿›
        float step_size = 100.0f;  // äº‘æ¸²æŸ“ä½¿ç”¨è¾ƒå¤§æ­¥é•¿
        int num_steps = static_cast<int>((t_max - t_min) / step_size);

        for (int i = 0; i < num_steps; ++i) {
            float t = t_min + i * step_size;
            Vector3f pos = ray.origin + t * ray.direction;

            // é‡‡æ ·äº‘å¯†åº¦
            float cloud_density = sample_cloud_density(pos);
            if (cloud_density <= 0.0f) continue;

            // è®¡ç®—å…‰ç…§
            Vector3f light_color = calculate_cloud_lighting(pos, sun_direction, cloud_density);

            // é€æ˜åº¦æ··åˆ
            float step_alpha = 1.0f - std::exp(-cloud_density * step_size * 0.01f);
            color += (1.0f - alpha) * step_alpha * light_color;
            alpha += (1.0f - alpha) * step_alpha;

            // æ—©æœŸç»ˆæ­¢
            if (alpha > 0.99f) break;
        }

        return Vector4f(color.x(), color.y(), color.z(), alpha);
    }

private:
    float sample_cloud_density(const Vector3f& pos) const {
        float total_density = 0.0f;

        for (const auto& layer : cloud_layers) {
            if (pos.y() < layer.altitude_min || pos.y() > layer.altitude_max) {
                continue;
            }

            // é«˜åº¦è¡°å‡
            float height_fraction = (pos.y() - layer.altitude_min) /
                                  (layer.altitude_max - layer.altitude_min);
            float height_gradient = 4.0f * height_fraction * (1.0f - height_fraction);

            // åŸºç¡€å™ªå£°
            Vector3f noise_coord = pos * layer.noise_scale;
            float base_noise = sample_3d_noise(noise_coord);

            // ç»†èŠ‚å™ªå£°
            Vector3f detail_coord = pos * layer.detail_scale;
            float detail_noise = sample_3d_noise(detail_coord);

            // ç»„åˆå™ªå£°
            float combined_noise = base_noise * 0.7f + detail_noise * 0.3f;

            // åº”ç”¨è¦†ç›–ç‡å’Œé«˜åº¦æ¢¯åº¦
            float density = std::max(0.0f, combined_noise - (1.0f - layer.coverage));
            density *= height_gradient * layer.density_multiplier;

            total_density += density;
        }

        return std::min(total_density, 1.0f);
    }

    Vector3f calculate_cloud_lighting(const Vector3f& pos, const Vector3f& sun_dir,
                                    float density) const {
        // åŸºç¡€ç¯å¢ƒå…‰
        Vector3f ambient = Vector3f(0.6f, 0.7f, 0.8f) * 0.3f;

        // å¤ªé˜³å…‰æ•£å°„
        float sun_transmittance = calculate_sun_transmittance(pos, sun_dir);
        Vector3f sun_color = Vector3f(1.0f, 0.9f, 0.7f) * sun_transmittance;

        // Henyey-Greenbergç›¸ä½å‡½æ•°ï¼ˆäº‘çš„å‰å‘æ•£å°„ï¼‰
        float cos_theta = -sun_dir.dot(Vector3f(0, -1, 0));  // å‡è®¾è§†çº¿å‘ä¸‹
        float phase = henyey_greenberg_phase(cos_theta, 0.3f);  // è½»å¾®å‰å‘æ•£å°„

        // ç»„åˆå…‰ç…§
        Vector3f total_light = ambient + sun_color * phase;

        // åº”ç”¨å¯†åº¦
        return total_light * density;
    }

    float calculate_sun_transmittance(const Vector3f& pos, const Vector3f& sun_dir) const {
        // ç®€åŒ–çš„å¤ªé˜³å…‰é€å°„ç‡è®¡ç®—
        float transmittance = 1.0f;
        float step_size = 50.0f;

        for (int i = 0; i < 10; ++i) {  // æœ‰é™æ­¥æ•°çš„å…‰çº¿è¡Œè¿›
            Vector3f sample_pos = pos + i * step_size * sun_dir;
            float density = sample_cloud_density(sample_pos);
            transmittance *= std::exp(-density * step_size * 0.005f);

            if (transmittance < 0.1f) break;
        }

        return transmittance;
    }

    float sample_3d_noise(const Vector3f& coord) const {
        // è¿™é‡Œåº”è¯¥ä»3Då™ªå£°çº¹ç†é‡‡æ ·
        // ç®€åŒ–å®ç°ï¼šä½¿ç”¨ç¨‹åºåŒ–å™ªå£°
        return (std::sin(coord.x()) * std::cos(coord.y()) * std::sin(coord.z()) + 1.0f) * 0.5f;
    }

    void generate_3d_noise_texture() {
        // ç”Ÿæˆ3D Perlinå™ªå£°çº¹ç†
        const int size = 128;
        std::vector<float> noise_data(size * size * size);

        for (int z = 0; z < size; ++z) {
            for (int y = 0; y < size; ++y) {
                for (int x = 0; x < size; ++x) {
                    Vector3f coord(x / float(size), y / float(size), z / float(size));
                    int index = z * size * size + y * size + x;
                    noise_data[index] = generate_perlin_noise(coord * 8.0f);
                }
            }
        }

        glGenTextures(1, &noise_texture_3d);
        glBindTexture(GL_TEXTURE_3D, noise_texture_3d);
        glTexImage3D(GL_TEXTURE_3D, 0, GL_R16F, size, size, size, 0, GL_RED, GL_FLOAT, noise_data.data());

        glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_REPEAT);
    }

    float generate_perlin_noise(const Vector3f& coord) const {
        // ç®€åŒ–çš„Perlinå™ªå£°å®ç°
        return (std::sin(coord.x()) * std::cos(coord.y()) * std::sin(coord.z()) + 1.0f) * 0.5f;
    }

    float henyey_greenberg_phase(float cos_theta, float g) const {
        float g2 = g * g;
        float denom = 1.0f + g2 - 2.0f * g * cos_theta;
        return (1.0f - g2) / (4.0f * M_PI * std::pow(denom, 1.5f));
    }
};
```

---

## è®¡ç®—ç€è‰²å™¨ä¸GPGPU

## 28.1 è®¡ç®—ç€è‰²å™¨åŸºç¡€

### 28.1.1 å·¥ä½œç»„å’Œçº¿ç¨‹æ¨¡å‹

**å·¥ä½œç»„å¤§å°**ï¼š

- æœ¬åœ°å·¥ä½œç»„å¤§å°ï¼š$(local\_size\_x, local\_size\_y, local\_size\_z)$
- å…¨å±€å·¥ä½œç»„æ•°é‡ï¼š$(num\_groups\_x, num\_groups\_y, num\_groups\_z)$
- æ€»çº¿ç¨‹æ•°ï¼š$total\_threads = local\_size \times num\_groups$

**çº¿ç¨‹ç´¢å¼•è®¡ç®—**ï¼š
$$global\_id = local\_id + group\_id \times local\_size$$

```cpp
class ComputeShaderManager {
private:
    struct ComputeProgram {
        GLuint program_id;
        GLuint shader_id;
        std::unordered_map<std::string, GLint> uniform_locations;

        ComputeProgram() : program_id(0), shader_id(0) {}

        ~ComputeProgram() {
            if (shader_id) glDeleteShader(shader_id);
            if (program_id) glDeleteProgram(program_id);
        }
    };

    std::unordered_map<std::string, std::unique_ptr<ComputeProgram>> programs;

public:
    bool create_compute_program(const std::string& name, const std::string& source) {
        auto program = std::make_unique<ComputeProgram>();

        // åˆ›å»ºè®¡ç®—ç€è‰²å™¨
        program->shader_id = glCreateShader(GL_COMPUTE_SHADER);
        const char* source_ptr = source.c_str();
        glShaderSource(program->shader_id, 1, &source_ptr, nullptr);
        glCompileShader(program->shader_id);

        // æ£€æŸ¥ç¼–è¯‘é”™è¯¯
        GLint success;
        glGetShaderiv(program->shader_id, GL_COMPILE_STATUS, &success);
        if (!success) {
            char info_log[512];
            glGetShaderInfoLog(program->shader_id, 512, nullptr, info_log);
            std::cerr << "è®¡ç®—ç€è‰²å™¨ç¼–è¯‘å¤±è´¥: " << info_log << std::endl;
            return false;
        }

        // åˆ›å»ºç¨‹åº
        program->program_id = glCreateProgram();
        glAttachShader(program->program_id, program->shader_id);
        glLinkProgram(program->program_id);

        // æ£€æŸ¥é“¾æ¥é”™è¯¯
        glGetProgramiv(program->program_id, GL_LINK_STATUS, &success);
        if (!success) {
            char info_log[512];
            glGetProgramInfoLog(program->program_id, 512, nullptr, info_log);
            std::cerr << "è®¡ç®—ç€è‰²å™¨ç¨‹åºé“¾æ¥å¤±è´¥: " << info_log << std::endl;
            return false;
        }

        programs[name] = std::move(program);
        return true;
    }

    void dispatch_compute(const std::string& program_name,
                         GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z) {
        auto it = programs.find(program_name);
        if (it == programs.end()) {
            std::cerr << "è®¡ç®—ç€è‰²å™¨ç¨‹åºæœªæ‰¾åˆ°: " << program_name << std::endl;
            return;
        }

        glUseProgram(it->second->program_id);
        glDispatchCompute(num_groups_x, num_groups_y, num_groups_z);
        glMemoryBarrier(GL_SHADER_STORAGE_BARRIER_BIT);
    }

    void set_uniform(const std::string& program_name, const std::string& uniform_name,
                    float value) {
        auto it = programs.find(program_name);
        if (it == programs.end()) return;

        auto& program = it->second;
        auto uniform_it = program->uniform_locations.find(uniform_name);

        GLint location;
        if (uniform_it == program->uniform_locations.end()) {
            location = glGetUniformLocation(program->program_id, uniform_name.c_str());
            program->uniform_locations[uniform_name] = location;
        } else {
            location = uniform_it->second;
        }

        if (location != -1) {
            glUseProgram(program->program_id);
            glUniform1f(location, value);
        }
    }
};
```

## 28.2 å¹¶è¡Œç®—æ³•å®ç°

### 28.2.1 å¹¶è¡Œå‰ç¼€å’Œ(Prefix Sum)

```cpp
class ParallelPrefixSum {
private:
    ComputeShaderManager compute_manager;
    GLuint input_buffer, output_buffer, temp_buffer;

    const std::string upsweep_shader = R"(
        #version 430
        layout(local_size_x = 256) in;

        layout(std430, binding = 0) restrict buffer InputBuffer {
            float input_data[];
        };

        layout(std430, binding = 1) restrict buffer TempBuffer {
            float temp_data[];
        };

        uniform int step;
        uniform int n;

        void main() {
            uint index = gl_GlobalInvocationID.x;
            uint stride = 1u << step;
            uint read_index = (index + 1u) * stride * 2u - 1u;

            if (read_index < n) {
                uint write_index = read_index + stride;
                if (write_index < n) {
                    temp_data[write_index] += temp_data[read_index];
                }
            }
        }
    )";

    const std::string downsweep_shader = R"(
        #version 430
        layout(local_size_x = 256) in;

        layout(std430, binding = 1) restrict buffer TempBuffer {
            float temp_data[];
        };

        layout(std430, binding = 2) restrict buffer OutputBuffer {
            float output_data[];
        };

        uniform int step;
        uniform int n;

        void main() {
            uint index = gl_GlobalInvocationID.x;
            uint stride = 1u << (step + 1);
            uint read_index = (index + 1u) * stride - 1u;

            if (read_index < n) {
                uint write_index = read_index + (stride >> 1);
                if (write_index < n) {
                    float temp = temp_data[read_index];
                    temp_data[read_index] = temp_data[write_index];
                    temp_data[write_index] += temp;
                }
            }
        }
    )";

public:
    void setup(int max_size) {
        // åˆ›å»ºç¼“å†²åŒº
        glGenBuffers(1, &input_buffer);
        glGenBuffers(1, &output_buffer);
        glGenBuffers(1, &temp_buffer);

        glBindBuffer(GL_SHADER_STORAGE_BUFFER, input_buffer);
        glBufferData(GL_SHADER_STORAGE_BUFFER, max_size * sizeof(float), nullptr, GL_DYNAMIC_DRAW);

        glBindBuffer(GL_SHADER_STORAGE_BUFFER, output_buffer);
        glBufferData(GL_SHADER_STORAGE_BUFFER, max_size * sizeof(float), nullptr, GL_DYNAMIC_DRAW);

        glBindBuffer(GL_SHADER_STORAGE_BUFFER, temp_buffer);
        glBufferData(GL_SHADER_STORAGE_BUFFER, max_size * sizeof(float), nullptr, GL_DYNAMIC_DRAW);

        // ç¼–è¯‘ç€è‰²å™¨
        compute_manager.create_compute_program("upsweep", upsweep_shader);
        compute_manager.create_compute_program("downsweep", downsweep_shader);
    }

    void compute_prefix_sum(const std::vector<float>& input, std::vector<float>& output) {
        int n = input.size();
        output.resize(n);

        // ä¸Šä¼ è¾“å…¥æ•°æ®
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, input_buffer);
        glBufferSubData(GL_SHADER_STORAGE_BUFFER, 0, n * sizeof(float), input.data());

        // å¤åˆ¶åˆ°ä¸´æ—¶ç¼“å†²åŒº
        glBindBuffer(GL_COPY_READ_BUFFER, input_buffer);
        glBindBuffer(GL_COPY_WRITE_BUFFER, temp_buffer);
        glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, n * sizeof(float));

        // ç»‘å®šç¼“å†²åŒº
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, input_buffer);
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, temp_buffer);
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 2, output_buffer);

        // Up-sweepé˜¶æ®µ
        int steps = static_cast<int>(std::ceil(std::log2(n)));
        for (int step = 0; step < steps; ++step) {
            compute_manager.set_uniform("upsweep", "step", static_cast<float>(step));
            compute_manager.set_uniform("upsweep", "n", static_cast<float>(n));

            int num_groups = (n + 255) / 256;
            compute_manager.dispatch_compute("upsweep", num_groups, 1, 1);
        }

        // æ¸…é›¶æœ€åä¸€ä¸ªå…ƒç´ 
        float zero = 0.0f;
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, temp_buffer);
        glBufferSubData(GL_SHADER_STORAGE_BUFFER, (n - 1) * sizeof(float), sizeof(float), &zero);

        // Down-sweepé˜¶æ®µ
        for (int step = steps - 1; step >= 0; --step) {
            compute_manager.set_uniform("downsweep", "step", static_cast<float>(step));
            compute_manager.set_uniform("downsweep", "n", static_cast<float>(n));

            int num_groups = (n + 255) / 256;
            compute_manager.dispatch_compute("downsweep", num_groups, 1, 1);
        }

        // å¤åˆ¶ç»“æœ
        glBindBuffer(GL_COPY_READ_BUFFER, temp_buffer);
        glBindBuffer(GL_COPY_WRITE_BUFFER, output_buffer);
        glCopyBufferSubData(GL_COPY_READ_BUFFER, GL_COPY_WRITE_BUFFER, 0, 0, n * sizeof(float));

        // ä¸‹è½½ç»“æœ
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, output_buffer);
        float* result = static_cast<float*>(glMapBuffer(GL_SHADER_STORAGE_BUFFER, GL_READ_ONLY));
        std::copy(result, result + n, output.begin());
        glUnmapBuffer(GL_SHADER_STORAGE_BUFFER);
    }
};
```

### 28.2.2 GPUç²’å­ç³»ç»Ÿ

```cpp
class GPUParticleSystem {
private:
    struct Particle {
        Vector3f position;
        float life;
        Vector3f velocity;
        float size;
        Vector4f color;
        Vector3f acceleration;
        float padding;
    };

    GLuint particle_buffer;
    GLuint counter_buffer;
    GLuint indirect_buffer;
    ComputeShaderManager compute_manager;

    const std::string update_shader = R"(
        #version 430
        layout(local_size_x = 256) in;

        struct Particle {
            vec3 position;
            float life;
            vec3 velocity;
            float size;
            vec4 color;
            vec3 acceleration;
            float padding;
        };

        layout(std430, binding = 0) restrict buffer ParticleBuffer {
            Particle particles[];
        };

        layout(std430, binding = 1) restrict buffer CounterBuffer {
            uint alive_count;
            uint dead_count;
            uint alive_list[];
        };

        uniform float delta_time;
        uniform vec3 gravity;
        uniform float damping;

        void main() {
            uint index = gl_GlobalInvocationID.x;
            if (index >= particles.length()) return;

            Particle p = particles[index];

            // æ›´æ–°ç”Ÿå‘½å‘¨æœŸ
            p.life -= delta_time;

            if (p.life > 0.0) {
                // æ›´æ–°ç‰©ç†
                p.acceleration += gravity;
                p.velocity += p.acceleration * delta_time;
                p.velocity *= damping;
                p.position += p.velocity * delta_time;

                // æ›´æ–°é¢œè‰²ï¼ˆåŸºäºç”Ÿå‘½å‘¨æœŸï¼‰
                float life_ratio = p.life / 5.0; // å‡è®¾æœ€å¤§ç”Ÿå‘½å‘¨æœŸä¸º5ç§’
                p.color.a = life_ratio;

                // é‡ç½®åŠ é€Ÿåº¦
                p.acceleration = vec3(0.0);

                particles[index] = p;

                // æ·»åŠ åˆ°æ´»è·ƒåˆ—è¡¨
                uint alive_index = atomicAdd(alive_count, 1);
                alive_list[alive_index] = index;
            } else {
                // ç²’å­æ­»äº¡
                atomicAdd(dead_count, 1);
            }
        }
    )";

    const std::string emit_shader = R"(
        #version 430
        layout(local_size_x = 64) in;

        struct Particle {
            vec3 position;
            float life;
            vec3 velocity;
            float size;
            vec4 color;
            vec3 acceleration;
            float padding;
        };

        layout(std430, binding = 0) restrict buffer ParticleBuffer {
            Particle particles[];
        };

        layout(std430, binding = 1) restrict buffer CounterBuffer {
            uint alive_count;
            uint dead_count;
            uint alive_list[];
        };

        uniform vec3 emitter_position;
        uniform vec3 emitter_direction;
        uniform float emit_rate;
        uniform float delta_time;
        uniform uint random_seed;

        // ç®€å•çš„éšæœºæ•°ç”Ÿæˆå™¨
        uint hash(uint x) {
            x += (x << 10u);
            x ^= (x >> 6u);
            x += (x << 3u);
            x ^= (x >> 11u);
            x += (x << 15u);
            return x;
        }

        float random(uint seed) {
            return float(hash(seed)) / 4294967295.0;
        }

        void main() {
            uint index = gl_GlobalInvocationID.x;

            // è®¡ç®—éœ€è¦å‘å°„çš„ç²’å­æ•°é‡
            uint emit_count = uint(emit_rate * delta_time);
            if (index >= emit_count) return;

            // æŸ¥æ‰¾æ­»äº¡çš„ç²’å­è¿›è¡Œé‡ç”¨
            if (dead_count > 0) {
                uint dead_index = atomicAdd(dead_count, -1) - 1;
                if (dead_index < particles.length()) {
                    uint particle_index = dead_index; // ç®€åŒ–ï¼šç›´æ¥ä½¿ç”¨ç´¢å¼•

                    // åˆå§‹åŒ–æ–°ç²’å­
                    uint seed = random_seed + index * 1000u;

                    particles[particle_index].position = emitter_position +
                        vec3(random(seed) - 0.5, random(seed + 1u) - 0.5, random(seed + 2u) - 0.5) * 2.0;

                    particles[particle_index].life = 3.0 + random(seed + 3u) * 2.0; // 3-5ç§’ç”Ÿå‘½å‘¨æœŸ

                    vec3 random_dir = normalize(vec3(
                        random(seed + 4u) - 0.5,
                        random(seed + 5u) - 0.5,
                        random(seed + 6u) - 0.5
                    ));
                    particles[particle_index].velocity = emitter_direction + random_dir * 0.5;

                    particles[particle_index].size = 0.1 + random(seed + 7u) * 0.1;
                    particles[particle_index].color = vec4(1.0, 0.8, 0.2, 1.0);
                    particles[particle_index].acceleration = vec3(0.0);
                }
            }
        }
    )";

public:
    void setup(int max_particles) {
        // åˆ›å»ºç²’å­ç¼“å†²åŒº
        glGenBuffers(1, &particle_buffer);
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, particle_buffer);
        glBufferData(GL_SHADER_STORAGE_BUFFER, max_particles * sizeof(Particle), nullptr, GL_DYNAMIC_DRAW);

        // åˆ›å»ºè®¡æ•°å™¨ç¼“å†²åŒº
        glGenBuffers(1, &counter_buffer);
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, counter_buffer);
        glBufferData(GL_SHADER_STORAGE_BUFFER, (2 + max_particles) * sizeof(GLuint), nullptr, GL_DYNAMIC_DRAW);

        // åˆå§‹åŒ–è®¡æ•°å™¨
        GLuint initial_counts[2] = {0, static_cast<GLuint>(max_particles)};
        glBufferSubData(GL_SHADER_STORAGE_BUFFER, 0, 2 * sizeof(GLuint), initial_counts);

        // ç¼–è¯‘ç€è‰²å™¨
        compute_manager.create_compute_program("update_particles", update_shader);
        compute_manager.create_compute_program("emit_particles", emit_shader);
    }

    void update(float delta_time, const Vector3f& emitter_pos, const Vector3f& emitter_dir,
               float emit_rate) {
        // ç»‘å®šç¼“å†²åŒº
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 0, particle_buffer);
        glBindBufferBase(GL_SHADER_STORAGE_BUFFER, 1, counter_buffer);

        // é‡ç½®æ´»è·ƒè®¡æ•°
        GLuint zero = 0;
        glBindBuffer(GL_SHADER_STORAGE_BUFFER, counter_buffer);
        glBufferSubData(GL_SHADER_STORAGE_BUFFER, 0, sizeof(GLuint), &zero);

        // æ›´æ–°ç²’å­
        compute_manager.set_uniform("update_particles", "delta_time", delta_time);
        compute_manager.set_uniform("update_particles", "damping", 0.98f);
        compute_manager.dispatch_compute("update_particles", (10000 + 255) / 256, 1, 1);

        // å‘å°„æ–°ç²’å­
        compute_manager.set_uniform("emit_particles", "delta_time", delta_time);
        compute_manager.set_uniform("emit_particles", "emit_rate", emit_rate);
        compute_manager.set_uniform("emit_particles", "random_seed",
                                  static_cast<float>(std::rand()));
        compute_manager.dispatch_compute("emit_particles", (64 + 63) / 64, 1, 1);
    }

    GLuint get_particle_buffer() const { return particle_buffer; }
    GLuint get_counter_buffer() const { return counter_buffer; }
};
```

è¿™ä¸ªå®Œæ•´çš„è®¡ç®—æœºå›¾å½¢å­¦ç¬”è®°æ¶µç›–äº†ä»åŸºç¡€æ•°å­¦åˆ°é«˜çº§æ¸²æŸ“æŠ€æœ¯çš„æ‰€æœ‰é‡è¦ä¸»é¢˜ï¼Œä¸ºæ·±åº¦å­¦ä¹ å’Œè®¡ç®—æœºè§†è§‰æä¾›äº†åšå®çš„ç†è®ºåŸºç¡€å’Œå®è·µæŒ‡å¯¼ã€‚
